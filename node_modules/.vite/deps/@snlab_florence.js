import "./chunk-6CJGRA3E.js";
import {
  bisect_default,
  bisector_default,
  format,
  formatPrefix,
  formatSpecifier,
  precisionFixed_default,
  precisionPrefix_default,
  precisionRound_default,
  tickIncrement,
  tickStep,
  ticks_default
} from "./chunk-L7Z7LR23.js";
import {
  number_default,
  round_default,
  value_default
} from "./chunk-3TZ35GGH.js";
import "./chunk-X7HCJ7ZS.js";
import {
  writable
} from "./chunk-Q6OROXX5.js";
import {
  SvelteComponentDev,
  add_location,
  append_dev,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  component_subscribe,
  create_component,
  create_slot,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  safe_not_equal,
  setContext,
  set_data_maybe_contenteditable_dev,
  set_style,
  set_svg_attributes,
  space,
  svg_element,
  text,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-TJOAEWHY.js";
import "./chunk-NFXY5EW3.js";
import "./chunk-XNHBATJA.js";

// node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
    this._ += arguments[i2] + strings[i2];
  }
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15)
    return append;
  const k3 = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i2 = 1, n2 = strings.length; i2 < n2; ++i2) {
      this._ += Math.round(arguments[i2] * k3) / k3 + strings[i2];
    }
  };
}
var Path = class {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x3, y3) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x3, y3) {
    this._append`L${this._x1 = +x3},${this._y1 = +y3}`;
  }
  quadraticCurveTo(x1, y1, x3, y3) {
    this._append`Q${+x1},${+y1},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  bezierCurveTo(x1, y1, x23, y23, x3, y3) {
    this._append`C${+x1},${+y1},${+x23},${+y23},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x23, y23, r2) {
    x1 = +x1, y1 = +y1, x23 = +x23, y23 = +y23, r2 = +r2;
    if (r2 < 0)
      throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x23 - x1, y21 = y23 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x23 - x0, y20 = y23 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x3, y3, r2, a0, a1, ccw) {
    x3 = +x3, y3 = +y3, r2 = +r2, ccw = !!ccw;
    if (r2 < 0)
      throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x3 + dx, y0 = y3 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }
    if (!r2)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r2},${r2},0,1,${cw},${x3 - dx},${y3 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon) {
      this._append`A${r2},${r2},0,${+(da >= pi)},${cw},${this._x1 = x3 + r2 * Math.cos(a1)},${this._y1 = y3 + r2 * Math.sin(a1)}`;
    }
  }
  rect(x3, y3, w3, h2) {
    this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${w3 = +w3}v${+h2}h${-w3}Z`;
  }
  toString() {
    return this._;
  }
};
function path() {
  return new Path();
}
path.prototype = Path.prototype;

// node_modules/@snlab/rendervous/node_modules/d3-scale/src/init.js
function initRange(domain, range) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range).domain(domain);
      break;
  }
  return this;
}

// node_modules/@snlab/rendervous/node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");

// node_modules/@snlab/rendervous/node_modules/d3-scale/src/constant.js
function constants(x3) {
  return function() {
    return x3;
  };
}

// node_modules/@snlab/rendervous/node_modules/d3-scale/src/number.js
function number(x3) {
  return +x3;
}

// node_modules/@snlab/rendervous/node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity(x3) {
  return x3;
}
function normalize(a3, b2) {
  return (b2 -= a3 = +a3) ? function(x3) {
    return (x3 - a3) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a3, b2) {
  var t2;
  if (a3 > b2)
    t2 = a3, a3 = b2, b2 = t2;
  return function(x3) {
    return Math.max(a3, Math.min(b2, x3));
  };
}
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x3) {
    return r0(d0(x3));
  };
}
function polymap(domain, range, interpolate) {
  var j2 = Math.min(domain.length, range.length) - 1, d2 = new Array(j2), r2 = new Array(j2), i2 = -1;
  if (domain[j2] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }
  while (++i2 < j2) {
    d2[i2] = normalize(domain[i2], domain[i2 + 1]);
    r2[i2] = interpolate(range[i2], range[i2 + 1]);
  }
  return function(x3) {
    var i3 = bisect_default(domain, x3, 1, j2) - 1;
    return r2[i3](d2[i3](x3));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range = unit, interpolate = value_default, transform2, untransform, unknown, clamp2 = identity, piecewise2, output, input;
  function rescale2() {
    var n2 = Math.min(domain.length, range.length);
    if (clamp2 !== identity)
      clamp2 = clamper(domain[0], domain[n2 - 1]);
    piecewise2 = n2 > 2 ? polymap : bimap;
    output = input = null;
    return scale2;
  }
  function scale2(x3) {
    return x3 == null || isNaN(x3 = +x3) ? unknown : (output || (output = piecewise2(domain.map(transform2), range, interpolate)))(transform2(clamp2(x3)));
  }
  scale2.invert = function(y3) {
    return clamp2(untransform((input || (input = piecewise2(range, domain.map(transform2), number_default)))(y3)));
  };
  scale2.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number), rescale2()) : domain.slice();
  };
  scale2.range = function(_2) {
    return arguments.length ? (range = Array.from(_2), rescale2()) : range.slice();
  };
  scale2.rangeRound = function(_2) {
    return range = Array.from(_2), interpolate = round_default, rescale2();
  };
  scale2.clamp = function(_2) {
    return arguments.length ? (clamp2 = _2 ? true : identity, rescale2()) : clamp2 !== identity;
  };
  scale2.interpolate = function(_2) {
    return arguments.length ? (interpolate = _2, rescale2()) : interpolate;
  };
  scale2.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale2) : unknown;
  };
  return function(t2, u2) {
    transform2 = t2, untransform = u2;
    return rescale2();
  };
}
function continuous() {
  return transformer()(identity, identity);
}

// node_modules/@snlab/rendervous/node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/@snlab/rendervous/node_modules/d3-scale/src/linear.js
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count) {
    var d2 = domain();
    return ticks_default(d2[0], d2[d2.length - 1], count == null ? 10 : count);
  };
  scale2.tickFormat = function(count, specifier) {
    var d2 = domain();
    return tickFormat(d2[0], d2[d2.length - 1], count == null ? 10 : count, specifier);
  };
  scale2.nice = function(count) {
    if (count == null)
      count = 10;
    var d2 = domain();
    var i0 = 0;
    var i1 = d2.length - 1;
    var start = d2[i0];
    var stop = d2[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);
      if (step === prestep) {
        d2[i0] = start;
        d2[i1] = stop;
        return domain(d2);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy(scale2, linear());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}

// node_modules/@snlab/rendervous/node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date();
var t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date)), date;
  }
  interval.floor = (date) => {
    return floori(date = /* @__PURE__ */ new Date(+date)), date;
  };
  interval.ceil = (date) => {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };
  interval.round = (date) => {
    const d0 = interval(date), d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };
  interval.offset = (date, step) => {
    return offseti(date = /* @__PURE__ */ new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };
  interval.range = (start, stop, step) => {
    const range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0))
      return range;
    let previous;
    do
      range.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };
  interval.filter = (test) => {
    return timeInterval((date) => {
      if (date >= date)
        while (floori(date), !test(date))
          date.setTime(date - 1);
    }, (date, step) => {
      if (date >= date) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date, 1), !test(date)) {
            }
          }
      }
    });
  };
  if (count) {
    interval.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d2) => field(d2) % step === 0 : (d2) => interval.count(0, d2) % step === 0);
    };
  }
  return interval;
}

// node_modules/@snlab/rendervous/node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date, step) => {
  date.setTime(+date + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k3) => {
  k3 = Math.floor(k3);
  if (!isFinite(k3) || !(k3 > 0))
    return null;
  if (!(k3 > 1))
    return millisecond;
  return timeInterval((date) => {
    date.setTime(Math.floor(date / k3) * k3);
  }, (date, step) => {
    date.setTime(+date + step * k3);
  }, (start, end) => {
    return (end - start) / k3;
  });
};
var milliseconds = millisecond.range;

// node_modules/@snlab/rendervous/node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/@snlab/rendervous/node_modules/d3-time/src/second.js
var second = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds());
}, (date, step) => {
  date.setTime(+date + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date) => {
  return date.getUTCSeconds();
});
var seconds = second.range;

// node_modules/@snlab/rendervous/node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date) => {
  date.setUTCSeconds(0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/@snlab/rendervous/node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/@snlab/rendervous/node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date) => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date) => date.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return Math.floor(date / durationDay);
});
var unixDays = unixDay.range;

// node_modules/@snlab/rendervous/node_modules/d3-time/src/week.js
function timeWeekday(i2) {
  return timeInterval((date) => {
    date.setDate(date.getDate() - (date.getDay() + 7 - i2) % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setDate(date.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i2) {
  return timeInterval((date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i2) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/@snlab/rendervous/node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setMonth(date.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date) => {
  return date.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCMonth(date.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date) => {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/@snlab/rendervous/node_modules/d3-time/src/year.js
var timeYear = timeInterval((date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setFullYear(date.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date) => {
  return date.getFullYear();
});
timeYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date) => {
    date.setFullYear(Math.floor(date.getFullYear() / k3) * k3);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setFullYear(date.getFullYear() + step * k3);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date) => {
  return date.getUTCFullYear();
});
utcYear.every = (k3) => {
  return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date) => {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k3) * k3);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCFullYear(date.getUTCFullYear() + step * k3);
  });
};
var utcYears = utcYear.range;

// node_modules/@snlab/rendervous/node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks(start, stop, count) {
    const reverse = stop < start;
    if (reverse)
      [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks2 = interval ? interval.range(start, +stop + 1) : [];
    return reverse ? ticks2.reverse() : ticks2;
  }
  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i2 = bisector_default(([, , step2]) => step2).right(tickIntervals, target);
    if (i2 === tickIntervals.length)
      return year.every(tickStep(start / durationYear, stop / durationYear, count));
    if (i2 === 0)
      return millisecond.every(Math.max(tickStep(start, stop, count), 1));
    const [t2, step] = tickIntervals[target / tickIntervals[i2 - 1][2] < tickIntervals[i2][2] / target ? i2 - 1 : i2];
    return t2.every(step);
  }
  return [ticks, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/quickselect/index.js
function quickselect(arr, k3, left, right, compare) {
  quickselectStep(arr, k3, left || 0, right || arr.length - 1, compare || defaultCompare);
}
function quickselectStep(arr, k3, left, right, compare) {
  while (right > left) {
    if (right - left > 600) {
      var n2 = right - left + 1;
      var m2 = k3 - left + 1;
      var z2 = Math.log(n2);
      var s3 = 0.5 * Math.exp(2 * z2 / 3);
      var sd = 0.5 * Math.sqrt(z2 * s3 * (n2 - s3) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k3 - m2 * s3 / n2 + sd));
      var newRight = Math.min(right, Math.floor(k3 + (n2 - m2) * s3 / n2 + sd));
      quickselectStep(arr, k3, newLeft, newRight, compare);
    }
    var t2 = arr[k3];
    var i2 = left;
    var j2 = right;
    swap(arr, left, k3);
    if (compare(arr[right], t2) > 0)
      swap(arr, left, right);
    while (i2 < j2) {
      swap(arr, i2, j2);
      i2++;
      j2--;
      while (compare(arr[i2], t2) < 0)
        i2++;
      while (compare(arr[j2], t2) > 0)
        j2--;
    }
    if (compare(arr[left], t2) === 0)
      swap(arr, left, j2);
    else {
      j2++;
      swap(arr, j2, right);
    }
    if (j2 <= k3)
      left = j2 + 1;
    if (k3 <= j2)
      right = j2 - 1;
  }
}
function swap(arr, i2, j2) {
  var tmp = arr[i2];
  arr[i2] = arr[j2];
  arr[j2] = tmp;
}
function defaultCompare(a3, b2) {
  return a3 < b2 ? -1 : a3 > b2 ? 1 : 0;
}

// node_modules/rbush/index.js
var RBush = class {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects(bbox, node))
      return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf)
            result.push(child);
          else if (contains(bbox, childBBox))
            this._all(child, result);
          else
            nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects(bbox, node))
      return false;
    const nodesToSearch = [];
    while (node) {
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox))
            return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length))
      return this;
    if (data.length < this._minEntries) {
      for (let i2 = 0; i2 < data.length; i2++) {
        this.insert(data[i2]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item)
      this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item)
      return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path3 = [];
    const indexes = [];
    let i2, parent, goingUp;
    while (node || path3.length) {
      if (!node) {
        node = path3.pop();
        parent = path3[path3.length - 1];
        i2 = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path3.push(node);
          this._condense(path3);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path3.push(node);
        indexes.push(i2);
        i2 = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i2++;
        node = parent.children[i2];
        goingUp = false;
      } else
        node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a3, b2) {
    return a3.minX - b2.minX;
  }
  compareMinY(a3, b2) {
    return a3.minY - b2.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf)
        result.push(...node.children);
      else
        nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N2 = right - left + 1;
    let M2 = this._maxEntries;
    let node;
    if (N2 <= M2) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N2) / Math.log(M2));
      M2 = Math.ceil(N2 / Math.pow(M2, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N22 = Math.ceil(N2 / M2);
    const N1 = N22 * Math.ceil(Math.sqrt(M2));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i2 = left; i2 <= right; i2 += N1) {
      const right2 = Math.min(i2 + N1 - 1, right);
      multiSelect(items, i2, right2, N22, this.compareMinY);
      for (let j2 = i2; j2 <= right2; j2 += N22) {
        const right3 = Math.min(j2 + N22 - 1, right2);
        node.children.push(this._build(items, j2, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level, path3) {
    while (true) {
      path3.push(node);
      if (node.leaf || path3.length - 1 === level)
        break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i2 = 0; i2 < node.children.length; i2++) {
        const child = node.children[i2];
        const area = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode) {
    const bbox = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level, insertPath);
    node.children.push(item);
    extend(node, bbox);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else
        break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level);
  }
  // split overflowed node into two
  _split(insertPath, level) {
    const node = insertPath[level];
    const M2 = node.children.length;
    const m2 = this._minEntries;
    this._chooseSplitAxis(node, m2, M2);
    const splitIndex = this._chooseSplitIndex(node, m2, M2);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level)
      insertPath[level - 1].children.push(newNode);
    else
      this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m2, M2) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i2 = m2; i2 <= M2 - m2; i2++) {
      const bbox1 = distBBox(node, 0, i2, this.toBBox);
      const bbox2 = distBBox(node, i2, M2, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i2;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        if (area < minArea) {
          minArea = area;
          index = i2;
        }
      }
    }
    return index || M2 - m2;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m2, M2) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m2, M2, compareMinX);
    const yMargin = this._allDistMargin(node, m2, M2, compareMinY);
    if (xMargin < yMargin)
      node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m2, M2, compare) {
    node.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m2, toBBox);
    const rightBBox = distBBox(node, M2 - m2, M2, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i2 = m2; i2 < M2 - m2; i2++) {
      const child = node.children[i2];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i2 = M2 - m2 - 1; i2 >= m2; i2--) {
      const child = node.children[i2];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path3, level) {
    for (let i2 = level; i2 >= 0; i2--) {
      extend(path3[i2], bbox);
    }
  }
  _condense(path3) {
    for (let i2 = path3.length - 1, siblings; i2 >= 0; i2--) {
      if (path3[i2].children.length === 0) {
        if (i2 > 0) {
          siblings = path3[i2 - 1].children;
          siblings.splice(siblings.indexOf(path3[i2]), 1);
        } else
          this.clear();
      } else
        calcBBox(path3[i2], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i2 = 0; i2 < items.length; i2++) {
    if (equalsFn(item, items[i2]))
      return i2;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k3, p2, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i2 = k3; i2 < p2; i2++) {
    const child = node.children[i2];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend(a3, b2) {
  a3.minX = Math.min(a3.minX, b2.minX);
  a3.minY = Math.min(a3.minY, b2.minY);
  a3.maxX = Math.max(a3.maxX, b2.maxX);
  a3.maxY = Math.max(a3.maxY, b2.maxY);
  return a3;
}
function compareNodeMinX(a3, b2) {
  return a3.minX - b2.minX;
}
function compareNodeMinY(a3, b2) {
  return a3.minY - b2.minY;
}
function bboxArea(a3) {
  return (a3.maxX - a3.minX) * (a3.maxY - a3.minY);
}
function bboxMargin(a3) {
  return a3.maxX - a3.minX + (a3.maxY - a3.minY);
}
function enlargedArea(a3, b2) {
  return (Math.max(b2.maxX, a3.maxX) - Math.min(b2.minX, a3.minX)) * (Math.max(b2.maxY, a3.maxY) - Math.min(b2.minY, a3.minY));
}
function intersectionArea(a3, b2) {
  const minX = Math.max(a3.minX, b2.minX);
  const minY = Math.max(a3.minY, b2.minY);
  const maxX = Math.min(a3.maxX, b2.maxX);
  const maxY = Math.min(a3.maxY, b2.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a3, b2) {
  return a3.minX <= b2.minX && a3.minY <= b2.minY && b2.maxX <= a3.maxX && b2.maxY <= a3.maxY;
}
function intersects(a3, b2) {
  return b2.minX <= a3.maxX && b2.minY <= a3.maxY && b2.maxX >= a3.minX && b2.maxY >= a3.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n2, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n2)
      continue;
    const mid = left + Math.ceil((right - left) / n2 / 2) * n2;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}

// node_modules/d3-shape/src/math.js
var cos = Math.cos;
var sin = Math.sin;
var sqrt2 = Math.sqrt;
var epsilon2 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var tau2 = 2 * pi2;

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x3, y3);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a3, r2) {
    this._curve.point(r2 * Math.sin(a3), r2 * -Math.cos(a3));
  }
};
function curveRadial(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}

// node_modules/d3-shape/src/symbol/asterisk.js
var sqrt3 = sqrt2(3);

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt2(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = sin(pi2 / 10) / sin(7 * pi2 / 10);
var kx = sin(tau2 / 10) * kr;
var ky = -cos(tau2 / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt32 = sqrt2(3);

// node_modules/d3-shape/src/symbol/triangle2.js
var sqrt33 = sqrt2(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = sqrt2(3) / 2;
var k = 1 / sqrt2(12);
var a = (k / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point2(that, x3, y3) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x3) / 6,
    (that._y0 + 4 * that._y1 + y3) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x3, this._y2 = y3;
        break;
      case 1:
        this._point = 2;
        this._x3 = x3, this._y3 = y3;
        break;
      case 2:
        this._point = 3;
        this._x4 = x3, this._y4 = y3;
        this._context.moveTo((this._x0 + 4 * this._x1 + x3) / 6, (this._y0 + 4 * this._y1 + y3) / 6);
        break;
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x3) / 6, y0 = (this._y0 + 4 * this._y1 + y3) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
  }
};

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x3 = this._x, y3 = this._y, j2 = x3.length - 1;
    if (j2 > 0) {
      var x0 = x3[0], y0 = y3[0], dx = x3[j2] - x0, dy = y3[j2] - y0, i2 = -1, t2;
      while (++i2 <= j2) {
        t2 = i2 / j2;
        this._basis.point(
          this._beta * x3[i2] + (1 - this._beta) * (x0 + t2 * dx),
          this._beta * y3[i2] + (1 - this._beta) * (y0 + t2 * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x3, y3) {
    this._x.push(+x3);
    this._y.push(+y3);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point3(that, x3, y3) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x3),
    that._y2 + that._k * (that._y1 - y3),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        this._x1 = x3, this._y1 = y3;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y3;
        break;
      default:
        point3(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x3, y3);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point4(that, x3, y3) {
  var x1 = that._x1, y1 = that._y1, x23 = that._x2, y23 = that._y2;
  if (that._l01_a > epsilon2) {
    var a3 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a3 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2;
    y1 = (y1 * a3 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
  }
  if (that._l23_a > epsilon2) {
    var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x23 = (x23 * b2 + that._x1 * that._l23_2a - x3 * that._l12_2a) / m2;
    y23 = (y23 * b2 + that._y1 * that._l23_2a - y3 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x1, y1, x23, y23, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point4(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x3, this._y3 = y3;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x3, this._y4 = y3);
        break;
      case 2:
        this._point = 3;
        this._x5 = x3, this._y5 = y3;
        break;
      default:
        point4(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point) {
      var x23 = this._x2 - x3, y23 = this._y2 - y3;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point4(this, x3, y3);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    if (this._point)
      this._context.lineTo(x3, y3);
    else
      this._point = 1, this._context.moveTo(x3, y3);
  }
};

// node_modules/d3-shape/src/curve/monotone.js
function sign(x3) {
  return x3 < 0 ? -1 : 1;
}
function slope3(that, x23, y23) {
  var h0 = that._x1 - that._x0, h1 = x23 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y23 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t2) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t2) / 2 : t2;
}
function point5(that, t02, t12) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point5(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    var t12 = NaN;
    x3 = +x3, y3 = +y3;
    if (x3 === this._x1 && y3 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point5(this, slope2(this, t12 = slope3(this, x3, y3)), t12);
        break;
      default:
        point5(this, this._t0, t12 = slope3(this, x3, y3));
        break;
    }
    this._x0 = this._x1, this._x1 = x3;
    this._y0 = this._y1, this._y1 = y3;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x3, y3) {
  MonotoneX.prototype.point.call(this, y3, x3);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x3, y3) {
    this._context.moveTo(y3, x3);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x3, y3) {
    this._context.lineTo(y3, x3);
  },
  bezierCurveTo: function(x1, y1, x23, y23, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y23, x23, y3, x3);
  }
};

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x3 = this._x, y3 = this._y, n2 = x3.length;
    if (n2) {
      this._line ? this._context.lineTo(x3[0], y3[0]) : this._context.moveTo(x3[0], y3[0]);
      if (n2 === 2) {
        this._context.lineTo(x3[1], y3[1]);
      } else {
        var px = controlPoints(x3), py = controlPoints(y3);
        for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x3[i1], y3[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n2 === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x3, y3) {
    this._x.push(+x3);
    this._y.push(+y3);
  }
};
function controlPoints(x3) {
  var i2, n2 = x3.length - 1, m2, a3 = new Array(n2), b2 = new Array(n2), r2 = new Array(n2);
  a3[0] = 0, b2[0] = 2, r2[0] = x3[0] + 2 * x3[1];
  for (i2 = 1; i2 < n2 - 1; ++i2)
    a3[i2] = 1, b2[i2] = 4, r2[i2] = 4 * x3[i2] + 2 * x3[i2 + 1];
  a3[n2 - 1] = 2, b2[n2 - 1] = 7, r2[n2 - 1] = 8 * x3[n2 - 1] + x3[n2];
  for (i2 = 1; i2 < n2; ++i2)
    m2 = a3[i2] / b2[i2 - 1], b2[i2] -= m2, r2[i2] -= m2 * r2[i2 - 1];
  a3[n2 - 1] = r2[n2 - 1] / b2[n2 - 1];
  for (i2 = n2 - 2; i2 >= 0; --i2)
    a3[i2] = (r2[i2] - a3[i2 + 1]) / b2[i2];
  b2[n2 - 1] = (x3[n2] + a3[n2 - 1]) / 2;
  for (i2 = 0; i2 < n2 - 1; ++i2)
    b2[i2] = 2 * x3[i2 + 1] - a3[i2 + 1];
  return [a3, b2];
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t2) {
  this._context = context;
  this._t = t2;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x3, y3) {
    x3 = +x3, y3 = +y3;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y3);
          this._context.lineTo(x3, y3);
        } else {
          var x1 = this._x * (1 - this._t) + x3 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y3);
        }
        break;
      }
    }
    this._x = x3, this._y = y3;
  }
};

// node_modules/colortranslator/esm/index.js
var t = function() {
  return t = Object.assign || function(t2) {
    for (var e2, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
      for (var a3 in e2 = arguments[r2])
        Object.prototype.hasOwnProperty.call(e2, a3) && (t2[a3] = e2[a3]);
    return t2;
  }, t.apply(this, arguments);
};
function e(t2, e2, r2) {
  if (r2 || 2 === arguments.length)
    for (var n2, a3 = 0, o2 = e2.length; a3 < o2; a3++)
      !n2 && a3 in e2 || (n2 || (n2 = Array.prototype.slice.call(e2, 0, a3)), n2[a3] = e2[a3]);
  return t2.concat(n2 || Array.prototype.slice.call(e2));
}
var r;
var n;
var a2;
var o;
!function(t2) {
  t2.HEX = "HEX", t2.RGB = "RGB", t2.HSL = "HSL", t2.CMYK = "CMYK";
}(r || (r = {})), function(t2) {
  t2.ANALOGOUS = "ANALOGOUS", t2.COMPLEMENTARY = "COMPLEMENTARY", t2.SPLIT_COMPLEMENTARY = "SPLIT_COMPLEMENTARY", t2.TRIADIC = "TRIADIC", t2.TETRADIC = "TETRADIC", t2.SQUARE = "SQUARE";
}(n || (n = {})), function(t2) {
  t2.ADDITIVE = "ADDITIVE", t2.SUBTRACTIVE = "SUBTRACTIVE";
}(a2 || (a2 = {})), function(t2) {
  t2.black = "#000000", t2.silver = "#C0C0C0", t2.gray = "#808080", t2.white = "#FFFFFF", t2.maroon = "#800000", t2.red = "#FF0000", t2.purple = "#800080", t2.fuchsia = "#FF00FF", t2.green = "#008000", t2.lime = "#00FF00", t2.olive = "#808000", t2.yellow = "#FFFF00", t2.navy = "#000080", t2.blue = "#0000FF", t2.teal = "#008080", t2.aqua = "#00FFFF", t2.orange = "#FFA500", t2.aliceblue = "#F0F8FF", t2.antiquewhite = "#FAEBD7", t2.aquamarine = "#7FFFD4", t2.azure = "#F0FFFF", t2.beige = "#F5F5DC", t2.bisque = "#FFE4C4", t2.blanchedalmond = "#FFEBCD", t2.blueviolet = "#8A2BE2", t2.brown = "#A52A2A", t2.burlywood = "#DEB887", t2.cadetblue = "#5F9EA0", t2.chartreuse = "#7FFF00", t2.chocolate = "#D2691E", t2.coral = "#FF7F50", t2.cornflowerblue = "#6495ED", t2.cornsilk = "#FFF8DC", t2.crimson = "#DC143C", t2.cyan = "#00FFFF", t2.darkblue = "#00008B", t2.darkcyan = "#008B8B", t2.darkgoldenrod = "#B8860B", t2.darkgray = "#A9A9A9", t2.darkgreen = "#006400", t2.darkgrey = "#A9A9A9", t2.darkkhaki = "#BDB76B", t2.darkmagenta = "#8B008B", t2.darkolivegreen = "#556B2F", t2.darkorange = "#FF8C00", t2.darkorchid = "#9932CC", t2.darkred = "#8B0000", t2.darksalmon = "#E9967A", t2.darkseagreen = "#8FBC8F", t2.darkslateblue = "#483D8B", t2.darkslategray = "#2F4F4F", t2.darkslategrey = "#2F4F4F", t2.darkturquoise = "#00CED1", t2.darkviolet = "#9400D3", t2.deeppink = "#FF1493", t2.deepskyblue = "#00BFFF", t2.dimgray = "#696969", t2.dimgrey = "#696969", t2.dodgerblue = "#1E90FF", t2.firebrick = "#B22222", t2.floralwhite = "#FFFAF0", t2.forestgreen = "#228B22", t2.gainsboro = "#DCDCDC", t2.ghostwhite = "#F8F8FF", t2.gold = "#FFD700", t2.goldenrod = "#DAA520", t2.greenyellow = "#ADFF2F", t2.grey = "#808080", t2.honeydew = "#F0FFF0", t2.hotpink = "#FF69B4", t2.indianred = "#CD5C5C", t2.indigo = "#4B0082", t2.ivory = "#FFFFF0", t2.khaki = "#F0E68C", t2.lavender = "#E6E6FA", t2.lavenderblush = "#FFF0F5", t2.lawngreen = "#7CFC00", t2.lemonchiffon = "#FFFACD", t2.lightblue = "#ADD8E6", t2.lightcoral = "#F08080", t2.lightcyan = "#E0FFFF", t2.lightgoldenrodyellow = "#FAFAD2", t2.lightgray = "#D3D3D3", t2.lightgreen = "#90EE90", t2.lightgrey = "#D3D3D3", t2.lightpink = "#FFB6C1", t2.lightsalmon = "#FFA07A", t2.lightseagreen = "#20B2AA", t2.lightskyblue = "#87CEFA", t2.lightslategray = "#778899", t2.lightslategrey = "#778899", t2.lightsteelblue = "#B0C4DE", t2.lightyellow = "#FFFFE0", t2.limegreen = "#32CD32", t2.linen = "#FAF0E6", t2.magenta = "#FF00FF", t2.mediumaquamarine = "#66CDAA", t2.mediumblue = "#0000CD", t2.mediumorchid = "#BA55D3", t2.mediumpurple = "#9370DB", t2.mediumseagreen = "#3CB371", t2.mediumslateblue = "#7B68EE", t2.mediumspringgreen = "#00FA9A", t2.mediumturquoise = "#48D1CC", t2.mediumvioletred = "#C71585", t2.midnightblue = "#191970", t2.mintcream = "#F5FFFA", t2.mistyrose = "#FFE4E1", t2.moccasin = "#FFE4B5", t2.navajowhite = "#FFDEAD", t2.oldlace = "#FDF5E6", t2.olivedrab = "#6B8E23", t2.orangered = "#FF4500", t2.orchid = "#DA70D6", t2.palegoldenrod = "#EEE8AA", t2.palegreen = "#98FB98", t2.paleturquoise = "#AFEEEE", t2.palevioletred = "#DB7093", t2.papayawhip = "#FFEFD5", t2.peachpuff = "#FFDAB9", t2.peru = "#CD853F", t2.pink = "#FFC0CB", t2.plum = "#DDA0DD", t2.powderblue = "#B0E0E6", t2.rosybrown = "#BC8F8F", t2.royalblue = "#4169E1", t2.saddlebrown = "#8B4513", t2.salmon = "#FA8072", t2.sandybrown = "#F4A460", t2.seagreen = "#2E8B57", t2.seashell = "#FFF5EE", t2.sienna = "#A0522D", t2.skyblue = "#87CEEB", t2.slateblue = "#6A5ACD", t2.slategray = "#708090", t2.slategrey = "#708090", t2.snow = "#FFFAFA", t2.springgreen = "#00FF7F", t2.steelblue = "#4682B4", t2.tan = "#D2B48C", t2.thistle = "#D8BFD8", t2.tomato = "#FF6347", t2.turquoise = "#40E0D0", t2.violet = "#EE82EE", t2.wheat = "#F5DEB3", t2.whitesmoke = "#F5F5F5", t2.yellowgreen = "#9ACD32", t2.rebeccapurple = "#663399";
}(o || (o = {}));
var i;
var u;
var c;
var s2;
var d;
var h;
var l;
var f = Object.keys(o);
var g = ((i = {})[r.HEX] = /^#(?:([a-f\d])([a-f\d])([a-f\d])([a-f\d])?|([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?)$/i, i[r.RGB] = /^rgba?\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, i[r.HSL] = /^hsla?\s*\(\s*(?:(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*,\s*((?:\d*\.)?\d+)%\s*,\s*((?:\d*\.)?\d+)%(?:\s*,\s*((?:\d*\.)?\d+))?|(-?(?:\d*\.)?\d+(?:deg|grad|rad|turn)?)\s*((?:\d*\.)?\d+)%\s*((?:\d*\.)?\d+)%(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, i[r.CMYK] = /^(?:device-cmyk|cmyk)\s*\(\s*(?:((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)\s*,\s*((?:\d*\.)?\d+%?)(?:\s*,\s*((?:\d*\.)?\d+))?|((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)\s*((?:\d*\.)?\d+%?)(?:\s*\/\s*((?:\d*\.)?\d+%?))?)\s*\)$/, i);
var p = /^(-?(?:\d*\.)?\d+)((?:deg|grad|rad|turn)?)$/;
var b = /^(\d+(?:\.\d+)?|\.\d+)%$/;
var F = /^0x([a-f\d]{1,2})$/i;
var y2 = "The provided string color doesn't have a correct format";
var m = "The provided color object doesn't have the proper keys or format";
var A = function(t2, e2, r2) {
  return r2 < 0 && (r2 += 6), r2 >= 6 && (r2 -= 6), r2 < 1 ? Math.round(255 * ((e2 - t2) * r2 + t2)) : r2 < 3 ? Math.round(255 * e2) : r2 < 4 ? Math.round(255 * ((e2 - t2) * (4 - r2) + t2)) : Math.round(255 * t2);
};
var E = function(t2, e2, r2) {
  e2 /= 100;
  var n2 = (r2 /= 100) <= 0.5 ? r2 * (e2 + 1) : r2 + e2 - r2 * e2, a3 = 2 * r2 - n2;
  return { r: A(a3, n2, (t2 /= 60) + 2), g: A(a3, n2, t2), b: A(a3, n2, t2 - 2) };
};
var H = function(t2, e2, r2, n2) {
  return n2 = 1 - n2, { r: Math.round(255 * (1 - t2) * n2), g: Math.round(255 * (1 - e2) * n2), b: Math.round(255 * (1 - r2) * n2) };
};
var v = function(t2, e2, r2) {
  t2 /= 255, e2 /= 255, r2 /= 255;
  var n2 = 1 - Math.max(t2, e2, r2), a3 = 1 - n2, o2 = (a3 - t2) / a3, i2 = (a3 - e2) / a3, u2 = (a3 - r2) / a3;
  return { c: Math.round(100 * o2), m: Math.round(100 * i2), y: Math.round(100 * u2), k: Math.round(100 * n2) };
};
var B = function(t2, e2, r2, n2) {
  void 0 === n2 && (n2 = 1), t2 /= 255, e2 /= 255, r2 /= 255, n2 = Math.min(n2, 1);
  var a3 = Math.max(t2, e2, r2), o2 = Math.min(t2, e2, r2), i2 = a3 - o2, u2 = 0, c2 = 0, s3 = (a3 + o2) / 2;
  if (0 === i2)
    u2 = 0, c2 = 0;
  else {
    switch (a3) {
      case t2:
        u2 = (e2 - r2) / i2 % 6;
        break;
      case e2:
        u2 = (r2 - t2) / i2 + 2;
        break;
      case r2:
        u2 = (t2 - e2) / i2 + 4;
    }
    (u2 = Math.round(60 * u2)) < 0 && (u2 += 360), c2 = i2 / (1 - Math.abs(2 * s3 - 1));
  }
  return { h: u2, s: Math.round(100 * c2), l: Math.round(100 * s3), a: n2 };
};
var M = function(t2, e2) {
  if (t2 < 0 && (t2 += 360), t2 > 360 && (t2 -= 360), 360 === t2 || 0 === t2)
    return t2;
  var r2 = [[0, 120], [120, 180], [180, 240], [240, 360]], n2 = [[0, 60], [60, 120], [120, 240], [240, 360]], a3 = e2 ? n2 : r2, o2 = 0, i2 = 0, u2 = 0, c2 = 0;
  return (e2 ? r2 : n2).find(function(e3, r3) {
    return t2 >= e3[0] && t2 < e3[1] && (o2 = e3[0], i2 = e3[1], u2 = a3[r3][0], c2 = a3[r3][1], true);
  }), u2 + (c2 - u2) / (i2 - o2) * (t2 - o2);
};
var C = function(t2, e2) {
  return Object.prototype.hasOwnProperty.call(t2, e2);
};
var D = function(t2) {
  return b.test("".concat(t2)) ? +"".concat(t2).replace(b, "$1") : Math.min(+t2, 100);
};
var R = function(t2) {
  return 1 === t2.length && (t2 += t2), parseInt(t2, 16);
};
var S = function(t2) {
  var e2 = X(t2).toString(16).toUpperCase();
  return 1 === e2.length ? "0x0".concat(e2) : "0x".concat(e2);
};
var L = function(t2) {
  var e2 = X(t2).toString(16).toUpperCase();
  return 1 === e2.length && (e2 = "0".concat(e2)), e2;
};
var G = function(t2, e2) {
  return void 0 === e2 && (e2 = false), !e2 && b.test(t2) ? Math.min(255 * +t2.replace(b, "$1") / 100, 255) : F.test(t2) ? 3 === t2.length ? e2 ? parseInt(t2 + t2.slice(-1)) / 255 : parseInt(t2 + t2.slice(-1)) : e2 ? X(t2, 6) / 255 : X(t2, 6) : Math.min(+t2, e2 ? 1 : 255);
};
var k2 = function(t2) {
  return Math.min(b.test(t2) ? +t2.replace(b, "$1") / 100 : +t2, 1);
};
var O = function(t2) {
  return t2.sort().join("").toUpperCase();
};
var X = function(t2, e2) {
  void 0 === e2 && (e2 = 0);
  var r2 = Math.pow(10, e2);
  return Math.round(+t2 * r2) / r2;
};
var j = function(t2, e2, r2) {
  return Math.max(e2, Math.min(t2, r2));
};
var I = ((u = {})[r.HEX] = function(t2) {
  return "#".concat(L(t2.r)).concat(L(t2.g)).concat(L(t2.b)).concat(C(t2, "a") && L(t2.a) || "");
}, u[r.RGB] = function(t2) {
  return "rgb".concat(C(t2, "a") ? "a" : "", "(").concat(X(t2.r), ",").concat(X(t2.g), ",").concat(X(t2.b)).concat(C(t2, "a") && ",".concat(X(t2.a, 2)) || "", ")");
}, u[r.HSL] = function(t2) {
  return "hsl".concat(C(t2, "a") ? "a" : "", "(").concat(X(t2.h), ",").concat(X(t2.s), "%,").concat(X(t2.l), "%").concat(C(t2, "a") && ",".concat(X(t2.a, 2)) || "", ")");
}, u[r.CMYK] = function(t2) {
  return "cmyk(".concat(X(t2.c), "%,").concat(X(t2.m), "%,").concat(X(t2.y), "%,").concat(X(t2.k), "%").concat(C(t2, "a") && ",".concat(X(t2.a, 2)) || "", ")");
}, u);
var Y = function(t2) {
  if ("string" == typeof t2) {
    var e2 = t2.match(p), r2 = +e2[1];
    switch (e2[2]) {
      case "rad":
        t2 = Math.round(180 * r2 / Math.PI);
        break;
      case "turn":
        t2 = Math.round(360 * r2);
        break;
      default:
        t2 = r2;
    }
  }
  return (t2 > 360 || t2 < 0) && (t2 -= 360 * Math.floor(t2 / 360)), t2;
};
var T = function(t2) {
  return "string" == typeof t2 && (t2 = b.test(t2) ? +t2.replace(b, "$1") / 100 : +t2), isNaN(+t2) || t2 > 1 ? 1 : X(t2, 6);
};
var K = function(r2, n2, o2) {
  return n2.reduce(function(n3, i2) {
    return e(e([], n3, true), [t(t({}, r2), { h: o2 === a2.ADDITIVE ? Y(r2.h + i2) : Y(M(M(r2.h, false) + i2, true)) })], false);
  }, [t({}, r2)]);
};
var P = function(t2, e2) {
  return K(t2, [30, -30], e2);
};
var w = function(t2, e2) {
  return K(t2, [180], e2);
};
var x2 = function(t2, e2) {
  return K(t2, [150, -150], e2);
};
var N = function(t2, e2) {
  return K(t2, [120, -120], e2);
};
var V = function(t2, e2) {
  return K(t2, [60, -120, 180], e2);
};
var U = function(t2, e2) {
  return K(t2, [90, -90, 180], e2);
};
var $ = Object.entries(r).reduce(function(t2, e2) {
  var n2 = e2[0], a3 = e2[1];
  if (n2 !== r.HEX) {
    var o2 = O(n2.split(""));
    t2[o2] = a3, t2["A" + o2] = a3;
  }
  return t2;
}, {});
var q = function(t2) {
  return "string" == typeof t2 ? function(t3) {
    var e2;
    if (Object.keys(r).some(function(r2) {
      if (g[r2].test(t3))
        return e2 = r2, true;
    }), !e2 && ~f.indexOf(t3) && (e2 = r.HEX), !e2)
      throw new Error(y2);
    return e2;
  }(t2) : function(t3) {
    var e2, n2 = false, a3 = O(Object.keys(t3));
    if ($[a3] && (e2 = $[a3]), e2 && e2 === r.RGB) {
      var o2 = Object.entries(t3).some(function(t4) {
        return !F.test("".concat(t4[1]));
      }), i2 = Object.entries(t3).some(function(t4) {
        return !(b.test("".concat(t4[1])) || !F.test("".concat(t4[1])) && !isNaN(+t4[1]) && +t4[1] <= 255);
      });
      o2 && i2 && (n2 = true), o2 || (e2 = r.HEX);
    }
    if (!e2 || n2)
      throw new Error(m);
    return e2;
  }(t2);
};
var Q = ((c = {})[r.HEX] = function(t2) {
  var e2 = (~f.indexOf(t2) ? o[t2] : t2).match(g.HEX), r2 = { r: R(e2[1] || e2[5]), g: R(e2[2] || e2[6]), b: R(e2[3] || e2[7]) }, n2 = e2[4] || e2[8];
  return void 0 !== n2 && (r2.a = R(n2) / 255), r2;
}, c[r.RGB] = function(t2) {
  var e2 = t2.match(g.RGB), r2 = G(e2[1] || e2[5]), n2 = G(e2[2] || e2[6]), a3 = G(e2[3] || e2[7]), o2 = e2[4] || e2[8], i2 = { r: Math.min(r2, 255), g: Math.min(n2, 255), b: Math.min(a3, 255) };
  return void 0 !== o2 && (i2.a = T(o2)), i2;
}, c[r.HSL] = function(t2) {
  var e2 = t2.match(g.HSL), r2 = Y(e2[1] || e2[5]), n2 = D(e2[2] || e2[6]), a3 = D(e2[3] || e2[7]), o2 = e2[4] || e2[8], i2 = E(r2, n2, a3);
  return void 0 !== o2 && (i2.a = T(o2)), i2;
}, c[r.CMYK] = function(t2) {
  var e2 = t2.match(g.CMYK), r2 = k2(e2[1] || e2[6]), n2 = k2(e2[2] || e2[7]), a3 = k2(e2[3] || e2[8]), o2 = k2(e2[4] || e2[9]), i2 = e2[5] || e2[10], u2 = H(r2, n2, a3, o2);
  return void 0 !== i2 && (u2.a = T(i2)), u2;
}, c);
var _ = ((s2 = {})[r.HEX] = function(t2) {
  var e2 = { r: G("".concat(t2.r)), g: G("".concat(t2.g)), b: G("".concat(t2.b)) };
  return C(t2, "a") && (e2.a = Math.min(G("".concat(t2.a), true), 1)), e2;
}, s2[r.RGB] = function(t2) {
  return this.HEX(t2);
}, s2[r.HSL] = function(t2) {
  var e2 = D("".concat(t2.s)), r2 = D("".concat(t2.l)), n2 = E(Y(t2.h), e2, r2);
  return C(t2, "a") && (n2.a = T(t2.a)), n2;
}, s2[r.CMYK] = function(t2) {
  var e2 = k2("".concat(t2.c)), r2 = k2("".concat(t2.m)), n2 = k2("".concat(t2.y)), a3 = k2("".concat(t2.k)), o2 = H(e2, r2, n2, a3);
  return C(t2, "a") && (o2.a = T(t2.a)), o2;
}, s2);
var z = function(t2, e2) {
  return void 0 === e2 && (e2 = q(t2)), "string" == typeof t2 ? Q[e2](t2) : _[e2](t2);
};
var J = ((d = {})[r.HEX] = function(t2) {
  return { r: S(t2.r), g: S(t2.g), b: S(t2.b) };
}, d.HEXA = function(t2) {
  var e2 = J.HEX(t2);
  return e2.a = C(t2, "a") ? S(255 * t2.a) : "0xFF", e2;
}, d[r.RGB] = function(t2) {
  return C(t2, "a") && delete t2.a, t2;
}, d.RGBA = function(t2) {
  return t2.a = C(t2, "a") ? X(t2.a, 2) : 1, t2;
}, d[r.HSL] = function(t2) {
  var e2 = B(t2.r, t2.g, t2.b);
  return delete e2.a, e2;
}, d.HSLA = function(t2) {
  var e2 = J.HSL(t2);
  return e2.a = C(t2, "a") ? X(t2.a, 2) : 1, e2;
}, d[r.CMYK] = function(t2) {
  return v(t2.r, t2.g, t2.b);
}, d.CMYKA = function(t2) {
  var e2 = v(t2.r, t2.g, t2.b);
  return e2.a = C(t2, "a") ? X(t2.a, 2) : 1, e2;
}, d);
var W = function(e2, n2, a3) {
  var o2 = q(e2), i2 = "string" == typeof e2, u2 = z(e2, o2), c2 = "string" == typeof e2 && C(u2, "a") || "string" != typeof e2 && C(e2, "a"), s3 = B(u2.r, u2.g, u2.b, u2.a);
  c2 || delete s3.a;
  var d2 = a3 ? s3.l / (n2 + 1) : (100 - s3.l) / (n2 + 1), h2 = Array(n2).fill(null).map(function(e3, r2) {
    return t(t({}, s3), { l: s3.l + d2 * (r2 + 1) * (1 - 2 * +a3) });
  });
  switch (o2) {
    case r.HEX:
    default:
      return h2.map(function(e3) {
        var r2 = E(e3.h, e3.s, e3.l);
        return c2 && (r2.a = e3.a), i2 ? c2 ? I.HEX(t(t({}, r2), { a: X(255 * r2.a, 6) })) : I.HEX(r2) : c2 ? J.HEXA(r2) : J.HEX(r2);
      });
    case r.RGB:
      return h2.map(function(t2) {
        var e3 = E(t2.h, t2.s, t2.l);
        return c2 && (e3.a = t2.a), i2 ? I.RGB(e3) : c2 ? J.RGBA(e3) : J.RGB(e3);
      });
    case r.HSL:
      return h2.map(function(e3) {
        return i2 ? I.HSL(e3) : c2 ? J.HSLA(t(t({}, E(e3.h, e3.s, e3.l)), { a: e3.a })) : J.HSL(E(e3.h, e3.s, e3.l));
      });
  }
};
var Z = ((h = { buildHarmony: function(t2, e2, n2) {
  var a3 = q(t2), o2 = z(t2, a3), i2 = B(o2.r, o2.g, o2.b, o2.a), u2 = "string" == typeof t2 && C(o2, "a") || "string" != typeof t2 && C(t2, "a"), c2 = "string" == typeof t2;
  switch (a3) {
    case r.HEX:
    default:
      return u2 ? this.HEXA(i2, e2, n2, c2) : this.HEX(i2, e2, n2, c2);
    case r.HSL:
      return u2 ? this.HSLA(i2, e2, n2, c2) : this.HSL(i2, e2, n2, c2);
    case r.RGB:
      return u2 ? this.RGBA(i2, e2, n2, c2) : this.RGB(i2, e2, n2, c2);
  }
} })[r.HEX] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HEX(E(t3.h, t3.s, t3.l)) : J.HEX(E(t3.h, t3.s, t3.l));
  });
}, h.HEXA = function(e2, r2, n2, a3) {
  return r2(e2, n2).map(function(e3) {
    return a3 ? I.HEX(t(t({}, E(e3.h, e3.s, e3.l)), { a: 255 * T(e3.a) })) : J.HEXA(t(t({}, E(e3.h, e3.s, e3.l)), { a: T(e3.a) }));
  });
}, h[r.RGB] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.RGB(E(t3.h, t3.s, t3.l)) : J.RGB(E(t3.h, t3.s, t3.l));
  });
}, h.RGBA = function(e2, r2, n2, a3) {
  return r2(e2, n2).map(function(e3) {
    return a3 ? I.RGB(t(t({}, E(e3.h, e3.s, e3.l)), { a: T(e3.a) })) : J.RGBA(t(t({}, E(e3.h, e3.s, e3.l)), { a: T(e3.a) }));
  });
}, h[r.HSL] = function(t2, e2, r2, n2) {
  return e2(t2, r2).map(function(t3) {
    return n2 ? I.HSL({ h: t3.h, s: t3.s, l: t3.l }) : J.HSL(E(t3.h, t3.s, t3.l));
  });
}, h.HSLA = function(e2, r2, n2, a3) {
  return r2(e2, n2).map(function(e3) {
    return a3 ? I.HSL(t(t({}, e3), { a: T(e3.a) })) : J.HSLA(t(t({}, E(e3.h, e3.s, e3.l)), { a: T(e3.a) }));
  });
}, h);
var tt = ((l = { mix: function(e2, r2) {
  var n2, o2, i2, u2, c2, s3, d2, h2, l2, f2, g2, p2, b2, F2, y3, m2 = e2.map(function(t2) {
    var e3 = q(t2);
    return z(t2, e3);
  }), A2 = r2 === a2.SUBTRACTIVE ? m2.map(function(t2) {
    var e3, r3, n3, a3, o3, i3, u3, c3, s4, d3, h3, l3, f3, g3, p3 = (e3 = t2.r, r3 = t2.g, n3 = t2.b, a3 = Math.min(e3, r3, n3), o3 = Math.min(255 - e3, 255 - r3, 255 - n3), i3 = e3 - a3, u3 = r3 - a3, c3 = n3 - a3, s4 = Math.min(i3, u3), d3 = i3 - s4, h3 = (u3 + s4) / 2, l3 = (c3 + u3 - s4) / 2, f3 = Math.max(d3, h3, l3) / Math.max(i3, u3, c3), g3 = isNaN(f3) || f3 === 1 / 0 || f3 <= 0 ? 1 : f3, { r: d3 / g3 + o3, y: h3 / g3 + o3, b: l3 / g3 + o3 });
    return C(t2, "a") && (p3.a = t2.a), p3;
  }) : null;
  function E2(e3) {
    var n3 = r2 === a2.ADDITIVE ? { r: 0, g: 0, b: 0, a: 0 } : { r: 0, y: 0, b: 0, a: 0 };
    return e3.reduce(function(e4, n4) {
      var o3 = C(n4, "a") ? n4.a : 1, i3 = { r: Math.min(e4.r + n4.r * o3, 255), b: Math.min(e4.b + n4.b * o3, 255), a: 1 - (1 - o3) * (1 - e4.a) }, u3 = "g" in e4 ? e4.g : e4.y, c3 = "g" in n4 ? n4.g : n4.y;
      return t(t({}, i3), r2 === a2.ADDITIVE ? { g: Math.min(u3 + c3 * o3, 255) } : { y: Math.min(u3 + c3 * o3, 255) });
    }, n3);
  }
  if (r2 === a2.ADDITIVE)
    n2 = E2(m2);
  else {
    var H2 = E2(A2);
    o2 = H2.r, i2 = H2.y, u2 = H2.b, c2 = Math.min(o2, i2, u2), s3 = Math.min(255 - o2, 255 - i2, 255 - u2), d2 = o2 - c2, h2 = i2 - c2, l2 = u2 - c2, f2 = Math.min(h2, l2), g2 = d2 + h2 - f2, p2 = h2 + f2, b2 = 2 * (l2 - f2), F2 = Math.max(g2, p2, b2) / Math.max(d2, h2, l2), y3 = isNaN(F2) || F2 === 1 / 0 || F2 <= 0 ? 1 : F2, (n2 = { r: g2 / y3 + s3, g: p2 / y3 + s3, b: b2 / y3 + s3 }).a = H2.a;
  }
  return { r: X(n2.r, 2), g: X(n2.g, 2), b: X(n2.b, 2), a: j(n2.a, 0, 1) };
} })[r.HEX] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.HEX(n2) : J.HEX(n2);
}, l.HEXA = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return n2.a = r2 ? 255 * T(n2.a) : T(n2.a), r2 ? I.HEX(n2) : J.HEXA(n2);
}, l[r.RGB] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return delete n2.a, r2 ? I.RGB(n2) : J.RGB(n2);
}, l.RGBA = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2);
  return r2 ? I.RGB(n2) : J.RGBA(n2);
}, l[r.HSL] = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), a3 = B(n2.r, n2.g, n2.b);
  return delete n2.a, delete a3.a, r2 ? I.HSL(a3) : J.HSL(n2);
}, l.HSLA = function(t2, e2, r2) {
  var n2 = this.mix(t2, e2), a3 = B(n2.r, n2.g, n2.b, n2.a);
  return r2 ? I.HSL(a3) : J.HSLA(n2);
}, l);
var et = function(t2, e2, r2, n2, a3) {
  var o2 = n2(z(t2, e2));
  return r2 ? a3(o2) : o2;
};
var rt = function(t2, e2, r2, n2, a3, o2) {
  r2 < 1 && (r2 = 5);
  var i2 = function(t3, e3, r3) {
    var n3 = r3 - 1, a4 = (e3.r - t3.r) / n3, o3 = (e3.g - t3.g) / n3, i3 = (e3.b - t3.b) / n3, u2 = T(t3.a), c2 = (T(e3.a) - u2) / n3;
    return Array(r3).fill(null).map(function(r4, s3) {
      return 0 === s3 ? t3 : s3 === n3 ? e3 : { r: X(t3.r + a4 * s3), g: X(t3.g + o3 * s3), b: X(t3.b + i3 * s3), a: X(u2 + c2 * s3, 2) };
    });
  }(z(t2), z(e2), r2);
  return i2.map(function(t3) {
    var e3 = a3(t3);
    return n2 ? o2(e3) : e3;
  });
};
var nt = function() {
  function e2(t2) {
    this.rgb = z(t2), this.updateHSL(), this.updateCMYK();
  }
  return e2.prototype.updateRGB = function() {
    this.rgb = t(t({}, E(this.hsl.h, this.hsl.s, this.hsl.l)), { a: this.hsl.a });
  }, e2.prototype.updateRGBFromCMYK = function() {
    this.rgb = t(t({}, H(this.cmyk.c, this.cmyk.m, this.cmyk.y, this.cmyk.k)), { a: this.rgb.a });
  }, e2.prototype.updateHSL = function() {
    this.hsl = B(this.rgb.r, this.rgb.g, this.rgb.b, this.rgb.a);
  }, e2.prototype.updateCMYK = function() {
    this.cmyk = v(this.rgb.r, this.rgb.g, this.rgb.b);
  }, e2.prototype.updateRGBAndCMYK = function() {
    return this.updateRGB(), this.updateCMYK(), this;
  }, e2.prototype.updateHSLAndCMYK = function() {
    return this.updateHSL(), this.updateCMYK(), this;
  }, e2.prototype.updateRGBAndHSL = function() {
    return this.updateRGBFromCMYK(), this.updateHSL(), this;
  }, e2.prototype.setH = function(t2) {
    return this.hsl.h = Y(t2), this.updateRGBAndCMYK();
  }, e2.prototype.setS = function(t2) {
    return this.hsl.s = j(t2, 0, 100), this.updateRGBAndCMYK();
  }, e2.prototype.setL = function(t2) {
    return this.hsl.l = j(t2, 0, 100), this.updateRGBAndCMYK();
  }, e2.prototype.setR = function(t2) {
    return this.rgb.r = j(t2, 0, 255), this.updateHSLAndCMYK();
  }, e2.prototype.setG = function(t2) {
    return this.rgb.g = j(t2, 0, 255), this.updateHSLAndCMYK();
  }, e2.prototype.setB = function(t2) {
    return this.rgb.b = j(t2, 0, 255), this.updateHSLAndCMYK();
  }, e2.prototype.setA = function(t2) {
    return this.hsl.a = this.rgb.a = j(t2, 0, 1), this;
  }, e2.prototype.setC = function(t2) {
    return this.cmyk.c = j(t2, 0, 100), this.updateRGBAndHSL();
  }, e2.prototype.setM = function(t2) {
    return this.cmyk.m = j(t2, 0, 100), this.updateRGBAndHSL();
  }, e2.prototype.setY = function(t2) {
    return this.cmyk.y = j(t2, 0, 100), this.updateRGBAndHSL();
  }, e2.prototype.setK = function(t2) {
    return this.cmyk.k = j(t2, 0, 100), this.updateRGBAndHSL();
  }, Object.defineProperty(e2.prototype, "H", { get: function() {
    return X(this.hsl.h);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "S", { get: function() {
    return X(this.hsl.s);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "L", { get: function() {
    return X(this.hsl.l);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "R", { get: function() {
    return X(this.rgb.r);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "G", { get: function() {
    return X(this.rgb.g);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "B", { get: function() {
    return X(this.rgb.b);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "A", { get: function() {
    return X(this.hsl.a, 2);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "C", { get: function() {
    return X(this.cmyk.c);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "M", { get: function() {
    return X(this.cmyk.m);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "Y", { get: function() {
    return X(this.cmyk.y);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "K", { get: function() {
    return X(this.cmyk.k);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HEXObject", { get: function() {
    return J.HEX(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HEXAObject", { get: function() {
    return J.HEXA(this.rgb);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "RGBObject", { get: function() {
    return { r: this.R, g: this.G, b: this.B };
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "RGBAObject", { get: function() {
    return t(t({}, this.RGBObject), { a: this.hsl.a });
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HSLObject", { get: function() {
    return { h: this.H, s: this.S, l: this.L };
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HSLAObject", { get: function() {
    return t(t({}, this.HSLObject), { a: this.hsl.a });
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "CMYKObject", { get: function() {
    return { c: this.C, m: this.M, y: this.Y, k: this.K };
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "CMYKAObject", { get: function() {
    return { c: this.C, m: this.M, y: this.Y, k: this.K, a: this.hsl.a };
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HEX", { get: function() {
    var t2 = this.rgb, e3 = { r: t2.r, g: t2.g, b: t2.b };
    return I.HEX(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HEXA", { get: function() {
    var t2 = this.rgb, e3 = { r: t2.r, g: t2.g, b: t2.b, a: 255 * this.hsl.a };
    return I.HEX(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "RGB", { get: function() {
    var t2 = this.rgb, e3 = { r: t2.r, g: t2.g, b: t2.b };
    return I.RGB(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "RGBA", { get: function() {
    var t2 = this.rgb, e3 = { r: t2.r, g: t2.g, b: t2.b, a: this.hsl.a };
    return I.RGB(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HSL", { get: function() {
    var t2 = this.hsl, e3 = { h: t2.h, s: t2.s, l: t2.l };
    return I.HSL(e3);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "HSLA", { get: function() {
    return I.HSL(this.hsl);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "CMYK", { get: function() {
    return I.CMYK(this.cmyk);
  }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "CMYKA", { get: function() {
    return I.CMYK(t(t({}, this.cmyk), { a: this.hsl.a }));
  }, enumerable: false, configurable: true }), e2.toHEX = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.HEX, I.HEX);
  }, e2.toHEXA = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.HEXA, I.HEX);
  }, e2.toRGB = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.RGB, I.RGB);
  }, e2.toRGBA = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.RGBA, I.RGB);
  }, e2.toHSL = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.HSL, I.HSL);
  }, e2.toHSLA = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.HSLA, I.HSL);
  }, e2.toCMYK = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.CMYK, I.CMYK);
  }, e2.toCMYKA = function(t2, e3) {
    void 0 === e3 && (e3 = true);
    var r2 = q(t2);
    return et(t2, r2, e3, J.CMYKA, I.CMYK);
  }, e2.getBlendHEX = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.HEX, I.HEX);
  }, e2.getBlendHEXA = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.HEXA, I.HEX);
  }, e2.getBlendRGB = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.RGB, I.RGB);
  }, e2.getBlendRGBA = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.RGBA, I.RGB);
  }, e2.getBlendHSL = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.HSL, I.HSL);
  }, e2.getBlendHSLA = function(t2, e3, r2, n2) {
    return void 0 === r2 && (r2 = 5), void 0 === n2 && (n2 = true), rt(t2, e3, r2, n2, J.HSLA, I.HSL);
  }, e2.getMixHEX = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a2.ADDITIVE), void 0 === r2 && (r2 = true), tt.HEX(t2, e3, r2);
  }, e2.getMixHEXA = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a2.ADDITIVE), void 0 === r2 && (r2 = true), tt.HEXA(t2, e3, r2);
  }, e2.getMixRGB = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a2.ADDITIVE), void 0 === r2 && (r2 = true), tt.RGB(t2, e3, r2);
  }, e2.getMixRGBA = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a2.ADDITIVE), void 0 === r2 && (r2 = true), tt.RGBA(t2, e3, r2);
  }, e2.getMixHSL = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a2.ADDITIVE), void 0 === r2 && (r2 = true), tt.HSL(t2, e3, r2);
  }, e2.getMixHSLA = function(t2, e3, r2) {
    return void 0 === e3 && (e3 = a2.ADDITIVE), void 0 === r2 && (r2 = true), tt.HSLA(t2, e3, r2);
  }, e2.getShades = function(t2, e3) {
    return W(t2, e3, true);
  }, e2.getTints = function(t2, e3) {
    return W(t2, e3, false);
  }, e2.getHarmony = function(t2, e3, r2) {
    switch (void 0 === e3 && (e3 = n.COMPLEMENTARY), void 0 === r2 && (r2 = a2.ADDITIVE), e3) {
      case n.ANALOGOUS:
        return Z.buildHarmony(t2, P, r2);
      case n.SPLIT_COMPLEMENTARY:
        return Z.buildHarmony(t2, x2, r2);
      case n.TRIADIC:
        return Z.buildHarmony(t2, N, r2);
      case n.TETRADIC:
        return Z.buildHarmony(t2, V, r2);
      case n.SQUARE:
        return Z.buildHarmony(t2, U, r2);
      default:
        return Z.buildHarmony(t2, w, r2);
    }
  }, e2;
}();

// node_modules/@snlab/rendervous/dist/rendervous.esm.js
function getAspectRatio(parentSection) {
  const { rangeX, rangeY } = parentSection.ranges;
  const dx = Math.abs(rangeX[0] - rangeX[1]);
  const dy = Math.abs(rangeY[0] - rangeY[1]);
  return dx / dy;
}
function getNRowsAndColumns(numberOfCells, nrows, ncolumns, aspectRatio) {
  if (!nrows && !ncolumns) {
    return getNRowsAndColumnsFromAspectRatio(numberOfCells, aspectRatio);
  }
  if (nrows && !ncolumns) {
    return {
      nrows,
      ncolumns: Math.ceil(numberOfCells / nrows)
    };
  }
  if (!nrows && ncolumns) {
    return {
      nrows: Math.ceil(numberOfCells / ncolumns),
      ncolumns
    };
  }
  return { nrows, ncolumns };
}
function getNRowsAndColumnsFromAspectRatio(numberOfCells, aspectRatio) {
  let ncolumns = 1;
  let nrows = 1;
  while (ncolumns * nrows < numberOfCells) {
    const aspectRatioIfColumnsAreIncremented = (ncolumns + 1) / nrows;
    const aspectRatioIfRowsAreIncremented = ncolumns / (nrows + 1);
    const deltaC = Math.abs(aspectRatio - aspectRatioIfColumnsAreIncremented);
    const deltaR = Math.abs(aspectRatio - aspectRatioIfRowsAreIncremented);
    if (deltaC < deltaR) {
      ncolumns++;
    } else {
      nrows++;
    }
  }
  return { nrows, ncolumns };
}
function getGridCellPositions(numberOfCells, nrows, ncolumns) {
  const cellWidth = 1 / ncolumns;
  const cellHeight = 1 / nrows;
  const cells = [];
  for (let rowIndex = 0; rowIndex < nrows; rowIndex++) {
    for (let columnIndex = 0; columnIndex < ncolumns; columnIndex++) {
      cells.push({
        x1: cellWidth * columnIndex,
        x2: cellWidth * (columnIndex + 1),
        y1: cellHeight * rowIndex,
        y2: cellHeight * (rowIndex + 1)
      });
      if (cells.length === numberOfCells)
        break;
    }
    if (cells.length === numberOfCells)
      break;
  }
  return cells;
}
function getGridCells({
  numberOfCells,
  rows,
  columns
}, parentSection) {
  if (numberOfCells === 0)
    return [];
  const aspectRatio = getAspectRatio(parentSection);
  const { nrows, ncolumns } = getNRowsAndColumns(
    numberOfCells,
    rows,
    columns,
    aspectRatio
  );
  if (nrows * ncolumns < numberOfCells) {
    throw new Error("numberOfCells lower than rows * columns");
  }
  return getGridCellPositions(numberOfCells, nrows, ncolumns);
}
var RecorderBase = class {
  constructor() {
    this._resetCalls();
  }
  _resetCalls() {
    this._positioningCalls = { call: [], args: [], submarks: [] };
  }
  // Record method calls
  closePath() {
    addCall(this._positioningCalls, "closePath", arguments);
  }
  moveTo() {
    addCall(this._positioningCalls, "moveTo", arguments);
  }
  lineTo() {
    addCall(this._positioningCalls, "lineTo", arguments);
  }
  quadraticCurveTo() {
    addCall(this._positioningCalls, "quadraticCurveTo", arguments);
  }
  bezierCurveTo() {
    addCall(this._positioningCalls, "bezierCurveTo", arguments);
  }
  arcTo() {
    addCall(this._positioningCalls, "arcTo", arguments);
  }
  arc() {
    addCall(this._positioningCalls, "arc", arguments);
  }
  ellipse() {
    addCall(this._positioningCalls, "ellipse", arguments);
  }
  translate() {
    addCall(this._positioningCalls, "translate", arguments);
  }
  rotate() {
    addCall(this._positioningCalls, "rotate", arguments);
  }
  // Custom method to detect multi polygons / multi linestrings
  submarkStart() {
    this._positioningCalls.submarks.push(this._positioningCalls.call.length);
  }
};
function addCall(obj, callName, args) {
  obj.call.push(callName);
  obj.args.push(args);
}
var RecorderMark = class extends RecorderBase {
  result() {
    return this._positioningCalls;
  }
};
var RecorderLayer = class extends RecorderBase {
  constructor() {
    super();
    this._marks = [];
  }
  markEnd() {
    this._marks.push(this._positioningCalls);
    this._resetCalls();
  }
  result() {
    return this._marks;
  }
};
var RecorderLabel = class extends RecorderMark {
  _resetCalls() {
    this._positioningCalls = { call: [], args: [], submarks: [] };
  }
};
var RecorderLabelLayer = class extends RecorderLayer {
  _resetCalls() {
    this._positioningCalls = { call: [], args: [], submarks: [] };
  }
};
function recorderMark() {
  return new RecorderMark();
}
function recorderLayer() {
  return new RecorderLayer();
}
function recorderLabel() {
  return new RecorderLabel();
}
function recorderLabelLayer() {
  return new RecorderLabelLayer();
}
var BaseContext = class {
  beginPath() {
  }
  closePath() {
  }
  moveTo() {
  }
  lineTo() {
  }
  quadraticCurveTo() {
  }
  bezierCurveTo() {
  }
  arcTo() {
  }
  arc() {
  }
  ellipse() {
  }
  fill() {
  }
  stroke() {
  }
  setLineDash() {
  }
  fillText() {
  }
  strokeText() {
  }
  translate() {
  }
  rotate() {
  }
  save() {
  }
  restore() {
  }
  rect() {
  }
  clip() {
  }
  setTransform() {
  }
  markStart() {
  }
  markEnd() {
  }
  layerStart() {
  }
  layerEnd() {
  }
  submarkStart() {
  }
};
var pi3 = Math.PI;
var tau3 = 2 * pi3;
var epsilon3 = 1e-6;
var tauEpsilon2 = tau3 - epsilon3;
function ellipse(pathGen, x3, y3, rx, ry, rot, a0, a1, ccw) {
  x3 = +x3;
  y3 = +y3;
  rx = +rx;
  ry = +ry;
  ccw = !!ccw;
  const dx = rx * Math.cos(a0);
  const dy = ry * Math.sin(a0);
  const x0 = x3 + dx;
  const y0 = y3 + dy;
  const cw = 1 ^ ccw;
  let da = ccw ? a0 - a1 : a1 - a0;
  if (rx < 0)
    throw new Error("negative radius x: " + rx);
  if (ry < 0)
    throw new Error("negative radius: " + ry);
  if (pathGen._x1 === null) {
    pathGen._ += "M" + x0 + "," + y0;
  } else if (Math.abs(pathGen._x1 - x0) > epsilon3 || Math.abs(pathGen._y1 - y0) > epsilon3) {
    pathGen._ += "L" + x0 + "," + y0;
  }
  if (!rx)
    return;
  if (!ry)
    return;
  if (da < 0)
    da = da % tau3 + tau3;
  if (da > tauEpsilon2) {
    pathGen._ += "A" + rx + "," + ry + ",0,1," + cw + "," + (x3 - dx) + "," + (y3 - dy) + "A" + rx + "," + ry + ",0,1," + cw + "," + (pathGen._x1 = x0) + "," + (pathGen._y1 = y0);
  } else if (da > epsilon3) {
    pathGen._ += "A" + rx + "," + ry + ",0," + +(da >= pi3) + "," + cw + "," + (pathGen._x1 = x3 + rx * Math.cos(a1)) + "," + (pathGen._y1 = y3 + ry * Math.sin(a1));
  }
}
function path2() {
  return new Path2();
}
function pathLayer() {
  return new PathLayer();
}
var BasePath = class extends BaseContext {
  constructor() {
    super();
    this._pathContext = path();
  }
  _reset() {
    this._pathContext._x0 = null;
    this._pathContext._y0 = null;
    this._pathContext._x1 = null;
    this._pathContext._y1 = null;
    this._pathContext._ = "";
  }
  closePath() {
    this._pathContext.closePath();
  }
  moveTo(x3, y3) {
    this._pathContext.moveTo(x3, y3);
  }
  lineTo(x3, y3) {
    this._pathContext.lineTo(x3, y3);
  }
  quadraticCurveTo() {
    this._pathContext.quadraticCurveTo.apply(this._pathContext, arguments);
  }
  bezierCurveTo() {
    this._pathContext.bezierCurveTo.apply(this._pathContext, arguments);
  }
  arcTo() {
    this._pathContext.arcTo.apply(this._pathContext, arguments);
  }
  arc() {
    this._pathContext.arc.apply(this._pathContext, arguments);
  }
  ellipse(x3, y3, rx, ry, rot, a0, a1, ccw) {
    ellipse(this._pathContext, x3, y3, rx, ry, rot, a0, a1, ccw);
  }
};
var Path2 = class extends BasePath {
  result() {
    const output = { d: this._pathContext.toString() };
    this._reset();
    return output;
  }
};
var PathLayer = class extends BasePath {
  constructor() {
    super();
    this.marks = [];
  }
  markEnd() {
    this.marks.push({ d: this._pathContext.toString() });
    this._reset();
  }
  result() {
    const result = this.marks;
    this.marks = [];
    return result;
  }
};
function text2() {
  return new Text();
}
function textLayer() {
  return new TextLayer();
}
var BaseText = class extends BaseContext {
  constructor() {
    super();
    this._reset();
  }
  _reset() {
    this._currentStyle = {};
    this._currentRotation = null;
  }
  translate(x3, y3) {
    this._currentStyle.x = x3;
    this._currentStyle.y = y3;
  }
  rotate(rotation) {
    this._currentRotation = rotation;
  }
};
var Text = class extends BaseText {
  result() {
    const result = getTextData(this);
    this._reset();
    return result;
  }
};
var TextLayer = class extends BaseText {
  constructor() {
    super();
    this.marks = [];
  }
  markEnd() {
    const result = getTextData(this);
    this._reset();
    this.marks.push(result);
  }
  result() {
    const result = this.marks;
    this.marks = [];
    return result;
  }
};
function getTextData(self) {
  const result = self._currentStyle;
  if (self._currentRotation) {
    result.transform = getRotation(self._currentRotation, result.x, result.y);
  }
  return result;
}
function getRotation(rotationRadians, x3, y3) {
  const rotationDegrees = rotationRadians * (180 / Math.PI);
  return `rotate(${rotationDegrees},${x3},${y3})`;
}
function circle() {
  return new Circle();
}
function circleLayer() {
  return new CircleLayer();
}
var BaseCircle = class extends BaseContext {
  constructor() {
    super();
    this._reset();
  }
  _reset() {
    this._currentStyle = {};
  }
  beginPath() {
  }
  arc(x3, y3, radius, sAngle, eAngle, counterclockwise) {
    this._currentStyle.cx = x3;
    this._currentStyle.cy = y3;
  }
};
var Circle = class extends BaseCircle {
  result() {
    const result = getCircleData(this);
    this._reset();
    return result;
  }
};
var CircleLayer = class extends BaseCircle {
  constructor() {
    super();
    this.marks = [];
  }
  markEnd() {
    this.marks.push(this._currentStyle);
    this._reset();
  }
  result() {
    const result = this.marks;
    this.marks = [];
    return result;
  }
};
function getCircleData(self) {
  const result = self._currentStyle;
  return result;
}
var svgPositioning = Object.freeze({
  __proto__: null,
  path: path2,
  pathLayer,
  text: text2,
  textLayer,
  getRotation,
  circle,
  circleLayer
});
function path$1() {
  return new Path$1();
}
function pathLayer$1() {
  return new PathLayer$1();
}
var BasePath$1 = class extends BaseContext {
  constructor() {
    super();
    this._pathContext = path();
  }
  _reset() {
    this._pathContext._x0 = null;
    this._pathContext._y0 = null;
    this._pathContext._x1 = null;
    this._pathContext._y1 = null;
    this._pathContext._ = "";
    resetStyles(this, PATH_STYLES);
  }
  closePath() {
    this._pathContext.closePath();
  }
  moveTo(x3, y3) {
    this._pathContext.moveTo(x3, y3);
  }
  lineTo(x3, y3) {
    this._pathContext.lineTo(x3, y3);
  }
  quadraticCurveTo() {
    this._pathContext.quadraticCurveTo.apply(this._pathContext, arguments);
  }
  bezierCurveTo() {
    this._pathContext.bezierCurveTo.apply(this._pathContext, arguments);
  }
  arcTo() {
    this._pathContext.arcTo.apply(this._pathContext, arguments);
  }
  arc() {
    this._pathContext.arc.apply(this._pathContext, arguments);
  }
  ellipse(x3, y3, rx, ry, rot, a0, a1, ccw) {
    ellipse(this._pathContext, x3, y3, rx, ry, rot, a0, a1, ccw);
  }
  setLineDash(dashArray) {
    this._strokeDashArray = dashArray.join(" ");
  }
};
var Path$1 = class extends BasePath$1 {
  result() {
    const result = getPathData(this);
    this._reset();
    return result;
  }
};
var PathLayer$1 = class extends BasePath$1 {
  constructor() {
    super();
    this.marks = [];
  }
  markEnd() {
    this.marks.push(getPathData(this));
    this._reset();
  }
  layerEnd() {
    if (anyStylesActive(this, PATH_STYLES)) {
      for (let i2 = 0; i2 < this.marks.length; i2++) {
        attachStyles(this.marks[i2], this, PATH_STYLES);
      }
    }
  }
  result() {
    const result = this.marks;
    this.marks = [];
    return result;
  }
};
function getPathData(self) {
  const result = { d: self._pathContext.toString() };
  attachStyles(result, self, PATH_STYLES);
  return result;
}
var PATH_STYLES = {
  fillStyle: "fill",
  strokeStyle: "stroke",
  lineWidth: "stroke-width",
  _strokeDashArray: "stroke-dasharray",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  miterLimit: "stroke-miterlimit",
  lineDashOffset: "stroke-dashoffset"
};
function attachStyles(target, source, styles) {
  for (const styleName in styles) {
    if (source[styleName]) {
      target[styles[styleName]] = source[styleName];
    }
  }
}
function anyStylesActive(context, styles) {
  for (const styleName in styles) {
    if (context[styleName])
      return true;
  }
  return false;
}
function resetStyles(context, styles) {
  for (const styleName in styles) {
    context[styleName] = void 0;
  }
}
function text$1() {
  return new Text$1();
}
function textLayer$1() {
  return new TextLayer$1();
}
var BaseText$1 = class extends BaseContext {
  constructor() {
    super();
    this._reset();
  }
  _reset() {
    this._currentStyle = {};
    this._currentRotation = null;
  }
  fillText(text3, x3, y3) {
    this._currentStyle.text = text3;
    this._currentStyle.fill = this.fillStyle;
  }
  strokeText(text3, x3, y3) {
    this._currentStyle.text = text3;
    this._currentStyle.stroke = this.strokeStyle;
    this._currentStyle["stroke-width"] = this.lineWidth;
  }
  translate(x3, y3) {
    this._currentStyle.x = x3;
    this._currentStyle.y = y3;
  }
  rotate(rotation) {
    this._currentRotation = rotation;
  }
};
var Text$1 = class extends BaseText$1 {
  result() {
    const result = getTextData$1(this);
    this._reset();
    return result;
  }
};
var TextLayer$1 = class extends BaseText$1 {
  constructor() {
    super();
    this.marks = [];
  }
  markEnd() {
    const result = getTextData$1(this);
    this._reset();
    this.marks.push(result);
  }
  result() {
    const result = this.marks;
    this.marks = [];
    return result;
  }
};
function getTextData$1(self) {
  const result = self._currentStyle;
  result.style = `font:${self.font};`;
  result["dominant-baseline"] = self.textBaseline;
  result["text-anchor"] = self.textAlign === "center" ? "middle" : self.textAlign;
  if (self._currentRotation) {
    result.transform = getRotation(self._currentRotation, result.x, result.y);
  }
  return result;
}
function circle$1() {
  return new Circle$1();
}
function circleLayer$1() {
  return new CircleLayer$1();
}
var BaseCircle$1 = class extends BaseContext {
  constructor() {
    super();
    this._currentStyle = {};
  }
  beginPath() {
  }
  arc(x3, y3, radius, sAngle, eAngle, counterclockwise) {
    this._currentStyle.cx = x3;
    this._currentStyle.cy = y3;
    this._currentStyle.r = radius;
  }
  setLineDash(dashArray) {
    this._strokeDashArray = dashArray.join(" ");
  }
};
var Circle$1 = class extends BaseCircle$1 {
  result() {
    const result = getCircleData$1(this);
    this._currentStyle = {};
    resetStyles(this, POINT_STYLES);
    return result;
  }
};
var CircleLayer$1 = class extends BaseCircle$1 {
  constructor() {
    super();
    this.marks = [];
  }
  markEnd() {
    const result = getCircleData$1(this);
    this.marks.push(result);
    this._currentStyle = {};
    resetStyles(this, POINT_STYLES);
  }
  layerEnd() {
    if (anyStylesActive(this, POINT_STYLES)) {
      for (let i2 = 0; i2 < this.marks.length; i2++) {
        attachStyles(this.marks[i2], this, POINT_STYLES);
      }
    }
  }
  result() {
    const result = this.marks;
    this.marks = [];
    return result;
  }
};
function getCircleData$1(self) {
  const result = self._currentStyle;
  attachStyles(result, self, POINT_STYLES);
  return result;
}
var POINT_STYLES = {
  fillStyle: "fill",
  strokeStyle: "stroke",
  lineWidth: "stroke-width",
  _strokeDashArray: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset"
};
var svgStyled = Object.freeze({
  __proto__: null,
  path: path$1,
  pathLayer: pathLayer$1,
  text: text$1,
  textLayer: textLayer$1,
  circle: circle$1,
  circleLayer: circleLayer$1
});
function chain(...transformers) {
  const lastIndex = transformers.length - 1;
  let result = transformers[lastIndex];
  for (let i2 = lastIndex - 1; i2 >= 0; i2--) {
    const transformer2 = transformers[i2];
    if (transformer2) {
      result = transformer2(result);
    }
  }
  result.markEnd = transformers[lastIndex].markEnd ? transformers[lastIndex].markEnd.bind(transformers[lastIndex]) : () => {
  };
  result.submarkStart = transformers[lastIndex].submarkStart ? transformers[lastIndex].submarkStart.bind(transformers[lastIndex]) : () => {
  };
  return result;
}
function Transformer(stream2) {
  this.stream = stream2;
}
Transformer.prototype = {
  constructor: Transformer,
  // Stream
  point(x3, y3) {
    this.stream.point(x3, y3);
  },
  areaStart() {
    this.stream.areaStart();
  },
  areaEnd() {
    this.stream.areaEnd();
  },
  lineStart() {
    this.stream.lineStart();
  },
  lineEnd() {
    this.stream.lineEnd();
  },
  polygonStart() {
    this.stream.polygonStart();
  },
  polygonEnd() {
    this.stream.polygonEnd();
  },
  // Context
  beginPath() {
    this.stream.beginPath();
  },
  moveTo() {
    this.stream.moveTo.apply(this.stream, arguments);
  },
  closePath() {
    this.stream.closePath();
  },
  lineTo() {
    this.stream.lineTo.apply(this.stream, arguments);
  },
  quadraticCurveTo() {
    this.stream.quadraticCurveTo.apply(this.stream, arguments);
  },
  bezierCurveTo() {
    this.stream.quadraticCurveTo.apply(this.stream, arguments);
  },
  arc() {
    this.stream.arc.apply(this.stream, arguments);
  },
  arcTo() {
    this.stream.arcTo.apply(this.stream, arguments);
  },
  ellipse() {
    this.stream.ellipse.apply(this.stream, arguments);
  }
};
function x22(value) {
  return ({ scaleX }) => scaleX(value) + scaleX.bandwidth();
}
function y22(value) {
  return ({ scaleY }) => scaleY(value) + scaleY.bandwidth();
}
function x2s(values) {
  return ({ scaleX }) => values.map((x3) => scaleX(x3) + scaleX.bandwidth());
}
function y2s(values) {
  return ({ scaleY }) => values.map((x3) => scaleY(x3) + scaleY.bandwidth());
}
function fitScales(bbox) {
  const domainX = bbox.x;
  const domainY = bbox.y;
  let rangeX;
  let rangeY;
  const scaleX = linear().domain(domainX);
  const scaleY = linear().domain(domainY);
  const setRangeX = (range) => {
    rangeX = range;
    updateRanges();
    return scaleX;
  };
  const setRangeY = (range) => {
    rangeY = range;
    updateRanges();
    return scaleY;
  };
  function updateRanges() {
    if (rangeX && rangeY) {
      const rangeDeltaX = Math.abs(rangeX[1] - rangeX[0]);
      const rangeDeltaY = Math.abs(rangeY[1] - rangeY[0]);
      const midX = (rangeX[0] + rangeX[1]) / 2;
      const midY = (rangeY[0] + rangeY[1]) / 2;
      const scalingFactorX = rangeDeltaX / (domainX[1] - domainX[0]);
      const scalingFactorY = rangeDeltaY / (domainY[1] - domainY[0]);
      if (scalingFactorX < scalingFactorY) {
        const fromMidY = (domainY[1] - domainY[0]) / 2 * scalingFactorX;
        const newRangeY = [midY - fromMidY, midY + fromMidY];
        if (rangeY[0] > rangeY[1])
          newRangeY.reverse();
        scaleX.range(rangeX);
        scaleY.range(newRangeY);
      }
      if (scalingFactorX >= scalingFactorY) {
        const fromMidX = (domainX[1] - domainX[0]) / 2 * scalingFactorY;
        const newRangeX = [midX - fromMidX, midX + fromMidX];
        scaleX.range(newRangeX);
        scaleY.range(rangeY);
      }
    }
  }
  const dummyScaleObject = {
    scaleX: { range: setRangeX, copy: function() {
      return this;
    } },
    scaleY: { range: setRangeY, copy: function() {
      return this;
    } }
  };
  return dummyScaleObject;
}
function getClipId(props, section) {
  const clipType = getClipType(props, section);
  if (clipType === "padding") {
    return `clip-padding-${section.id}`;
  }
  if (clipType === "outer") {
    return `clip-outer-${section.id}`;
  }
}
function getClipPathURL(props, section) {
  const clipId = getClipId(props, section);
  if (clipId === void 0)
    return;
  return `url(#${clipId})`;
}
function getClipType(props, section) {
  return props.clip !== void 0 ? props.clip : section.clip;
}
function bboxToClipRect({ minX, minY, maxX, maxY }) {
  return {
    x: minX,
    y: minY,
    width: Math.max(maxX - minX, 0),
    height: Math.max(maxY - minY, 0)
  };
}
var canvas;
var ctx;
function getCtx() {
  if (!ctx) {
    canvas = document.createElement("canvas");
    ctx = canvas.getContext("2d");
  }
  return ctx;
}
function aestheticGetter(aesthetic, keys) {
  if (aesthetic === void 0)
    return () => void 0;
  if (aesthetic.constructor === Array) {
    return (i2) => aesthetic[i2];
  }
  if (aesthetic.constructor === Function) {
    return keys ? (i2) => aesthetic({ index: i2, key: keys[i2] }) : (i2) => aesthetic({ index: i2, key: i2 });
  }
  return () => aesthetic;
}
function batchAestheticGetter(props, aestheticNames, keys) {
  const aestheticGetters = {};
  for (const aestheticName of aestheticNames) {
    if (props[aestheticName] !== void 0) {
      aestheticGetters[aestheticName] = aestheticGetter(props[aestheticName], keys);
    }
  }
  return function(i2) {
    const aesthetics = {};
    for (const aestheticName in aestheticGetters) {
      aesthetics[aestheticName] = aestheticGetters[aestheticName](i2);
    }
    return aesthetics;
  };
}
function areAllStylesGlobal(props, aestheticNames) {
  for (let i2 = 0; i2 < aestheticNames.length; i2++) {
    const aestheticName = aestheticNames[i2];
    if (props[aestheticName] === void 0)
      continue;
    if (props[aestheticName].constructor === Array || props[aestheticName].constructor === Function) {
      return false;
    }
  }
  return true;
}
function pointInPolygon(point6, polygon) {
  const x3 = point6[0];
  const y3 = point6[1];
  let inside = false;
  for (let i2 = 0, j2 = polygon.length - 1; i2 < polygon.length; j2 = i2++) {
    const xi = polygon[i2][0];
    const yi = polygon[i2][1];
    const xj = polygon[j2][0];
    const yj = polygon[j2][1];
    const intersect = yi > y3 !== yj > y3 && x3 < (xj - xi) * (y3 - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}
function hasStartAndEndCalls(context) {
  return "markEnd" in context;
}
function getClipBbox(props, section) {
  const clipType = getClipType$1(props, section);
  if (clipType === "padding") {
    return section.paddedBbox;
  }
  if (clipType === "outer") {
    return section.bbox;
  }
}
function getClip(props, section) {
  return clipArgs(getClipBbox(props, section));
}
function applyClipping(context, clipping) {
  context.beginPath();
  context.rect.apply(context, clipping);
  context.clip();
}
function applyPositioning(context, positioning) {
  for (let i2 = 0; i2 < positioning.call.length; i2++) {
    context[positioning.call[i2]].apply(context, positioning.args[i2]);
  }
}
function getClipType$1(props, section) {
  return props.clip !== void 0 ? props.clip : section.clip;
}
function clipArgs({ minX, minY, maxX, maxY }) {
  return [
    minX,
    minY,
    maxX - minX,
    maxY - minY
  ];
}
var currentId = 0;
function getId() {
  return "m" + currentId++;
}
var Mark = class {
  constructor(positioning, props, section, styler, type) {
    this.positioning = positioning;
    this.props = props;
    this.section = section;
    this.styler = styler;
    this.type = type;
    this.id = getId();
  }
  /**
   * Render mark to context.
   * @param {Object} context A 2d canvas context, or some other rendervous context.
   */
  render(context) {
    context.save();
    hasStartAndEndCalls(context) ? this._renderWithStartAndEndCalls(context) : this._render(context);
    context.restore();
  }
  /**
   * Updates non-positioning props / aesthetics.
   * @param {Object} aesthetics An object containing the updated values
   */
  updateAesthetics(aesthetics) {
    for (const aestheticName in aesthetics) {
      this.props[aestheticName] = aesthetics[aestheticName];
    }
  }
  // Internal
  _renderWithStartAndEndCalls(context) {
    context.markStart();
    const clip = getClip(this.props, this.section);
    applyClipping(context, clip);
    applyPositioning(context, this.positioning);
    this.styler.apply(context, this.props);
    context.markEnd();
  }
  _render(context) {
    const clip = getClip(this.props, this.section);
    applyClipping(context, clip);
    context.beginPath();
    applyPositioning(context, this.positioning);
    this.styler.apply(context, this.props);
  }
};
var SpatialIndex = class {
  constructor(interactionHandler, getMark, getLayer) {
    this._rbush = new RBush();
    this._interactionHandler = interactionHandler;
    this._getMark = getMark.bind(interactionHandler);
    this._getLayer = getLayer.bind(interactionHandler);
  }
  indexMark(markId2) {
    const mark = this._getMark(markId2);
    this._rbush.load(mark);
  }
  unindexMark(markId2) {
    const mark = this._getMark(markId2);
    for (let i2 = 0; i2 < mark.length; i2++) {
      this._rbush.remove(mark[i2]);
    }
  }
  indexLayer(layerId2) {
    const layer = this._getLayer(layerId2);
    this._rbush.load(layer);
  }
  unindexLayer(layerId2) {
    const layer = this._getLayer(layerId2);
    for (let i2 = 0; i2 < layer.length; i2++) {
      this._rbush.remove(layer[i2]);
    }
  }
  queryMouseCoordinates({ x: x3, y: y3 }) {
    const potentialHits = this._rbush.search({ minX: x3, maxX: x3, minY: y3, maxY: y3 });
    return this._getHits(x3, y3, potentialHits);
  }
  queryBoundingBox(boundingBox) {
    return this._rbush.search(boundingBox);
  }
  _getHits(x3, y3, potentialHits) {
    const ctx2 = getCtx();
    const hits = [];
    for (let i2 = 0; i2 < potentialHits.length; i2++) {
      const potentialHit = potentialHits[i2];
      ctx2.beginPath();
      const isHit = potentialHit.data.constructor === Mark ? this._detectCollisionMark(x3, y3, potentialHit) : this._detectCollisionLayer(x3, y3, potentialHit);
      if (isHit)
        hits.push(potentialHit);
    }
    return hits;
  }
  _detectCollisionMark(x3, y3, potentialHit) {
    const ctx2 = getCtx();
    if ("text" in potentialHit.data.props) {
      return detectCollisionText(x3, y3, potentialHit);
    }
    const markData = potentialHit.data;
    "segment" in potentialHit ? runCallsSegment(ctx2, markData.positioning, potentialHit.segment) : runCalls(ctx2, markData.positioning);
    const props = markData.props;
    if (hasFill(props)) {
      if (ctx2.isPointInPath(x3, y3))
        return true;
    }
    if (hasStroke(props)) {
      ctx2.lineWidth = props.strokeWidth;
      if (ctx2.isPointInStroke(x3, y3))
        return true;
    }
    return false;
  }
  _detectCollisionLayer(x3, y3, potentialHit) {
    const ctx2 = getCtx();
    if ("text" in potentialHit.data.props) {
      return detectCollisionText(x3, y3, potentialHit);
    }
    const layerData = potentialHit.data;
    const index = potentialHit.index;
    const positioning = layerData.positioning[index];
    "segment" in potentialHit ? runCallsSegment(ctx2, positioning, potentialHit.segment) : runCalls(ctx2, positioning);
    const props = batchAestheticGetter(
      layerData.props,
      ["fill", "stroke", "strokeWidth"],
      layerData.props.keys
    )(index);
    if (hasFill(props)) {
      if (ctx2.isPointInPath(x3, y3))
        return true;
    }
    if (hasStroke(props)) {
      ctx2.lineWidth = props.strokeWidth;
      if (ctx2.isPointInStroke(x3, y3))
        return true;
    }
    return false;
  }
};
var hasProp = (prop) => (props) => props[prop] && props[prop] !== "none";
var hasFill = hasProp("fill");
var hasStroke = hasProp("stroke");
function runCallsSegment(context, positioning, segment) {
  const lastCoords = getLastCoords(positioning, segment);
  const thisCall = positioning.call[segment];
  const thisArgs = positioning.args[segment];
  const segmentPositioning = {
    call: ["moveTo", thisCall],
    args: [lastCoords, thisArgs]
  };
  runCalls(context, segmentPositioning);
}
function getLastCoords(callObj, segment) {
  const lastCall = callObj.call[segment - 1];
  const lastArgs = callObj.args[segment - 1];
  switch (lastCall) {
    case "moveTo":
      return lastArgs;
    case "lineTo":
      return lastArgs;
    case "quadraticCurveTo":
      return [lastArgs[2], lastArgs[3]];
    case "bezierCurveTo":
      return [lastArgs[4], lastArgs[5]];
    default:
      throw new Error(`Invalid last call: ${lastCall}`);
  }
}
function runCalls(context, positioning) {
  for (let i2 = 0; i2 < positioning.call.length; i2++) {
    context[positioning.call[i2]].apply(context, positioning.args[i2]);
  }
}
function detectCollisionText(x3, y3, potentialHit) {
  const rotatedBbox = potentialHit.rotatedBbox;
  return pointInPolygon([x3, y3], rotatedBbox);
}
var w2 = typeof window !== "undefined" ? window : { screen: {}, navigator: {} };
var matchMedia = w2.matchMedia || (() => ({ matches: false }));
var options = {
  get passive() {
    return true;
  }
};
var noop2 = () => {
};
w2.addEventListener && w2.addEventListener("p", noop2, options);
w2.removeEventListener && w2.removeEventListener("p", noop2, false);
var onTouchStartInWindow = "ontouchstart" in w2;
var touchEventInWindow = "TouchEvent" in w2;
var supportsTouchEvents = onTouchStartInWindow || touchEventInWindow && matchMedia("(any-pointer: coarse)").matches;
var hasTouch = (w2.navigator.maxTouchPoints || 0) > 0 || supportsTouchEvents;
var userAgent = w2.navigator.userAgent || "";
var isIPad = matchMedia("(pointer: coarse)").matches && /iPad|Macintosh/.test(userAgent) && Math.min(w2.screen.width || 0, w2.screen.height || 0) >= 768;
var hasCoarsePrimaryPointer = (matchMedia("(pointer: coarse)").matches || !matchMedia("(pointer: fine)").matches && onTouchStartInWindow) && !/Windows.*Firefox/.test(userAgent);
var hasAnyHoverOrAnyFinePointer = matchMedia("(any-pointer: fine)").matches || matchMedia("(any-hover: hover)").matches || isIPad || !onTouchStartInWindow;
var deviceType = hasTouch && (hasAnyHoverOrAnyFinePointer || !hasCoarsePrimaryPointer) ? "hybrid" : hasTouch ? "touchOnly" : "mouseOnly";
var primaryInput = deviceType === "mouseOnly" ? "mouse" : deviceType === "touchOnly" ? "touch" : hasCoarsePrimaryPointer ? "touch" : "mouse";
var handler;
var _window;
function initWindow(w3) {
  if (w3) {
    _window = w3;
  } else {
    _window = window;
  }
}
var EventTracker = class {
  constructor(eventManager, { eventName, nativeEventName, useWindow, preventDefault }) {
    this._eventManager = eventManager;
    this._eventName = eventName;
    this._nativeEventName = nativeEventName;
    this._useWindow = useWindow;
    this._preventDefault = preventDefault;
    this._numberOfActiveListeners = 0;
    this._callbacks = {};
  }
  setNativeEventName(nativeEventName) {
    this._nativeEventName = nativeEventName;
  }
  addListener(listenerId, callback) {
    this._callbacks[listenerId] = callback;
    if (this._eventManagerHasBeenMounted()) {
      this._attachNativeListenerIfNecessary();
    }
  }
  attachAllListeners() {
    for (const _2 in this._callbacks) {
      this._attachNativeListenerIfNecessary();
    }
  }
  removeListener(listenerId) {
    delete this._callbacks[listenerId];
    if (this._eventManagerHasBeenMounted()) {
      this._removeNativeListenerIfNecessary();
    }
  }
  _eventManagerHasBeenMounted() {
    return this._eventManager._mounted;
  }
  _attachNativeListenerIfNecessary() {
    if (this._numberOfActiveListeners === 0) {
      handler = this._handleEvent.bind(this);
      const nativeEventName = this._nativeEventName;
      if (this._useWindow) {
        _window.addEventListener(nativeEventName, handler);
      }
      if (!this._useWindow) {
        this._eventManager._domNode.addEventListener(nativeEventName, handler);
      }
    }
    this._numberOfActiveListeners++;
  }
  _removeNativeListenerIfNecessary() {
    this._numberOfActiveListeners--;
    if (this._numberOfActiveListeners === 0) {
      const nativeEventName = this._nativeEventName;
      if (this._useWindow) {
        _window.removeEventListener(nativeEventName, handler);
      }
      if (!this._useWindow) {
        this._eventManager._domNode.removeEventListener(nativeEventName, handler);
      }
    }
  }
  _handleEvent(nativeEvent) {
    if (this._preventDefault)
      nativeEvent.preventDefault();
    const screenCoordinates = this._getScreenCoordinates(nativeEvent);
    nativeEvent.eventName = this._eventName;
    for (const listenerId in this._callbacks) {
      this._callbacks[listenerId](screenCoordinates, nativeEvent);
    }
  }
  _getScreenCoordinates(nativeEvent) {
    return this._eventManager._getScreenCoordinates(nativeEvent);
  }
};
var BaseEventManager = class {
  constructor(EXPOSED_EVENTS2, managerType) {
    this._domNode = void 0;
    this._svgPoint = void 0;
    this._mounted = false;
    this._trackers = {};
    this._BROWSER_TYPE = void 0;
    this._managerType = managerType;
    for (const event of EXPOSED_EVENTS2) {
      this._trackers[event.eventName] = new EventTracker(this, event);
    }
  }
  // Svelte can only bind to DOM nodes after initialization
  addRootNode(domNode, type) {
    this._domNode = domNode;
    if (type === "svg") {
      this._svgPoint = this._domNode.createSVGPoint();
    }
    this._BROWSER_TYPE = window.navigator.pointerEnabled ? "IE11 / MSEdge" : window.navigator.msPointerEnabled ? "IE10 / WP8" : "other";
    this._mounted = true;
  }
  attachEventListeners() {
    if (this._mounted === false)
      throw new Error("root node must be added first");
    for (const eventName in this._trackers) {
      if (this._managerType === "mouse") {
        this._trackers[eventName].setNativeEventName(this._getNativeMouseEventName(eventName, this._BROWSER_TYPE));
      }
      if (this._managerType === "touch") {
        this._trackers[eventName].setNativeEventName(this._getNativeTouchEventName(eventName, this._BROWSER_TYPE));
      }
      this._trackers[eventName].attachAllListeners();
    }
  }
  eventTracker(eventName) {
    return this._trackers[eventName];
  }
};
var capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
var MouseEventManager = class extends BaseEventManager {
  constructor() {
    super(EXPOSED_EVENTS, "mouse");
  }
  _getNativeMouseEventName(exposedEventName, BROWSER_TYPE) {
    if (exposedEventName === "click")
      return "click";
    if (exposedEventName === "wheel")
      return "wheel";
    if (BROWSER_TYPE === "IE11 / MSEdge") {
      const lastPart = sliceOffMouse(exposedEventName);
      return "pointer" + lastPart;
    }
    if (BROWSER_TYPE === "IE10 / WP8") {
      const lastPart = sliceOffMouse(exposedEventName);
      return "MSPointer" + capitalize(lastPart);
    }
    if (BROWSER_TYPE === "other") {
      return exposedEventName;
    }
  }
  _getScreenCoordinates(nativeEvent) {
    if (this._svgPoint) {
      this._svgPoint.x = nativeEvent.clientX;
      this._svgPoint.y = nativeEvent.clientY;
      return this._svgPoint.matrixTransform(this._domNode.getScreenCTM().inverse());
    }
    const rect = this._domNode.getBoundingBoxClientRect ? this._domNode.getBoundingBoxClientRect() : this._domNode.getBoundingClientRect();
    const x3 = nativeEvent.clientX - rect.left;
    const y3 = nativeEvent.clientY - rect.top;
    return { x: x3, y: y3 };
  }
};
var EVENT_NAMES = ["mousedown", "mouseup", "mousemove", "mouseout", "click", "wheel"];
var WINDOW_EVENTS = ["mousemove", "mouseup"];
var PREVENT_DEFAULT = ["mousedown"];
var EXPOSED_EVENTS = EVENT_NAMES.map((eventName) => ({
  eventName,
  nativeEventName: void 0,
  useWindow: WINDOW_EVENTS.includes(eventName),
  preventDefault: PREVENT_DEFAULT.includes(eventName)
}));
var sliceOffMouse = (str) => str.slice(5, str.length);
var TouchEventManager = class extends BaseEventManager {
  constructor() {
    super(EXPOSED_EVENTS$1, "touch");
  }
  _getNativeTouchEventName(exposedEventName, BROWSER_TYPE) {
    if (BROWSER_TYPE === "IE11 / MSEdge") {
      const lastPart = sliceOffTouch(exposedEventName);
      return "pointer" + lastPart;
    }
    if (BROWSER_TYPE === "IE10 / WP8") {
      const lastPart = sliceOffTouch(exposedEventName);
      return "MSPointer" + capitalize(lastPart);
    }
    if (BROWSER_TYPE === "other") {
      return exposedEventName;
    }
  }
  _getScreenCoordinates(nativeEvent) {
    const touches = getTouches(nativeEvent);
    if (touches.length === 1) {
      return this._getScreenCoordinatesSingle(touches[0]);
    }
    if (touches.length > 1) {
      return this._getScreenCoordinatesMulti(touches);
    }
  }
  _getScreenCoordinatesSingle(touch) {
    if (this._svgPoint) {
      this._svgPoint.x = touch.clientX;
      this._svgPoint.y = touch.clientY;
      return this._svgPoint.matrixTransform(this._domNode.getScreenCTM().inverse());
    }
    const rect = this._domNode.getBoundingBoxClientRect ? this._domNode.getBoundingBoxClientRect() : this._domNode.getBoundingClientRect();
    const x3 = touch.clientX - rect.left;
    const y3 = touch.clientY - rect.top;
    return { x: x3, y: y3 };
  }
  _getScreenCoordinatesMulti(touches) {
    const touchesInScreenCoordinates = [];
    for (const touch of touches) {
      touchesInScreenCoordinates.push(this._getScreenCoordinatesSingle(touch));
    }
    return touchesInScreenCoordinates;
  }
};
var EVENT_NAMES$1 = ["touchstart", "touchend", "touchmove", "touchcancel"];
var EXPOSED_EVENTS$1 = EVENT_NAMES$1.map((eventName) => ({
  eventName,
  nativeEventName: void 0,
  useWindow: false,
  preventDefault: true
}));
var sliceOffTouch = (str) => str.slice(5, str.length);
function getTouches(nativeEvent) {
  return nativeEvent.touches;
}
var EventManager = class {
  constructor() {
    if (primaryInput === "mouse") {
      this._mouseEventManager = new MouseEventManager();
    }
    if (primaryInput === "touch") {
      this._touchEventManager = new TouchEventManager();
    }
  }
  // Initialization
  addRootNode(domNode, type, w3) {
    this._forEachManager((manager) => {
      manager.addRootNode(domNode, type);
    });
    initWindow(w3);
  }
  attachEventListeners() {
    this._forEachManager((manager) => {
      manager.attachEventListeners();
    });
  }
  mouse() {
    return this._mouseEventManager;
  }
  touch() {
    return this._touchEventManager;
  }
  _forEachManager(callback) {
    if (this._mouseEventManager)
      callback(this._mouseEventManager);
    if (this._touchEventManager)
      callback(this._touchEventManager);
  }
};
var BaseInteractionManager = class {
  constructor() {
    this._id = void 0;
    this._eventManager = void 0;
    this._section = void 0;
    this._markInteractionInterface = void 0;
    this._sectionInteractionInterface = void 0;
  }
  // Initialization
  setId(id) {
    this._id = id;
  }
  linkEventManager(eventManager) {
    this._eventManager = eventManager;
  }
  // Section context loading
  loadSection(sectionData) {
    this._section = sectionData;
  }
  // Mark and layer interactions interface
  marks() {
    return this._markInteractionInterface;
  }
  // Section interactions interface
  section() {
    return this._sectionInteractionInterface;
  }
};
var BaseInteractionInterface = class {
  constructor(interactionManager, InteractionHandlers) {
    this._interactionManager = interactionManager;
    this._handlers = {};
    for (const handlerName in InteractionHandlers) {
      this._handlers[handlerName] = new InteractionHandlers[handlerName](this._interactionManager);
    }
  }
  _getHandler(interactionName) {
    const handlerName = interactionNameToHandlerName(interactionName);
    return this._handlers[handlerName];
  }
};
var interactionNameToHandlerName = (interactionName) => {
  return capitalize(interactionName) + "Handler";
};
var PI = Math.PI;
var HALF_PI = Math.PI / 2;
var TWO_PI = Math.PI * 2;
function getArcBbox(cx, cy, radius, _startAngle, _endAngle, counterclockwise) {
  if (_startAngle === 0 && _endAngle === TWO_PI) {
    return {
      minX: cx - radius,
      maxX: cx + radius,
      minY: cy - radius,
      maxY: cy + radius
    };
  }
  let startAngle = _startAngle;
  let endAngle = _endAngle;
  if (counterclockwise) {
    startAngle = _endAngle;
    endAngle = _startAngle;
  }
  const iniQuad = getQuadrant(startAngle);
  const endQuad = getQuadrant(endAngle);
  const ix = Math.cos(startAngle) * radius;
  const iy = Math.sin(startAngle) * radius;
  const ex = Math.cos(endAngle) * radius;
  const ey = Math.sin(endAngle) * radius;
  const minX = Math.min(ix, ex);
  const minY = Math.min(iy, ey);
  const maxX = Math.max(ix, ex);
  const maxY = Math.max(iy, ey);
  const r2 = radius;
  const xMax = [[maxX, r2, r2, r2], [maxX, maxX, r2, r2], [maxX, maxX, maxX, r2], [maxX, maxX, maxX, maxX]];
  const yMax = [[maxY, maxY, maxY, maxY], [r2, maxY, r2, r2], [r2, maxY, maxY, r2], [r2, maxY, maxY, maxY]];
  const xMin = [[minX, -r2, minX, minX], [minX, minX, minX, minX], [-r2, -r2, minX, -r2], [-r2, -r2, minX, minX]];
  const yMin = [[minY, -r2, -r2, minY], [minY, minY, -r2, minY], [minY, minY, minY, minY], [-r2, -r2, -r2, minY]];
  const x1 = xMin[endQuad][iniQuad];
  const y1 = yMin[endQuad][iniQuad];
  const x23 = xMax[endQuad][iniQuad];
  const y23 = yMax[endQuad][iniQuad];
  return {
    minX: x1 + cx,
    maxX: x23 + cx,
    minY: y1 + cy,
    maxY: y23 + cy
  };
}
function getQuadrant(_angle) {
  const angle = _angle % TWO_PI;
  if (angle > 0 && angle < HALF_PI)
    return 0;
  if (angle >= HALF_PI && angle < PI)
    return 1;
  if (angle >= PI && angle < PI + HALF_PI)
    return 2;
  return 3;
}
function applyLWAndClipping(bbox, props, section) {
  const useLineWidth = props.stroke && props.stroke !== "none";
  if (useLineWidth) {
    applyMargin(bbox, props.strokeWidth / 2);
  }
  const clipBbox = getClipBbox(props, section);
  applyClip(bbox, clipBbox);
  return bbox;
}
function applyMargin(bbox, margin) {
  bbox.minX -= margin;
  bbox.maxX += margin;
  bbox.minY -= margin;
  bbox.maxY += margin;
}
function applyClip(bbox, clipBbox) {
  bbox.minX = clamp(bbox.minX, clipBbox.minX, clipBbox.maxX);
  bbox.maxX = clamp(bbox.maxX, clipBbox.minX, clipBbox.maxX);
  bbox.minY = clamp(bbox.minY, clipBbox.minY, clipBbox.maxY);
  bbox.maxY = clamp(bbox.maxY, clipBbox.minY, clipBbox.maxY);
}
var clamp = (n2, min2, max2) => Math.min(Math.max(n2, min2), max2);
function bboxPoint(mark) {
  const { positioning, props, section } = mark;
  return [getBbox(positioning, props, section)];
}
function bboxPointLayer(layer) {
  const layerBboxes = [];
  const { props, section } = layer;
  const getAesthetics = batchAestheticGetter(props, ["stroke", "strokeWidth"], props.keys);
  for (let i2 = 0; i2 < layer.positioning.length; i2++) {
    const bbox = getBbox(
      layer.positioning[i2],
      getAesthetics(i2),
      section
    );
    bbox.index = i2;
    layerBboxes.push(bbox);
  }
  return layerBboxes;
}
function getBbox(positioning, props, section) {
  for (let i2 = 0; i2 < positioning.call.length; i2++) {
    if (positioning.call[i2] === "arc") {
      const bbox = getArcBbox.apply(null, positioning.args[i2]);
      return applyLWAndClipping(
        bbox,
        props,
        section
      );
    }
  }
}
function attach(bboxes, stuffToAttach) {
  for (let i2 = 0; i2 < bboxes.length; i2++) {
    const bbox = bboxes[i2];
    for (const stuffKey in stuffToAttach) {
      bbox[stuffKey] = stuffToAttach[stuffKey];
    }
  }
}
function attachWithKeys(bboxes, stuffToAttach, keys) {
  for (let i2 = 0; i2 < bboxes.length; i2++) {
    const bbox = bboxes[i2];
    for (const stuffKey in stuffToAttach) {
      bbox[stuffKey] = stuffToAttach[stuffKey];
    }
    bbox.key = keys[bbox.index];
  }
}
function indexPoint(mark) {
  const bboxes = bboxPoint(mark);
  attach(bboxes, { data: mark });
  return bboxes;
}
function indexPointLayer(layer) {
  const bboxes = bboxPointLayer(layer);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function getBbox$1(x0, x1, y0, y1) {
  return {
    minX: Math.min(x0, x1),
    maxX: Math.max(x0, x1),
    minY: Math.min(y0, y1),
    maxY: Math.max(y0, y1)
  };
}
function evalQuadratic(p0, p1, p2, t2) {
  return (1 - t2) * (1 - t2) * p0 + 2 * (1 - t2) * t2 * p1 + t2 * t2 * p2;
}
function evalCubic(p0, p1, p2, p3, t2) {
  return p0 * (1 - t2) * (1 - t2) * (1 - t2) + 3 * p1 * t2 * (1 - t2) * (1 - t2) + 3 * p2 * t2 * t2 * (1 - t2) + p3 * t2 * t2 * t2;
}
function getBezierBbox(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
  let a3 = 3 * p3x - 9 * p2x + 9 * p1x - 3 * p0x;
  let b2 = 6 * p0x - 12 * p1x + 6 * p2x;
  let c2 = 3 * p1x - 3 * p0x;
  let disc = b2 * b2 - 4 * a3 * c2;
  let xl = p0x;
  let xh = p0x;
  if (p3x < xl)
    xl = p3x;
  if (p3x > xh)
    xh = p3x;
  if (disc >= 0) {
    const t12 = (-b2 + Math.sqrt(disc)) / (2 * a3);
    if (t12 > 0 && t12 < 1) {
      const x1 = evalCubic(p0x, p1x, p2x, p3x, t12);
      if (x1 < xl)
        xl = x1;
      if (x1 > xh)
        xh = x1;
    }
    const t2 = (-b2 - Math.sqrt(disc)) / (2 * a3);
    if (t2 > 0 && t2 < 1) {
      const x23 = evalCubic(p0x, p1x, p2x, p3x, t2);
      if (x23 < xl)
        xl = x23;
      if (x23 > xh)
        xh = x23;
    }
  }
  a3 = 3 * p3y - 9 * p2y + 9 * p1y - 3 * p0y;
  b2 = 6 * p0y - 12 * p1y + 6 * p2y;
  c2 = 3 * p1y - 3 * p0y;
  disc = b2 * b2 - 4 * a3 * c2;
  let yl = p0y;
  let yh = p0y;
  if (p3y < yl)
    yl = p3y;
  if (p3y > yh)
    yh = p3y;
  if (disc >= 0) {
    const t12 = (-b2 + Math.sqrt(disc)) / (2 * a3);
    if (t12 > 0 && t12 < 1) {
      const y1 = evalCubic(p0y, p1y, p2y, p3y, t12);
      if (y1 < yl)
        yl = y1;
      if (y1 > yh)
        yh = y1;
    }
    const t2 = (-b2 - Math.sqrt(disc)) / (2 * a3);
    if (t2 > 0 && t2 < 1) {
      const y23 = evalCubic(p0y, p1y, p2y, p3y, t2);
      if (y23 < yl)
        yl = y23;
      if (y23 > yh)
        yh = y23;
    }
  }
  return getBbox$1(xl, xh, yl, yh);
}
function quadraticToCubic(x1, y1, cpx, cpy, x23, y23) {
  return [
    x1 / 3 + 2 / 3 * cpx,
    y1 / 3 + 2 / 3 * cpy,
    x23 / 3 + 2 / 3 * cpx,
    y23 / 3 + 2 / 3 * cpy,
    x23,
    y23
  ];
}
function getQuadraticBbox(x0, y0, x1, y1, x23, y23) {
  return getBezierBbox.apply(
    null,
    quadraticToCubic(x0, y0, x1, y1, x23, y23)
  );
}
function getEllipseBbox(x3, y3, rx, ry, rot, a0, a1, ccw) {
  if (rot !== 0)
    throw Error("Rotation not supported yet");
  const dimRatio = rx / ry;
  const r2 = dimRatio > 1 ? rx : ry;
  const bbox = getArcBbox(x3, y3, r2, a0, a1, ccw);
  rescaleBbox(bbox, dimRatio);
  return bbox;
}
function getEllipseEndCoords(x3, y3, rx, ry, rot, a0, a1) {
  const endX = Math.cos(a1) * rx;
  const endY = Math.sin(a1) * ry;
  return [x3 + endX, y3 + endY];
}
function rescaleBbox(bbox, dimRatio) {
  if (dimRatio < 1) {
    const cx = (bbox.minX + bbox.maxX) / 2;
    const dxMin = cx - bbox.minX;
    const dxMax = bbox.maxX - cx;
    bbox.minX = cx - dxMin * dimRatio;
    bbox.maxX = cx + dxMax * dimRatio;
  }
  if (dimRatio > 1) {
    const cy = (bbox.minY + bbox.maxY) / 2;
    const dyMin = cy - bbox.minY;
    const dyMax = bbox.maxY - cy;
    bbox.minY = cy - dyMin / dimRatio;
    bbox.maxY = cy + dyMax / dimRatio;
  }
}
function updateBbox(bbox, x3, y3) {
  bbox.minX = x3 < bbox.minX ? x3 : bbox.minX;
  bbox.maxX = x3 > bbox.maxX ? x3 : bbox.maxX;
  bbox.minY = y3 < bbox.minY ? y3 : bbox.minY;
  bbox.maxY = y3 > bbox.maxY ? y3 : bbox.maxY;
}
function updateBboxWithBbox(bbox, { minX, maxX, minY, maxY }) {
  bbox.minX = minX < bbox.minX ? minX : bbox.minX;
  bbox.maxX = maxX > bbox.maxX ? maxX : bbox.maxX;
  bbox.minY = minY < bbox.minY ? minY : bbox.minY;
  bbox.maxY = maxY > bbox.maxY ? maxY : bbox.maxY;
}
function bboxPolygon(mark) {
  const bboxes = [];
  const { positioning, props, section } = mark;
  const submarks = positioning.submarks.length ? positioning.submarks : [0];
  for (let i2 = 0; i2 < submarks.length; i2++) {
    const submarkStart = submarks[i2];
    const submarkEnd = submarks[i2 + 1] || positioning.call.length;
    bboxes.push(getBboxOfRange(
      positioning,
      props,
      section,
      submarkStart,
      submarkEnd
    ));
  }
  return bboxes;
}
function bboxPolygonLayer(layer) {
  const layerBboxes = [];
  const { props, section } = layer;
  const getAesthetics = batchAestheticGetter(props, ["stroke", "strokeWidth"], props.keys);
  for (let i2 = 0; i2 < layer.positioning.length; i2++) {
    const positioning = layer.positioning[i2];
    const submarks = positioning.submarks.length ? positioning.submarks : [0];
    for (let j2 = 0; j2 < submarks.length; j2++) {
      const submarkStart = submarks[j2];
      const submarkEnd = submarks[j2 + 1] || positioning.call.length;
      const bbox = getBboxOfRange(
        positioning,
        getAesthetics(i2),
        section,
        submarkStart,
        submarkEnd
      );
      bbox.index = i2;
      layerBboxes.push(bbox);
    }
  }
  return layerBboxes;
}
function getBboxOfRange(positioning, props, section, start, end) {
  const bbox = {
    minX: Infinity,
    maxX: -Infinity,
    minY: Infinity,
    maxY: -Infinity
  };
  let numberOfMoveTos = 0;
  let lastX;
  let lastY;
  for (let i2 = start; i2 < end; i2++) {
    const call = positioning.call[i2];
    const args = positioning.args[i2];
    switch (call) {
      case "moveTo":
        numberOfMoveTos++;
        if (numberOfMoveTos === 2) {
          return applyLWAndClipping(
            bbox,
            props,
            section
          );
        }
        lastX = args[0];
        lastY = args[1];
        break;
      case "lineTo":
        updateBbox(bbox, lastX, lastY);
        lastX = args[0];
        lastY = args[1];
        updateBbox(bbox, lastX, lastY);
        break;
      case "quadraticCurveTo":
        updateBboxWithBbox(
          bbox,
          getQuadraticBbox(lastX, lastY, ...args)
        );
        lastX = args[2];
        lastY = args[3];
        break;
      case "bezierCurveTo":
        updateBboxWithBbox(
          bbox,
          getBezierBbox(lastX, lastY, ...args)
        );
        lastX = args[4];
        lastY = args[5];
        break;
      case "ellipse":
        updateBboxWithBbox(
          bbox,
          getEllipseBbox.apply(null, args)
        );
        const endCoords = getEllipseEndCoords.apply(null, args);
        lastX = endCoords[0];
        lastY = endCoords[1];
        break;
    }
  }
  return applyLWAndClipping(
    bbox,
    props,
    section
  );
}
function indexRectangle(mark) {
  const bboxes = bboxPolygon(mark);
  attach(bboxes, { data: mark });
  return bboxes;
}
function indexRectangleLayer(layer) {
  const bboxes = bboxPolygonLayer(layer);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function indexPolygon(mark) {
  const bboxes = bboxPolygon(mark);
  attach(bboxes, { data: mark });
  return bboxes;
}
function indexPolygonLayer(layer) {
  const bboxes = bboxPolygonLayer(layer);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function bboxLabel(mark) {
  const { positioning, props, section } = mark;
  return [getBbox$2(positioning, props, section)];
}
function bboxLabelLayer(layer) {
  const layerBboxes = [];
  const { props, section } = layer;
  const getAesthetics = batchAestheticGetter(
    props,
    ["text", "fontSize", "rotate", "anchorPoint", "stroke", "strokeWidth"],
    props.keys
  );
  for (let i2 = 0; i2 < layer.positioning.length; i2++) {
    const bbox = getBbox$2(
      layer.positioning[i2],
      getAesthetics(i2),
      section
    );
    bbox.index = i2;
    layerBboxes.push(bbox);
  }
  return layerBboxes;
}
function getBbox$2(positioning, props, section) {
  const ctx2 = getCtx();
  ctx2.save();
  const width = ctx2.measureText(props.text).width;
  const height = props.fontSize;
  const [x0, y0] = getXY0(props, width, height);
  const x1 = x0 + width;
  const y1 = y0 + height;
  const bboxAround0Points = [
    [x0, y0],
    [x1, y0],
    [x1, y1],
    [x0, y1]
  ];
  ctx2.translate.apply(ctx2, positioning.args[0]);
  ctx2.rotate(props.rotate);
  const transformation = ctx2.getTransform ? ctx2.getTransform() : ctx2.currentTransform;
  const rotatedPoints = bboxAround0Points.map(([x3, y3]) => {
    const rotatedPoint = transformation.transformPoint({ x: x3, y: y3 });
    return [rotatedPoint.x, rotatedPoint.y];
  });
  ctx2.restore();
  const bboxRotatedPoints = getBboxPoints(rotatedPoints);
  const bbox = applyLWAndClipping(bboxRotatedPoints, props, section);
  bbox.rotatedBbox = rotatedPoints;
  return bbox;
}
function getXY0({ anchorPoint }, w3, h2) {
  const x3 = anchorPoint.startsWith("l") ? 0 : anchorPoint.startsWith("r") ? -w3 : -w3 / 2;
  const y3 = anchorPoint.endsWith("t") ? 0 : anchorPoint.endsWith("b") ? -h2 : -h2 / 2;
  return [x3, y3];
}
function getBboxPoints(points) {
  const bbox = {
    minX: Infinity,
    maxX: -Infinity,
    minY: Infinity,
    maxY: -Infinity
  };
  for (let i2 = 0; i2 < points.length; i2++) {
    const [x3, y3] = points[i2];
    updateBbox(bbox, x3, y3);
  }
  return bbox;
}
function indexLabel(mark) {
  const bboxes = bboxLabel(mark);
  attach(bboxes, { data: mark });
  return bboxes;
}
function indexLabelLayer(layer) {
  const bboxes = bboxLabelLayer(layer);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function bboxLine(mark) {
  const { positioning, props, section } = mark;
  return getBboxes(positioning, props, section);
}
function bboxLineLayer(layer) {
  const layerBboxes = [];
  const { props, section } = layer;
  const getAesthetics = batchAestheticGetter(props, ["stroke", "strokeWidth"], props.keys);
  for (let i2 = 0; i2 < layer.positioning.length; i2++) {
    const bboxes = getBboxes(
      layer.positioning[i2],
      getAesthetics(i2),
      section
    );
    for (let j2 = 0; j2 < bboxes.length; j2++) {
      bboxes[j2].index = i2;
      layerBboxes.push(bboxes[j2]);
    }
  }
  return layerBboxes;
}
function getBboxes(positioning, props, section) {
  const bboxes = [];
  let lastX;
  let lastY;
  let bbox;
  for (let i2 = 0; i2 < positioning.call.length; i2++) {
    const call = positioning.call[i2];
    const args = positioning.args[i2];
    switch (call) {
      case "moveTo":
        lastX = args[0];
        lastY = args[1];
        break;
      case "lineTo":
        bbox = applyLWAndClipping(
          getBbox$1(lastX, args[0], lastY, args[1]),
          props,
          section
        );
        bbox.segment = i2;
        bboxes.push(bbox);
        lastX = args[0];
        lastY = args[1];
        break;
      case "quadraticCurveTo":
        bbox = applyLWAndClipping(
          getQuadraticBbox(lastX, lastY, ...args),
          props,
          section
        );
        bbox.segment = i2;
        bboxes.push(bbox);
        lastX = args[2];
        lastY = args[3];
        break;
      case "bezierCurveTo":
        bbox = applyLWAndClipping(
          getBezierBbox(lastX, lastY, ...args),
          props,
          section
        );
        bbox.segment = i2;
        bboxes.push(bbox);
        lastX = args[4];
        lastY = args[5];
        break;
    }
  }
  return bboxes;
}
function indexLine(mark) {
  const bboxes = bboxLine(mark);
  attach(bboxes, { data: mark });
  return bboxes;
}
function indexLineLayer(layer) {
  const bboxes = bboxLineLayer(layer);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function indexArea(mark) {
  const bboxes = bboxPolygon(mark);
  attach(bboxes, { data: mark });
  return bboxes;
}
function indexAreaLayer(layer) {
  const bboxes = bboxPolygonLayer(layer);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function indexSymbol(mark) {
  const bboxes = bboxPolygon(mark);
  attach(bboxes, { data: mark });
  return bboxes;
}
function indexSymbolLayer(layer) {
  const bboxes = bboxPolygonLayer(layer);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
var markIndexing = {
  Point: indexPoint,
  Rectangle: indexRectangle,
  Polygon: indexPolygon,
  Line: indexLine,
  Area: indexArea,
  Symbol: indexSymbol,
  Label: indexLabel,
  FuncLine: indexLine
};
var layerIndexing = {
  Point: indexPointLayer,
  Rectangle: indexRectangleLayer,
  Polygon: indexPolygonLayer,
  Line: indexLineLayer,
  Label: indexLabelLayer,
  Area: indexAreaLayer,
  Symbol: indexSymbolLayer
};
var MarkInteractionInterface = class extends BaseInteractionInterface {
  constructor(interactionManager, InteractionHandlers) {
    super(interactionManager, InteractionHandlers);
    this._indexableMarks = {};
    this._indexableLayers = {};
  }
  // Mark loading and removing
  loadMark(mark) {
    const indexingFunction = markIndexing[mark.type];
    const indexableMark = indexingFunction(mark);
    const markId2 = mark.id;
    this._indexableMarks[markId2] = indexableMark;
  }
  markIsLoaded({ id }) {
    return id in this._indexableMarks;
  }
  removeMark({ id }) {
    delete this._indexableMarks[id];
  }
  // Layer loading and removing
  loadLayer(layer) {
    const indexingFunction = layerIndexing[layer.type];
    const indexableLayer = indexingFunction(layer);
    const layerId2 = layer.id;
    this._indexableLayers[layerId2] = indexableLayer;
  }
  layerIsLoaded({ id }) {
    return id in this._indexableLayers;
  }
  removeLayer({ id }) {
    delete this._indexableLayers[id];
  }
  // Add/remove mark interactions
  addMarkInteraction(interactionName, { id }, callback) {
    this._getHandler(interactionName).addMarkInteraction(id, callback);
  }
  removeAllMarkInteractions({ id }) {
    for (const handlerName in this._handlers) {
      const handler2 = this._handlers[handlerName];
      if (handler2.hasMark(id)) {
        handler2.removeMarkInteraction(id);
      }
    }
  }
  // Add/remove layer interactions
  addLayerInteraction(interactionName, { id }, callback) {
    this._getHandler(interactionName).addLayerInteraction(id, callback);
  }
  removeAllLayerInteractions({ id }) {
    for (const handlerName in this._handlers) {
      const handler2 = this._handlers[handlerName];
      if (handler2.hasLayer(id)) {
        handler2.removeLayerInteraction(id);
      }
    }
  }
};
var SectionInteractionInterface = class extends BaseInteractionInterface {
  addInteraction(interactionName, callback) {
    this._getHandler(interactionName).addInteraction(callback);
  }
  removeAllInteractions() {
    for (const handlerName in this._handlers) {
      const handler2 = this._handlers[handlerName];
      if (handler2.hasInteraction()) {
        handler2.removeInteraction();
      }
    }
  }
};
var BaseInteractionHandler = class {
  constructor(interactionManager, { eventName, interactionName }) {
    this._interactionManager = interactionManager;
    this._eventName = eventName;
    this._interactionName = interactionName;
  }
  interactionManager() {
    return this._interactionManager;
  }
  eventManager() {
    return this._interactionManager._eventManager;
  }
  section() {
    return this._interactionManager._section;
  }
  id() {
    return this._interactionManager._id;
  }
  _addEventListener() {
    const handler2 = this._handleEvent.bind(this);
    const eventManager = this.eventManager();
    const listenerId = this.getId();
    const events = isArray(this._eventName) ? this._eventName : [this._eventName];
    for (const event of events) {
      eventManager.eventTracker(event).addListener(listenerId, handler2);
    }
  }
  _removeEventListener() {
    const eventManager = this.eventManager();
    const listenerId = this.getId();
    const events = isArray(this._eventName) ? this._eventName : [this._eventName];
    for (const event of events) {
      eventManager.eventTracker(event).removeListener(listenerId);
    }
  }
};
function isArray(value) {
  return value.constructor === Array;
}
var MarkInteractionHandler = class extends BaseInteractionHandler {
  constructor(interactionManager, options2) {
    super(interactionManager, options2);
    const getMark = function(markId2) {
      return this._interactionManager.marks()._indexableMarks[markId2];
    };
    const getLayer = function(layerId2) {
      return this._interactionManager.marks()._indexableLayers[layerId2];
    };
    this._spatialIndex = new SpatialIndex(this, getMark, getLayer);
    this._numberOfInteractions = 0;
    this._markCallbacks = {};
    this._layerCallbacks = {};
  }
  // Add/remove mark interactions
  addMarkInteraction(markId2, callback) {
    this._addEventListenerIfNecessary();
    this._numberOfInteractions++;
    this._markCallbacks[markId2] = callback;
    this._spatialIndex.indexMark(markId2);
  }
  hasMark(markId2) {
    return markId2 in this._markCallbacks;
  }
  removeMarkInteraction(markId2) {
    this._removeEventListenerIfNecessary();
    delete this._markCallbacks[markId2];
    this._numberOfInteractions--;
    this._spatialIndex.unindexMark(markId2);
  }
  // Add/remove layer interactions
  addLayerInteraction(layerId2, callback) {
    if (!(layerId2 in this._layerCallbacks)) {
      this._addEventListenerIfNecessary();
      this._numberOfInteractions++;
      this._layerCallbacks[layerId2] = callback;
      this._spatialIndex.indexLayer(layerId2);
    }
  }
  hasLayer(layerId2) {
    return layerId2 in this._layerCallbacks;
  }
  removeLayerInteraction(layerId2) {
    if (layerId2 in this._layerCallbacks) {
      this._numberOfInteractions--;
      delete this._layerCallbacks[layerId2];
      this._removeEventListenerIfNecessary();
      this._spatialIndex.unindexLayer(layerId2);
    }
  }
  _addEventListenerIfNecessary() {
    if (this._numberOfInteractions === 0) {
      this._addEventListener();
    }
  }
  _removeEventListenerIfNecessary() {
    if (this._numberOfInteractions === 0) {
      this._removeEventListener();
    }
  }
  getId() {
    return `${this.id()}-mark-${this._interactionName}`;
  }
};
function createMarkEvent(eventType, eventOptions, hit, nativeEvent) {
  eventOptions.markType = hit.data.type;
  eventOptions.hitBbox = extractBbox(hit);
  eventOptions.hitSource = "mark";
  return createEvent(eventType, eventOptions, nativeEvent);
}
function createLayerEvent(eventType, eventOptions, hit, nativeEvent) {
  eventOptions.markType = hit.data.type;
  eventOptions.hitBbox = extractBbox(hit);
  eventOptions.key = hit.key;
  eventOptions.index = hit.index;
  eventOptions.hitSource = "layer";
  return createEvent(eventType, eventOptions, nativeEvent);
}
function createSectionEvent(eventType, eventOptions, nativeEvent) {
  eventOptions.hitSource = "section";
  return createEvent(eventType, eventOptions, nativeEvent);
}
function extractBbox(hit) {
  return { minX: hit.minX, maxX: hit.maxX, minY: hit.minY, maxY: hit.maxY };
}
function createEvent(eventType, eventOptions, nativeEvent) {
  const event = eventOptions;
  event.type = eventType;
  event.nativeType = nativeEvent.type;
  for (const key of INTERESTING_NATIVE_KEYS) {
    event[key] = nativeEvent[key];
  }
  return event;
}
var INTERESTING_NATIVE_KEYS = [
  "altKey",
  "ctrlKey",
  "shiftKey",
  "clientX",
  "clientY",
  "pageX",
  "pageY",
  "screenX",
  "screenY",
  "timeStamp"
];
function createSelectMarkEvent(eventType, hit) {
  const event = {
    type: eventType,
    markType: hit.data.type,
    hitSource: "mark"
  };
  return event;
}
function createSelectLayerEvent(eventType, hit) {
  const event = {
    type: eventType,
    markType: hit.data.type,
    key: hit.key,
    index: hit.index,
    hitSource: "layer"
  };
  return event;
}
function getLocalCoordinates(screenCoordinates, interactionManager) {
  const section = interactionManager._section;
  const inverseTotalTransformation = section.inverseTotalTransformation;
  const { minX, maxX, minY, maxY } = section.paddedBbox;
  const clampedX = clamp$1(screenCoordinates.x, minX, maxX);
  const clampedY = clamp$1(screenCoordinates.y, minY, maxY);
  const [localX, localY] = inverseTotalTransformation([clampedX, clampedY]);
  return { x: localX, y: localY };
}
function clamp$1(value, min2, max2) {
  return Math.max(min2, Math.min(value, max2));
}
var currentId$1 = 0;
function getId$1() {
  return "l" + currentId$1++;
}
var Layer = class {
  constructor(positioning, props, section, styler, type) {
    this.positioning = positioning;
    this.props = props;
    this.section = section;
    this.styler = styler;
    this.type = type;
    this.id = getId$1();
  }
  /**
   * Render layer to context.
   * @param {Object} context A 2d canvas context, or some other rendervous context.
   */
  render(context) {
    context.save();
    hasStartAndEndCalls(context) ? this._renderWithStartAndEndCalls(context) : this._render(context);
    context.restore();
  }
  /**
   * Updates non-positioning props / aesthetics.
   * @param {Object} aesthetics An object containing the updated values
   */
  updateAesthetics(aesthetics) {
    for (const aestheticName in aesthetics) {
      this.props[aestheticName] = aesthetics[aestheticName];
    }
  }
  // Internal
  _renderWithStartAndEndCalls(context) {
    context.layerStart();
    const clip = getClip(this.props, this.section);
    applyClipping(context, clip);
    const asOnePath = this.styler.asOnePath(this.props);
    const applyStyling2 = this.styler.create(this.props);
    if (asOnePath) {
      context.markStart();
      for (let i2 = 0; i2 < this.positioning.length; i2++) {
        applyPositioning(context, this.positioning[i2]);
      }
      applyStyling2(context);
      context.markEnd();
    }
    if (!asOnePath) {
      for (let i2 = 0; i2 < this.positioning.length; i2++) {
        context.markStart();
        applyPositioning(context, this.positioning[i2]);
        applyStyling2(context, i2);
        context.markEnd();
      }
    }
    context.layerEnd();
  }
  _render(context) {
    const clip = getClip(this.props, this.section);
    applyClipping(context, clip);
    const asOnePath = this.styler.asOnePath(this.props);
    const applyStyling2 = this.styler.create(this.props);
    if (asOnePath) {
      context.beginPath();
      for (let i2 = 0; i2 < this.positioning.length; i2++) {
        applyPositioning(context, this.positioning[i2]);
      }
      applyStyling2(context);
    }
    if (!asOnePath) {
      for (let i2 = 0; i2 < this.positioning.length; i2++) {
        context.beginPath();
        applyPositioning(context, this.positioning[i2]);
        applyStyling2(context, i2);
      }
    }
  }
};
function coordinatesAreInsideSection({ x: x3, y: y3 }, section) {
  const bbox = section.bbox;
  return x3 >= bbox.minX && x3 <= bbox.maxX && y3 >= bbox.minY && y3 <= bbox.maxY;
}
function hitIsMark(hit) {
  return hit.data.constructor === Mark;
}
function hitIsInLayer(hit) {
  return hit.data.constructor === Layer;
}
function getHitId(hit) {
  if (hitIsMark(hit))
    return hit.data.id;
  if (hitIsInLayer(hit))
    return hit.data.id + "-" + hit.index;
}
var ClickHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "click",
      eventName: "click"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      if (hitIsMark(hit)) {
        const clickEvent = createMarkEvent("click", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._markCallbacks[hit.data.id](clickEvent);
      }
      if (hitIsInLayer(hit)) {
        const clickEvent = createLayerEvent("click", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._layerCallbacks[hit.data.id](clickEvent);
      }
    }
  }
};
var MouseoverHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mouseover",
      eventName: "mousemove"
    });
    this._previousMouseoverIds = {};
    this._currentMouseoverIds = {};
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._currentMouseoverIds[hitId] = true;
      if (!(hitId in this._previousMouseoverIds)) {
        this._fireCallback(hit, screenCoordinates, nativeEvent);
      }
    }
    this._previousMouseoverIds = this._currentMouseoverIds;
    this._currentMouseoverIds = {};
  }
  _fireCallback(hit, screenCoordinates, nativeEvent) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    if (hitIsMark(hit)) {
      const mouseoverEvent = createMarkEvent("mouseover", {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);
      this._markCallbacks[hit.data.id](mouseoverEvent);
    }
    if (hitIsInLayer(hit)) {
      const mouseoverEvent = createLayerEvent("mouseover", {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);
      this._layerCallbacks[hit.data.id](mouseoverEvent);
    }
  }
};
var MouseoutHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mouseout",
      eventName: "mousemove"
    });
    this._previousMouseoverHits = {};
    this._currentMouseoverHits = {};
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._currentMouseoverHits[hitId] = hit;
    }
    for (const hitId in this._previousMouseoverHits) {
      if (!(hitId in this._currentMouseoverHits)) {
        const hit = this._previousMouseoverHits[hitId];
        this._fireCallback(hit, screenCoordinates, nativeEvent);
      }
    }
    this._previousMouseoverHits = this._currentMouseoverHits;
    this._currentMouseoverHits = {};
  }
  _fireCallback(hit, screenCoordinates, nativeEvent) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    if (hitIsMark(hit)) {
      const mouseoutEvent = createMarkEvent("mouseout", {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);
      this._markCallbacks[hit.data.id](mouseoutEvent);
    }
    if (hitIsInLayer(hit)) {
      const mouseoutEvent = createLayerEvent("mouseout", {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);
      this._layerCallbacks[hit.data.id](mouseoutEvent);
    }
  }
};
var MousedownHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mousedown",
      eventName: "mousedown"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      if (hitIsMark(hit)) {
        const mousedownEvent = createMarkEvent("mousedown", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._markCallbacks[hit.data.id](mousedownEvent);
      }
      if (hitIsInLayer(hit)) {
        const mousedownEvent = createLayerEvent("mousedown", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._layerCallbacks[hit.data.id](mousedownEvent);
      }
    }
  }
};
var MouseupHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mouseup",
      eventName: "mouseup"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      if (hitIsMark(hit)) {
        const mouseupEvent = createMarkEvent("mouseup", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._markCallbacks[hit.data.id](mouseupEvent);
      }
      if (hitIsInLayer(hit)) {
        const mouseupEvent = createLayerEvent("mouseup", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._layerCallbacks[hit.data.id](mouseupEvent);
      }
    }
  }
};
var MousedragHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mousedrag",
      eventName: ["mousedown", "mousemove", "mouseup"]
    });
    this._currentHits = {};
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (nativeEvent.eventName === "mousedown") {
      this._handleMousedown(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "mousemove") {
      this._handleMousemove(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "mouseup") {
      this._handleMouseup(screenCoordinates, nativeEvent);
    }
  }
  _handleMousedown(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._currentHits[hitId] = hit;
      this._fireCallback(hit, screenCoordinates, nativeEvent, "start");
    }
  }
  _handleMousemove(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    for (const hitId in this._currentHits) {
      const hit = this._currentHits[hitId];
      this._fireCallback(hit, screenCoordinates, nativeEvent, "drag");
    }
  }
  _handleMouseup(screenCoordinates, nativeEvent) {
    for (const hitId in this._currentHits) {
      const hit = this._currentHits[hitId];
      this._fireCallback(hit, screenCoordinates, nativeEvent, "end");
    }
    this._currentHits = {};
  }
  _fireCallback(hit, screenCoordinates, nativeEvent, dragType) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    if (hitIsMark(hit)) {
      const mousedragEvent = createMarkEvent("mousedrag", {
        screenCoordinates,
        localCoordinates,
        dragType
      }, hit, nativeEvent);
      this._markCallbacks[hit.data.id](mousedragEvent);
    }
    if (hitIsInLayer(hit)) {
      const mousedragEvent = createLayerEvent("mousedrag", {
        screenCoordinates,
        localCoordinates,
        dragType
      }, hit, nativeEvent);
      this._layerCallbacks[hit.data.id](mousedragEvent);
    }
  }
};
var MarkInteractionHandlers = Object.freeze({
  __proto__: null,
  ClickHandler,
  MouseoverHandler,
  MouseoutHandler,
  MousedownHandler,
  MouseupHandler,
  MousedragHandler
});
var SectionInteractionHandler = class extends BaseInteractionHandler {
  constructor(interactionManager, options2) {
    super(interactionManager, options2);
    this._callback = void 0;
  }
  addInteraction(callback) {
    this._addEventListener();
    this._callback = callback;
  }
  hasInteraction() {
    return this._callback !== void 0;
  }
  removeInteraction() {
    if (this._callback) {
      this._callback = void 0;
      this._removeEventListener();
    }
  }
  getId() {
    return `${this.id()}-section-${this._interactionName}`;
  }
};
function getScrollLineHeight() {
  var r2;
  var iframe = document.createElement("iframe");
  iframe.src = "#";
  document.body.appendChild(iframe);
  var iwin = iframe.contentWindow;
  var idoc = iwin.document;
  idoc.open();
  idoc.write("<!DOCTYPE html><html><head></head><body><span>a</span></body></html>");
  idoc.close();
  var span = idoc.body.firstElementChild;
  r2 = span.offsetHeight;
  document.body.removeChild(iframe);
  return r2;
}
var WheelHandler = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "wheel",
      eventName: "wheel"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    nativeEvent.preventDefault();
    nativeEvent.stopPropagation();
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
      const delta = getDelta(nativeEvent);
      const wheelEvent = createSectionEvent("wheel", {
        screenCoordinates,
        localCoordinates,
        delta
      }, nativeEvent);
      this._callback(wheelEvent);
    }
  }
};
var scrollLineHeight;
function getDelta(nativeEvent) {
  let delta;
  if ("wheelDelta" in nativeEvent && nativeEvent.wheelDelta !== 0) {
    delta = -nativeEvent.wheelDelta;
  }
  if ("detail" in nativeEvent && nativeEvent.detail !== 0) {
    delta = -nativeEvent.detail;
  }
  if ("deltaY" in nativeEvent && nativeEvent.deltaY !== 0) {
    delta = -nativeEvent.deltaY;
  }
  if (!scrollLineHeight) {
    scrollLineHeight = getScrollLineHeight();
  }
  return delta * (nativeEvent.deltaMode ? scrollLineHeight : 1) / 500;
}
var ClickHandler$1 = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "click",
      eventName: "click"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
      const clickEvent = createSectionEvent("click", {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);
      this._callback(clickEvent);
    }
  }
};
var MousedownHandler$1 = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mousedown",
      eventName: "mousedown"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
      const mousedownEvent = createSectionEvent("mousedown", {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);
      this._callback(mousedownEvent);
    }
  }
};
var MouseupHandler$1 = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mouseup",
      eventName: "mouseup"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
      const mouseupEvent = createSectionEvent("mouseup", {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);
      this._callback(mouseupEvent);
    }
  }
};
var MouseoverHandler$1 = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mouseover",
      eventName: "mousemove"
    });
    this._mouseCurrentlyOverSection = false;
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      if (!this._mouseCurrentlyOverSection) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
        const mousedownEvent = createSectionEvent("mouseover", {
          screenCoordinates,
          localCoordinates
        }, nativeEvent);
        this._callback(mousedownEvent);
        this._mouseCurrentlyOverSection = true;
      }
    } else {
      if (this._mouseCurrentlyOverSection) {
        this._mouseCurrentlyOverSection = false;
      }
    }
  }
};
var MouseoutHandler$1 = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mouseout",
      eventName: "mousemove"
    });
    this._mouseCurrentlyOverSection = false;
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      if (!this._mouseCurrentlyOverSection) {
        this._mouseCurrentlyOverSection = true;
      }
    } else {
      if (this._mouseCurrentlyOverSection) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
        const mouseoutEvent = createSectionEvent("mouseout", {
          screenCoordinates,
          localCoordinates
        }, nativeEvent);
        this._callback(mouseoutEvent);
        this._mouseCurrentlyOverSection = false;
      }
    }
  }
};
var MousemoveHandler = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "mouseover",
      eventName: "mousemove"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
      const mousemoveEvent = createSectionEvent("mousemove", {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);
      this._callback(mousemoveEvent);
    }
  }
};
var SectionInteractionHandlers = Object.freeze({
  __proto__: null,
  WheelHandler,
  ClickHandler: ClickHandler$1,
  MousedownHandler: MousedownHandler$1,
  MouseupHandler: MouseupHandler$1,
  MouseoverHandler: MouseoverHandler$1,
  MouseoutHandler: MouseoutHandler$1,
  MousemoveHandler
});
var MouseInteractionManager = class extends BaseInteractionManager {
  constructor() {
    super();
    this._markInteractionInterface = new MarkInteractionInterface(this, MarkInteractionHandlers);
    this._sectionInteractionInterface = new SectionInteractionInterface(this, SectionInteractionHandlers);
  }
};
function numberOfTouches(screenCoordinates) {
  if (screenCoordinates.constructor === Object)
    return 1;
  return screenCoordinates.length;
}
var TouchdownHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchdown",
      eventName: "touchstart"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      if (hitIsMark(hit)) {
        const touchdownEvent = createMarkEvent("touchdown", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._markCallbacks[hit.data.id](touchdownEvent);
      }
      if (hitIsInLayer(hit)) {
        const touchdownEvent = createLayerEvent("touchdown", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._layerCallbacks[hit.data.id](touchdownEvent);
      }
    }
  }
};
var TouchupHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchup",
      eventName: ["touchend", "touchcancel"]
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      if (hitIsMark(hit)) {
        const touchupEvent = createMarkEvent("touchup", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._markCallbacks[hit.data.id](touchupEvent);
      }
      if (hitIsInLayer(hit)) {
        const touchupEvent = createLayerEvent("touchup", {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);
        this._layerCallbacks[hit.data.id](touchupEvent);
      }
    }
  }
};
var TouchoverHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchover",
      eventName: ["touchstart", "touchmove"]
    });
    this._previousHits = {};
    this._currentHits = {};
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    if (nativeEvent.eventName === "touchstart") {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "touchmove") {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }
  }
  _handleTouchstart(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._previousHits[hitId] = true;
    }
  }
  _handleTouchmove(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._currentHits[hitId] = true;
      if (!(hitId in this._previousHits)) {
        this._fireCallback(hit, screenCoordinates, nativeEvent);
      }
    }
    this._previousHits = this._currentHits;
    this._currentHits = {};
  }
  _fireCallback(hit, screenCoordinates, nativeEvent) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    if (hitIsMark(hit)) {
      const touchoverEvent = createMarkEvent("touchover", {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);
      this._markCallbacks[hit.data.id](touchoverEvent);
    }
    if (hitIsInLayer(hit)) {
      const touchoverEvent = createLayerEvent("touchover", {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);
      this._layerCallbacks[hit.data.id](touchoverEvent);
    }
  }
};
var TouchoutHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchout",
      eventName: ["touchstart", "touchmove", "touchend"]
    });
    this._previousHits = {};
    this._currentHits = {};
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    if (nativeEvent.eventName === "touchstart") {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "touchmove") {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "touchend") {
      this._handleTouchend();
    }
  }
  _handleTouchstart(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._previousHits[hitId] = hit;
    }
  }
  _handleTouchmove(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._currentHits[hitId] = hit;
    }
    for (const hitId in this._previousHits) {
      if (!(hitId in this._currentHits)) {
        const hit = this._previousHits[hitId];
        this._fireCallback(hit, screenCoordinates, nativeEvent);
      }
    }
    this._previousHits = this._currentHits;
    this._currentHits = {};
  }
  _handleTouchend() {
    this._previousHits = {};
    this._currentHits = {};
  }
  _fireCallback(hit, screenCoordinates, nativeEvent) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    if (hitIsMark(hit)) {
      const touchoutEvent = createMarkEvent("touchout", {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);
      this._markCallbacks[hit.data.id](touchoutEvent);
    }
    if (hitIsInLayer(hit)) {
      const touchoutEvent = createLayerEvent("touchout", {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);
      this._layerCallbacks[hit.data.id](touchoutEvent);
    }
  }
};
var TouchdragHandler = class extends MarkInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchdrag",
      eventName: ["touchstart", "touchmove", "touchend"]
    });
    this._currentHits = {};
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    if (nativeEvent.eventName === "touchstart") {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "touchmove") {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "touchend") {
      this._handleTouchend(screenCoordinates, nativeEvent);
    }
  }
  _handleTouchstart(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._currentHits[hitId] = hit;
      this._fireCallback(hit, screenCoordinates, nativeEvent, "start");
    }
  }
  _handleTouchmove(screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return;
    }
    for (const hitId in this._currentHits) {
      const hit = this._currentHits[hitId];
      this._fireCallback(hit, screenCoordinates, nativeEvent, "drag");
    }
  }
  _handleTouchend(screenCoordinates, nativeEvent) {
    for (const hitId in this._currentHits) {
      const hit = this._currentHits[hitId];
      this._fireCallback(hit, screenCoordinates, nativeEvent, "end");
    }
    this._currentHits = {};
  }
  _fireCallback(hit, screenCoordinates, nativeEvent, dragType) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());
    if (hitIsMark(hit)) {
      const touchdragEvent = createMarkEvent("touchdrag", {
        screenCoordinates,
        localCoordinates,
        dragType
      }, hit, nativeEvent);
      this._markCallbacks[hit.data.id](touchdragEvent);
    }
    if (hitIsInLayer(hit)) {
      const touchdragEvent = createLayerEvent("touchdrag", {
        screenCoordinates,
        localCoordinates,
        dragType
      }, hit, nativeEvent);
      this._layerCallbacks[hit.data.id](touchdragEvent);
    }
  }
};
var MarkInteractionHandlers$1 = Object.freeze({
  __proto__: null,
  TouchdownHandler,
  TouchupHandler,
  TouchoverHandler,
  TouchoutHandler,
  TouchdragHandler
});
var TouchdownHandler$1 = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchdown",
      eventName: "touchstart"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
      const touchdownEvent = createSectionEvent("touchdown", {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);
      this._callback(touchdownEvent);
    }
  }
};
var TouchmoveHandler = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchmove",
      eventName: "touchmove"
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
      const touchmoveEvent = createSectionEvent("touchmove", {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);
      this._callback(touchmoveEvent);
    }
  }
};
var TouchupHandler$1 = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchup",
      eventName: ["touchend", "touchcancel"]
    });
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
      const touchupEvent = createSectionEvent("touchup", {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);
      this._callback(touchupEvent);
    }
  }
};
var TouchoverHandler$1 = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchover",
      eventName: ["touchstart", "touchmove"]
    });
    this._fingerCurrentlyOverSection = false;
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    if (nativeEvent.eventName === "touchstart") {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "touchmove") {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }
  }
  _handleTouchstart(screenCoordinates, nativeEvent) {
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      this._fingerCurrentlyOverSection = true;
    }
  }
  _handleTouchmove(screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      if (!this._fingerCurrentlyOverSection) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
        const touchoverEvent = createSectionEvent("touchover", {
          screenCoordinates,
          localCoordinates
        }, nativeEvent);
        this._callback(touchoverEvent);
        this._fingerCurrentlyOverSection = true;
      }
    } else {
      if (this._fingerCurrentlyOverSection) {
        this._fingerCurrentlyOverSection = false;
      }
    }
  }
};
var TouchoutHandler$1 = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "touchout",
      eventName: ["touchstart", "touchmove", "touchend"]
    });
    this._fingerCurrentlyOverSection = false;
  }
  _handleEvent(screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return;
    }
    if (nativeEvent.eventName === "touchstart") {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "touchmove") {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }
    if (nativeEvent.eventName === "touchend") {
      this._handleTouchend();
    }
  }
  _handleTouchstart(screenCoordinates, nativeEvent) {
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      this._fingerCurrentlyOverSection = true;
    }
  }
  _handleTouchmove(screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();
    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      if (!this._fingerCurrentlyOverSection) {
        this._fingerCurrentlyOverSection = true;
      }
    } else {
      if (this._fingerCurrentlyOverSection) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
        const touchoutEvent = createSectionEvent("touchout", {
          screenCoordinates,
          localCoordinates
        }, nativeEvent);
        this._callback(touchoutEvent);
        this._fingerCurrentlyOverSection = false;
      }
    }
  }
  _handleTouchend() {
    this._fingerCurrentlyOverSection = false;
  }
};
var PinchHandler = class extends SectionInteractionHandler {
  constructor(interactionManager) {
    super(interactionManager, {
      interactionName: "pinch",
      eventName: ["touchstart", "touchmove", "touchend"]
    });
    this._previousTouchDistance = void 0;
  }
  _handleEvent(screenCoordinatesArray, nativeEvent) {
    if (nativeEvent.type === "touchstart") {
      this._handleTouchstart(screenCoordinatesArray, nativeEvent);
    }
    if (nativeEvent.type === "touchmove") {
      this._handleTouchmove(screenCoordinatesArray, nativeEvent);
    }
    if (nativeEvent.type === "touchend") {
      this._handleTouchend(screenCoordinatesArray, nativeEvent);
    }
  }
  _handleTouchstart(screenCoordinatesArray, nativeEvent) {
    if (numberOfTouches(screenCoordinatesArray) !== 2) {
      return;
    }
    const section = this.section();
    if (allCoordinatesAreInsideSection(screenCoordinatesArray, section)) {
      this._previousTouchDistance = getDistance(screenCoordinatesArray);
    }
  }
  _handleTouchmove(screenCoordinatesArray, nativeEvent) {
    if (numberOfTouches(screenCoordinatesArray) !== 2) {
      return;
    }
    if (this._previousTouchDistance === void 0)
      return;
    const section = this.section();
    if (allCoordinatesAreInsideSection(screenCoordinatesArray, section)) {
      const sectionHeight = section.maxY - section.minY;
      const center = getCenter(screenCoordinatesArray);
      const touchDistance = getDistance(screenCoordinatesArray);
      const touchDelta = this._previousTouchDistance - touchDistance;
      const relativeTouchDelta = touchDelta / sectionHeight;
      this._previousTouchDistance = touchDistance;
      this._fireCallback(screenCoordinatesArray, nativeEvent, relativeTouchDelta, center);
    }
  }
  _handleTouchend(screenCoordinatesArray, nativeEvent) {
    this._previousTouchDistance = void 0;
  }
  _fireCallback(screenCoordinatesArray, nativeEvent, delta, center) {
    const screenCenter = center;
    const localCenter = getLocalCoordinates(screenCenter, this.interactionManager());
    const screenCoordinates = screenCoordinatesArray;
    const localCoordinates = screenCoordinatesArray.map((screenCoordinates2) => {
      return getLocalCoordinates(screenCoordinates2, this.interactionManager());
    });
    const pinchEvent = createSectionEvent("pinch", {
      screenCenter,
      localCenter,
      screenCoordinates,
      localCoordinates,
      delta
    }, nativeEvent);
    this._callback(pinchEvent);
  }
};
function allCoordinatesAreInsideSection(screenCoordinatesArray, section) {
  return screenCoordinatesArray.every((screenCoordinates) => {
    return coordinatesAreInsideSection(screenCoordinates, section);
  });
}
function getDistance(screenCoordinatesArray) {
  const [coords1, coords2] = screenCoordinatesArray;
  return Math.sqrt((coords2.x - coords1.x) ** 2 + (coords2.y - coords1.y) ** 2);
}
function getCenter(screenCoordinatesArray) {
  const [coords1, coords2] = screenCoordinatesArray;
  return { x: (coords2.x + coords1.x) / 2, y: (coords2.y + coords1.y) / 2 };
}
var SectionInteractionHandlers$1 = Object.freeze({
  __proto__: null,
  TouchdownHandler: TouchdownHandler$1,
  TouchmoveHandler,
  TouchupHandler: TouchupHandler$1,
  TouchoverHandler: TouchoverHandler$1,
  TouchoutHandler: TouchoutHandler$1,
  PinchHandler
});
var TouchInteractionManager = class extends BaseInteractionManager {
  constructor() {
    super();
    this._markInteractionInterface = new MarkInteractionInterface(this, MarkInteractionHandlers$1);
    this._sectionInteractionInterface = new SectionInteractionInterface(this, SectionInteractionHandlers$1);
  }
};
function centroidPoint(mark) {
  return _centroidPoint(mark.positioning);
}
function _centroidPoint(positioning) {
  for (let i2 = 0; i2 < positioning.call.length; i2++) {
    if (positioning.call[i2] === "arc") {
      return [positioning.args[i2][0], positioning.args[i2][1]];
    }
  }
}
function centroidPointLayer(layer) {
  const centroids = [];
  for (let i2 = 0; i2 < layer.positioning.length; i2++) {
    centroids.push(_centroidPoint(layer.positioning[i2]));
  }
  return centroids;
}
function createBboxFromCentroid([x3, y3], index) {
  return {
    minX: x3,
    maxX: x3,
    minY: y3,
    maxY: y3,
    index
  };
}
function indexPoint$1(mark) {
  const centroid = centroidPoint(mark);
  const bbox = createBboxFromCentroid(centroid);
  Object.assign(bbox, { data: mark });
  return [bbox];
}
function indexPointLayer$1(layer) {
  const centroids = centroidPointLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function interpolateQuadratic(x0, y0, x1, y1, x23, y23) {
  const points = [];
  for (let i2 = 1; i2 <= 5; i2++) {
    const x3 = evalQuadratic(x0, x1, x23, i2 * 0.2);
    const y3 = evalQuadratic(y0, y1, y23, i2 * 0.2);
    points.push([x3, y3]);
  }
  return points;
}
function interpolateCubic(x0, y0, x1, y1, x23, y23, x3, y3) {
  const points = [];
  for (let i2 = 1; i2 <= 10; i2++) {
    const x4 = evalCubic(x0, x1, x23, x3, i2 * 0.2);
    const y4 = evalCubic(y0, y1, y23, y3, i2 * 0.2);
    points.push([x4, y4]);
  }
  return points;
}
function interpolateEllipse(x3, y3, rx, ry, rot, a0, a1, ccw) {
  const points = [];
  if (a0 < a1) {
    const da = a1 - a0;
    const dai = da / 8;
    if (!ccw) {
      for (let i2 = 1; i2 <= 8; i2++) {
        points.push([
          Math.cos(a0 + dai * i2) * rx + x3,
          Math.sin(a0 + dai * i2) * ry + y3
        ]);
      }
    }
    if (ccw) {
      for (let i2 = 7; i2 >= 0; i2--) {
        points.push([
          Math.cos(a0 + dai * i2) * rx + x3,
          Math.sin(a0 + dai * i2) * ry + y3
        ]);
      }
    }
  }
  if (a0 > a1) {
    const da0 = TWO_PI$1 - a1;
    const da0i = da0 / 8;
    const da1i = a0 / 8;
    if (!ccw) {
      for (let i2 = 1; i2 <= 8; i2++) {
        points.push([
          Math.cos(a1 + da0i * i2) * rx + x3,
          Math.sin(a1 + da0i * i2) * ry + y3
        ]);
      }
      for (let i2 = 1; i2 <= 8; i2++) {
        points.push([
          Math.cos(da1i * i2) * rx + x3,
          Math.sin(da1i * i2) * ry + y3
        ]);
      }
    }
    if (ccw) {
      for (let i2 = 7; i2 >= 0; i2--) {
        points.push([
          Math.cos(da1i * i2) * rx + x3,
          Math.sin(da1i * i2) * ry + y3
        ]);
      }
      for (let i2 = 7; i2 >= 0; i2--) {
        points.push([
          Math.cos(a1 + da0i * i2) * rx + x3,
          Math.sin(a1 + da0i * i2) * ry + y3
        ]);
      }
    }
  }
  return points;
}
var TWO_PI$1 = Math.PI * 2;
function centroidPolygon(mark) {
  return _centroidPolygon(mark.positioning);
}
function _centroidPolygon(positioning) {
  const linearRings = toLinearRings(positioning);
  const centroidsAndAreas = linearRings.map(calculateLinearRingCentroidAndArea);
  return getMeanCentroidWeightedByArea(centroidsAndAreas);
}
function centroidPolygonLayer(layer) {
  return layer.positioning.map(_centroidPolygon);
}
function toLinearRings(positioning) {
  const linearRings = [];
  const submarks = positioning.submarks.length ? positioning.submarks : [0];
  for (let i2 = 0; i2 < submarks.length; i2++) {
    const submarkStart = submarks[i2];
    const submarkEnd = submarks[i2 + 1] || positioning.call.length;
    linearRings.push(toLinearRing(positioning, submarkStart, submarkEnd));
  }
  return linearRings;
}
function toLinearRing(positioning, start, end) {
  let linearRing = [];
  let lastX;
  let lastY;
  let numberOfMoveTos = 0;
  for (let i2 = start; i2 < end; i2++) {
    const call = positioning.call[i2];
    const args = positioning.args[i2];
    switch (call) {
      case "moveTo":
        numberOfMoveTos++;
        if (numberOfMoveTos === 2) {
          return linearRing;
        }
        lastX = args[0];
        lastY = args[1];
        linearRing.push([lastX, lastY]);
        break;
      case "lineTo":
        lastX = args[0];
        lastY = args[1];
        linearRing.push([lastX, lastY]);
        break;
      case "quadraticCurveTo":
        linearRing = linearRing.concat(interpolateQuadratic(lastX, lastY, ...args));
        lastX = args[2];
        lastY = args[3];
        break;
      case "bezierCurveTo":
        linearRing = linearRing.concat(interpolateCubic(lastX, lastY, ...args));
        lastX = args[4];
        lastY = args[5];
        break;
      case "ellipse":
        linearRing = linearRing.concat(interpolateEllipse.apply(null, args));
        const endCoords = getEllipseEndCoords.apply(null, args);
        lastX = endCoords[0];
        lastY = endCoords[1];
        break;
      case "closePath":
        linearRing.push(linearRing[0]);
        break;
    }
  }
  return linearRing;
}
function calculateLinearRingCentroidAndArea(ring) {
  const last = ring.length - 1;
  if (ring[0][0] !== ring[last][0] || ring[0][1] !== ring[last][1]) {
    ring.push(ring[0]);
  }
  const nPts = ring.length;
  const off = ring[0];
  let twicearea = 0;
  let x3 = 0;
  let y3 = 0;
  let p1;
  let p2;
  let f2;
  for (let i2 = 0, j2 = nPts - 1; i2 < nPts; j2 = i2++) {
    p1 = ring[i2];
    p2 = ring[j2];
    f2 = (p1[0] - off[0]) * (p2[1] - off[1]) - (p2[0] - off[0]) * (p1[1] - off[1]);
    twicearea += f2;
    x3 += (p1[0] + p2[0] - 2 * off[0]) * f2;
    y3 += (p1[1] + p2[1] - 2 * off[1]) * f2;
  }
  f2 = twicearea * 3;
  return {
    centroid: [x3 / f2 + off[0], y3 / f2 + off[1]],
    area: Math.abs(twicearea / 2)
  };
}
function getMeanCentroidWeightedByArea(centroidsAndAreas) {
  if (centroidsAndAreas.length === 1)
    return centroidsAndAreas[0].centroid;
  let x3 = 0;
  let y3 = 0;
  let totalArea = 0;
  for (let i2 = 0; i2 < centroidsAndAreas.length; i2++) {
    const { centroid, area } = centroidsAndAreas[i2];
    x3 += centroid[0] * area;
    y3 += centroid[1] * area;
    totalArea += area;
  }
  return [x3 / totalArea, y3 / totalArea];
}
function indexRectangle$1(mark) {
  const centroid = centroidPolygon(mark);
  const bbox = createBboxFromCentroid(centroid);
  Object.assign(bbox, { data: mark });
  return [bbox];
}
function indexRectangleLayer$1(layer) {
  const centroids = centroidPolygonLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function indexPolygon$1(mark) {
  const centroid = centroidPolygon(mark);
  const bbox = createBboxFromCentroid(centroid);
  Object.assign(bbox, { data: mark });
  return [bbox];
}
function indexPolygonLayer$1(layer) {
  const centroids = centroidPolygonLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function indexLine$1(mark) {
  const centroid = centroidPolygon(mark);
  const bbox = createBboxFromCentroid(centroid);
  Object.assign(bbox, { data: mark });
  return [bbox];
}
function indexLineLayer$1(layer) {
  const centroids = centroidPolygonLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function indexArea$1(mark) {
  const centroid = centroidPolygon(mark);
  const bbox = createBboxFromCentroid(centroid);
  Object.assign(bbox, { data: mark });
  return [bbox];
}
function indexAreaLayer$1(layer) {
  const centroids = centroidPolygonLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
function centroidLabel(label) {
  const bbox = bboxLabel(label);
  return calculateLinearRingCentroidAndArea(bbox[0].rotatedBbox).centroid;
}
function centroidLabelLayer(labelLayer) {
  const bboxes = bboxLabelLayer(labelLayer);
  return bboxes.map((b2) => calculateLinearRingCentroidAndArea(b2.rotatedBbox).centroid);
}
function indexLabel$1(mark) {
  const centroid = centroidLabel(mark);
  const bbox = createBboxFromCentroid(centroid);
  Object.assign(bbox, { data: mark });
  return [bbox];
}
function indexLabelLayer$1(layer) {
  const centroids = centroidLabelLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);
  layer.props.keys ? attachWithKeys(bboxes, { data: layer }, layer.props.keys) : attach(bboxes, { data: layer });
  return bboxes;
}
var markIndexing$1 = {
  Point: indexPoint$1,
  Rectangle: indexRectangle$1,
  Polygon: indexPolygon$1,
  Line: indexLine$1,
  Label: indexLabel$1,
  Area: indexArea$1,
  Symbol: indexPolygon$1,
  FuncLine: indexLine$1
};
var layerIndexing$1 = {
  Point: indexPointLayer$1,
  Rectangle: indexRectangleLayer$1,
  Polygon: indexPolygonLayer$1,
  Line: indexLineLayer$1,
  Label: indexLabelLayer$1,
  Area: indexAreaLayer$1,
  Symbol: indexPolygon$1
};
var SelectManager = class {
  constructor() {
    this._selectableMarks = {};
    this._selectableLayers = {};
    this._markCallbacks = {};
    this._layerCallbacks = {};
    this._previousSelection = {};
    this._currentSelection = {};
    const getMark = function(markId2) {
      return this._selectableMarks[markId2];
    };
    const getLayer = function(layerId2) {
      return this._selectableLayers[layerId2];
    };
    this._spatialIndex = new SpatialIndex(this, getMark, getLayer);
    this._selectPolygon = { start: void 0, points: [] };
  }
  // Loading/indexing
  loadMark(mark, callbacks) {
    const indexingFunction = markIndexing$1[mark.type];
    const indexableMark = indexingFunction(mark);
    const markId2 = mark.id;
    this._selectableMarks[markId2] = indexableMark;
    this._markCallbacks[markId2] = callbacks;
    this._spatialIndex.indexMark(markId2);
  }
  markIsLoaded({ id }) {
    return id in this._selectableMarks;
  }
  removeMark({ id }) {
    this._spatialIndex.unindexMark(id);
    delete this._selectableMarks[id];
    delete this._markCallbacks[id];
  }
  loadLayer(layer, callbacks) {
    const indexingFunction = layerIndexing$1[layer.type];
    const indexableLayer = indexingFunction(layer);
    const layerId2 = layer.id;
    this._selectableLayers[layerId2] = indexableLayer;
    this._layerCallbacks[layerId2] = callbacks;
    this._spatialIndex.indexLayer(layerId2);
  }
  layerIsLoaded({ id }) {
    return id in this._selectableLayers;
  }
  removeLayer({ id }) {
    this._spatialIndex.unindexLayer(id);
    delete this._selectableLayers[id];
    delete this._layerCallbacks[id];
  }
  // Rectangle
  selectRectangle(rectangle) {
    const hits = this._spatialIndex.queryBoundingBox(rectangleToRBushBbox(rectangle));
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._currentSelection[hitId] = hit;
      this._fireSelectCallback(hit);
    }
  }
  updateSelectRectangle(rectangle) {
    this._previousSelection = this._currentSelection;
    this._currentSelection = {};
    const hits = this._spatialIndex.queryBoundingBox(rectangleToRBushBbox(rectangle));
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitId = getHitId(hit);
      this._currentSelection[hitId] = hit;
      if (!(hitId in this._previousSelection)) {
        this._fireSelectCallback(hit);
      }
    }
    for (const hitId in this._previousSelection) {
      if (!(hitId in this._currentSelection)) {
        const hit = this._previousSelection[hitId];
        this._fireDeselectCallback(hit);
      }
    }
  }
  resetSelectRectangle() {
    for (const hitId in this._currentSelection) {
      const hit = this._currentSelection[hitId];
      this._fireDeselectCallback(hit);
    }
    this._previousSelection = {};
    this._currentSelection = {};
  }
  // Polygon
  startSelectPolygon(startCoordinates) {
    this._selectPolygon.start = parseCoordinates(startCoordinates);
  }
  addPointToSelectPolygon(coordinates) {
    this._selectPolygon.points.push(parseCoordinates(coordinates));
    if (this._selectPolygon.points.length > 1) {
      const lastThreePointsPolygon = this._getLastThreePointsPolygon();
      const bbox = calculateBbox(lastThreePointsPolygon);
      const hits = this._spatialIndex.queryBoundingBox(bbox);
      for (let i2 = 0; i2 < hits.length; i2++) {
        const hit = hits[i2];
        const hitCentroid = [hit.minX, hit.minY];
        if (pointInPolygon(hitCentroid, lastThreePointsPolygon)) {
          const hitId = getHitId(hit);
          if (hitId in this._currentSelection) {
            this._fireDeselectCallback(hit);
            delete this._currentSelection[hitId];
          } else {
            this._fireSelectCallback(hit);
            this._currentSelection[hitId] = hit;
          }
        }
      }
    }
  }
  moveSelectPolygon(_delta) {
    this._previousSelection = this._currentSelection;
    this._currentSelection = {};
    const delta = parseCoordinates(_delta);
    const start = this._selectPolygon.start;
    const points = this._selectPolygon.points;
    this._selectPolygon.start = [start[0] + delta[0], start[1] + delta[1]];
    this._selectPolygon.points = points.map((point6) => [point6[0] + delta[0], point6[1] + delta[1]]);
    const polygon = this.getSelectPolygon();
    const bbox = calculateBbox(polygon.coordinates[0]);
    const hits = this._spatialIndex.queryBoundingBox(bbox);
    for (let i2 = 0; i2 < hits.length; i2++) {
      const hit = hits[i2];
      const hitCentroid = [hit.minX, hit.minY];
      if (pointInPolygon(hitCentroid, polygon.coordinates[0])) {
        const hitId = getHitId(hit);
        this._currentSelection[hitId] = hit;
        if (!(hitId in this._previousSelection)) {
          this._fireSelectCallback(hit);
        }
      }
    }
    for (const hitId in this._previousSelection) {
      if (!(hitId in this._currentSelection)) {
        const hit = this._previousSelection[hitId];
        this._fireDeselectCallback(hit);
      }
    }
  }
  getSelectPolygon() {
    if (this._selectPolygon.start) {
      return {
        type: "Polygon",
        coordinates: [[
          this._selectPolygon.start,
          ...this._selectPolygon.points,
          this._selectPolygon.start
        ]]
      };
    }
  }
  resetSelectPolygon() {
    for (const hitId in this._currentSelection) {
      const hit = this._currentSelection[hitId];
      this._fireDeselectCallback(hit);
    }
    this._selectPolygon = { start: void 0, points: [] };
    this._currentSelection = {};
  }
  _fireSelectCallback(hit) {
    if (hitIsMark(hit)) {
      const selectEvent = createSelectMarkEvent("select", hit);
      const callback = this._markCallbacks[hit.data.id].onSelect;
      if (callback)
        callback(selectEvent);
    }
    if (hitIsInLayer(hit)) {
      const selectEvent = createSelectLayerEvent("select", hit);
      const callback = this._layerCallbacks[hit.data.id].onSelect;
      if (callback)
        callback(selectEvent);
    }
  }
  _fireDeselectCallback(hit) {
    if (hitIsMark(hit)) {
      const deselectEvent = createSelectMarkEvent("deselect", hit);
      const callback = this._markCallbacks[hit.data.id].onDeselect;
      if (callback)
        callback(deselectEvent);
    }
    if (hitIsInLayer(hit)) {
      const deselectEvent = createSelectLayerEvent("deselect", hit);
      const callback = this._layerCallbacks[hit.data.id].onDeselect;
      if (callback)
        callback(deselectEvent);
    }
  }
  _getLastThreePointsPolygon() {
    const points = this._selectPolygon.points;
    const lastPointIndex = points.length - 1;
    const start = this._selectPolygon.start;
    return [start, points[lastPointIndex - 1], points[lastPointIndex], start];
  }
};
function rectangleToRBushBbox(rectangle) {
  return {
    minX: Math.min(rectangle.x1, rectangle.x2),
    maxX: Math.max(rectangle.x1, rectangle.x2),
    minY: Math.min(rectangle.y1, rectangle.y2),
    maxY: Math.max(rectangle.y1, rectangle.y2)
  };
}
function parseCoordinates(coordinates) {
  if (is2dArray(coordinates))
    return coordinates;
  if (isXYObject(coordinates))
    return [coordinates.x, coordinates.y];
  throw new Error(`Invalid input: ${coordinates}`);
}
function is2dArray(coordinates) {
  return coordinates.constructor === Array && coordinates.length === 2 && coordinates.every((c2) => c2 && c2.constructor === Number);
}
function isXYObject(coordinates) {
  return "x" in coordinates && "y" in coordinates && coordinates.x.constructor === Number && coordinates.y.constructor === Number;
}
function calculateBbox(coords) {
  const bbox = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity };
  for (let i2 = 0; i2 < coords.length; i2++) {
    const [x3, y3] = coords[i2];
    updateBbox(bbox, x3, y3);
  }
  return bbox;
}
var InteractionManager = class {
  constructor() {
    if (primaryInput === "mouse") {
      this._mouseInteractionManager = new MouseInteractionManager();
    }
    if (primaryInput === "touch") {
      this._touchInteractionManager = new TouchInteractionManager();
    }
    this._selectManager = new SelectManager();
  }
  // Initialization
  setId(id) {
    this._forEachManager((manager) => {
      manager.setId(id);
    });
  }
  linkEventManager(eventManager) {
    if (this._mouseInteractionManager) {
      this._mouseInteractionManager.linkEventManager(eventManager.mouse());
    }
    if (this._touchInteractionManager) {
      this._touchInteractionManager.linkEventManager(eventManager.touch());
    }
  }
  // Section context loading
  loadSection(sectionContext) {
    this._forEachManager((manager) => {
      manager.loadSection(sectionContext);
    });
  }
  // Access sub managers
  mouse() {
    return this._mouseInteractionManager;
  }
  touch() {
    return this._touchInteractionManager;
  }
  select() {
    return this._selectManager;
  }
  // Other
  getPrimaryInput() {
    return primaryInput;
  }
  // Internal
  _forEachManager(callback) {
    if (this._mouseInteractionManager)
      callback(this._mouseInteractionManager);
    if (this._touchInteractionManager)
      callback(this._touchInteractionManager);
  }
};
function getOrientation(props) {
  return props.x ? "x" : "y";
}
function streamArea(g2, stream2) {
  const orientation = getOrientation(g2);
  if (orientation === "x") {
    streamAreaX(g2.x, g2.y1, g2.y2, stream2);
  }
  if (orientation === "y") {
    streamAreaY(g2.x1, g2.x2, g2.y, stream2);
  }
}
function streamLine(g2, stream2) {
  _streamLine(g2.x, g2.y, stream2);
}
function streamPoint(g2, stream2) {
  stream2.point(g2.x, g2.y);
}
function streamPolygon(g2, stream2) {
  _streamPolygon(g2.x, g2.y, stream2);
}
function streamRectangle(g2, stream2) {
  _streamRectangle(g2.x1, g2.x2, g2.y1, g2.y2, stream2);
}
function streamAreaLayer(g2, stream2) {
  const orientation = getOrientation(g2);
  if (orientation === "x") {
    forEachIndex(g2.x.length, (i2) => {
      streamAreaX(g2.x[i2], g2.y1[i2], g2.y2[i2], stream2);
      stream2.markEnd();
    });
  }
  if (orientation === "y") {
    forEachIndex(g2.y.length, (i2) => {
      streamAreaY(g2.x1[i2], g2.x2[i2], g2.y[i2], stream2);
      stream2.markEnd();
    });
  }
}
function streamLineLayer(g2, stream2) {
  forEachIndex(g2.x.length, (i2) => {
    _streamLine(g2.x[i2], g2.y[i2], stream2);
    stream2.markEnd();
  });
}
function streamPointLayer(g2, stream2) {
  forEachIndex(g2.x.length, (i2) => {
    stream2.point(g2.x[i2], g2.y[i2]);
    stream2.markEnd();
  });
}
function streamPolygonLayer(g2, stream2) {
  forEachIndex(g2.x.length, (i2) => {
    _streamPolygon(g2.x[i2], g2.y[i2], stream2);
    stream2.markEnd();
  });
}
function streamRectangleLayer(g2, stream2) {
  forEachIndex(g2.x1.length, (i2) => {
    _streamRectangle(
      g2.x1[i2],
      g2.x2[i2],
      g2.y1[i2],
      g2.y2[i2],
      stream2
    );
    stream2.markEnd();
  });
}
function _streamLine(x3, y3, stream2, closed = 0) {
  stream2.lineStart();
  streamXYArrays(x3, y3, stream2, closed);
  stream2.lineEnd();
}
function _streamPolygon(x3, y3, stream2) {
  const closed = isClosed(x3, y3) ? 1 : 0;
  stream2.polygonStart();
  _streamLine(x3, y3, stream2, closed);
  stream2.polygonEnd();
}
function _streamRectangle(x1, x23, y1, y23, stream2) {
  stream2.polygonStart();
  stream2.lineStart();
  stream2.point(x1, y1);
  stream2.point(x23, y1);
  stream2.point(x23, y23);
  stream2.point(x1, y23);
  stream2.lineEnd();
  stream2.polygonEnd();
}
function streamAreaX(x3, y1, y23, stream2) {
  stream2.areaStart();
  stream2.lineStart();
  streamXYArrays(x3, y23, stream2);
  stream2.lineEnd();
  stream2.lineStart();
  reverseStreamXYArrays(x3, y1, stream2);
  stream2.lineEnd();
  stream2.areaEnd();
}
function streamAreaY(x1, x23, y3, stream2) {
  stream2.areaStart();
  stream2.lineStart();
  streamXYArrays(x23, y3, stream2);
  stream2.lineEnd();
  stream2.lineStart();
  reverseStreamXYArrays(x1, y3, stream2);
  stream2.lineEnd();
  stream2.areaEnd();
}
function streamXYArrays(x3, y3, stream2, closed = 0) {
  let i2 = -1;
  const n2 = x3.length - closed;
  while (++i2 < n2)
    stream2.point(x3[i2], y3[i2]);
}
function isClosed(x3, y3) {
  const lastIndex = x3.length - 1;
  return x3[0] === x3[lastIndex] && y3[0] === y3[lastIndex];
}
function reverseStreamXYArrays(x3, y3, stream2) {
  let i2 = x3.length;
  while (--i2 > -1)
    stream2.point(x3[i2], y3[i2]);
}
function forEachIndex(length, fn) {
  for (let i2 = 0; i2 < length; i2++)
    fn(i2);
}
function scale(scales) {
  const { x: scaleX, y: scaleY } = scales;
  return (stream2) => new Scale(stream2, scaleX, scaleY);
}
var Scale = class extends Transformer {
  constructor(stream2, scaleX, scaleY) {
    super(stream2);
    this.scaleX = scaleX;
    this.scaleY = scaleY;
  }
  point(x3, y3) {
    this.stream.point(this.scaleX(x3), this.scaleY(y3));
  }
  moveTo(x3, y3) {
    this.stream.moveTo(this.scaleX(x3), this.scaleY(y3));
  }
  lineTo(x3, y3) {
    this.stream.lineTo(this.scaleX(x3), this.scaleY(y3));
  }
  quadraticCurveTo(cpx, cpy, x3, y3) {
    this.stream.quadraticCurveTo(
      this.scaleX(cpx),
      this.scaleY(cpy),
      this.scaleX(x3),
      this.scaleY(y3)
    );
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3) {
    this.stream.bezierCurveTo(
      this.scaleX(cp1x),
      this.scaleY(cp1y),
      this.scaleX(cp2x),
      this.scaleY(cp2y),
      this.scaleX(x3),
      this.scaleY(y3)
    );
  }
  arc(x3, y3, r2, sAngle, eAngle, counterclockwise) {
    this.stream.arc(
      this.scaleX(x3),
      this.scaleY(y3),
      r2,
      sAngle,
      eAngle,
      counterclockwise
    );
  }
  arcTo(x1, y1, x23, y23, r2) {
    this.stream.arcTo(
      this.scaleX(x1),
      this.scaleY(y1),
      this.scaleX(x23),
      this.scaleY(y23),
      r2
    );
  }
  ellipse(x3, y3, rx, ry, rotation, sAngle, eAngle, counterclockwise) {
    this.stream.ellipse(
      this.scaleX(x3),
      this.scaleY(y3),
      rx,
      ry,
      rotation,
      sAngle,
      eAngle,
      counterclockwise
    );
  }
  translate(x3, y3) {
    this.stream.translate(this.scaleX(x3), this.scaleY(y3));
  }
};
function round(decimals = 0) {
  const roundFn = createRoundFn(decimals);
  return scale({ x: roundFn, y: roundFn });
}
function createRoundFn(decimals) {
  const multiplier = Math.pow(10, decimals);
  return (n2) => Math.round(n2 * multiplier) / multiplier;
}
function transform(transformers) {
  const { x: transformX, y: transformY } = transformers;
  return (stream2) => new Transform(stream2, transformX, transformY);
}
var Transform = class extends Transformer {
  constructor(stream2, transformX, transformY) {
    super(stream2);
    this.transformX = transformX;
    this.transformY = transformY;
  }
  point(x3, y3) {
    this.stream.point(this.transformX(x3, y3), this.transformY(x3, y3));
  }
  moveTo(x3, y3) {
    this.stream.moveTo(this.transformX(x3, y3), this.transformY(x3, y3));
  }
  lineTo(x3, y3) {
    this.stream.lineTo(this.transformX(x3, y3), this.transformY(x3, y3));
  }
  quadraticCurveTo(cpx, cpy, x3, y3) {
    this.stream.quadraticCurveTo(
      this.transformX(cpx, cpy),
      this.transformY(cpx, cpy),
      this.transformX(x3, y3),
      this.transformY(x3, y3)
    );
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x3, y3) {
    this.stream.bezierCurveTo(
      this.transformX(cp1x, cp1y),
      this.transformY(cp1x, cp1y),
      this.transformX(cp2x, cp2y),
      this.transformY(cp2x, cp2y),
      this.transformX(x3, y3),
      this.transformY(x3, y3)
    );
  }
  arc(x3, y3, r2, sAngle, eAngle, counterclockwise) {
    this.stream.arc(
      this.transformX(x3, y3),
      this.transformY(x3, y3),
      r2,
      sAngle,
      eAngle,
      counterclockwise
    );
  }
  arcTo(x1, y1, x23, y23, r2) {
    this.stream.arcTo(
      this.transformX(x1, y1),
      this.transformY(x1, y1),
      this.transformX(x23, y23),
      this.transformY(x23, y23),
      r2
    );
  }
  ellipse(x3, y3, rx, ry, rotation, sAngle, eAngle, counterclockwise) {
    this.stream.ellipse(
      this.transformX(x3, y3),
      this.transformY(x3, y3),
      rx,
      ry,
      rotation,
      sAngle,
      eAngle,
      counterclockwise
    );
  }
  translate(x3, y3) {
    this.stream.translate(this.transformX(x3, y3), this.transformY(x3, y3));
  }
};
function createPipeline(props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    props.curve,
    outputSettings.round ? round(outputSettings.decimals) : null,
    context
  );
}
var DEFAULT_SETTINGS = {
  round: true,
  decimals: 0
};
function parseOutputSettings(outputSettings) {
  const parsedOutputSettings = outputSettings || {};
  for (const settingName in DEFAULT_SETTINGS) {
    if (!(settingName in parsedOutputSettings)) {
      parsedOutputSettings[settingName] = DEFAULT_SETTINGS[settingName];
    }
  }
  return parsedOutputSettings;
}
function propBypassesScaling(prop) {
  return prop.constructor === Function;
}
function fallback(value, fallbackValue) {
  return isDefined(value) ? value : fallbackValue;
}
function isDefined(prop) {
  return prop !== void 0;
}
function repeat(value, length) {
  return Array(length).fill(value);
}
function getPositioningMethod(props) {
  return props.geometry ? "geojson" : "florence";
}
function parsePoint(props, section) {
  let { parsedProps, scales } = parsePositioning(props, section);
  parsedProps = parseAesthetics(props, parsedProps);
  return { props: parsedProps, scales };
}
function parsePositioning(props, section) {
  const positioningMethod = getPositioningMethod(props);
  if (positioningMethod === "florence") {
    const bypassScalingX = propBypassesScaling(props.x);
    const bypassScalingY = propBypassesScaling(props.y);
    const parsedProps = {
      x: bypassScalingX ? props.x(section) : props.x,
      y: bypassScalingY ? props.y(section) : props.y
    };
    const scales = {
      x: bypassScalingX ? section.indirectScales.x : section.directScales.x,
      y: bypassScalingY ? section.indirectScales.y : section.directScales.y
    };
    return { parsedProps, scales };
  }
  if (positioningMethod === "geojson") {
    const bypassScaling = propBypassesScaling(props.geometry);
    const parsedProps = {
      geometry: bypassScaling ? props.geometry(section) : props.geometry
    };
    const scales = bypassScaling ? section.indirectScales : section.directScales;
    return { parsedProps, scales };
  }
}
var parseAestheticsPoint = parseAesthetics;
var parseAestheticsPointLayer = parseAesthetics;
function parseAesthetics(props, parsedProps) {
  parsedProps = parsedProps ?? {};
  parsedProps.radius = fallback(props.radius, 3);
  return parseAesthetics$1(props, parsedProps);
}
function parsePolygon(props, section) {
  let { parsedProps, scales } = parsePositioning(props, section);
  parsedProps = parseAesthetics$1(props, parsedProps);
  return { props: parsedProps, scales };
}
var parseAestheticsPolygon = parseAesthetics$1;
var parseAestheticsPolygonLayer = parseAesthetics$1;
function parseAesthetics$1(props, parsedProps) {
  parsedProps = parsedProps ?? {};
  parsedProps.fill = fallback(props.fill, "black");
  parsedProps.stroke = fallback(props.stroke, "none");
  if (parsedProps.stroke !== "none") {
    parsedProps.strokeWidth = fallback(props.strokeWidth, 1);
  }
  OPTIONAL_AESTHETICS.forEach((style) => {
    if (props[style])
      parsedProps[style] = props[style];
  });
  return parsedProps;
}
var OPTIONAL_AESTHETICS = [
  "opacity",
  "fillOpacity",
  "strokeOpacity",
  "lineJoin",
  "miterLimit",
  "dashArray",
  "dashOffset",
  "keys",
  "clip",
  "asOnePath"
];
function parseArea(props, section) {
  const parsedProps = parsePositioningArea(props, section);
  return parseAesthetics$2(props, parsedProps);
}
function parseAreaLayer(props, section) {
  const parsedProps = parsePositioningAreaLayer(props, section);
  return parseAesthetics$2(props, parsedProps);
}
function parsePositioningArea(props, section) {
  const parsedProps = {};
  const orientation = getOrientation(props);
  if (orientation === "x") {
    parsedProps.x = getCoordX(props.x, section);
    parsedProps.y1 = getCoordY(props.y1, section);
    parsedProps.y2 = getCoordY(props.y2, section);
  }
  if (orientation === "y") {
    parsedProps.y = getCoordY(props.y, section);
    parsedProps.x1 = getCoordX(props.x1, section);
    parsedProps.x2 = getCoordX(props.x2, section);
  }
  return parsedProps;
}
function parsePositioningAreaLayer(props, section) {
  const parsedProps = {};
  const orientation = getOrientation(props);
  if (orientation === "x") {
    parsedProps.x = getCoordsX(props.x, section);
    parsedProps.y1 = getCoordsY(props.y1, section);
    parsedProps.y2 = getCoordsY(props.y2, section);
  }
  if (orientation === "y") {
    parsedProps.y = getCoordsY(props.y, section);
    parsedProps.x1 = getCoordsX(props.x1, section);
    parsedProps.x2 = getCoordsX(props.x2, section);
  }
  return parsedProps;
}
var parseAestheticsArea = parseAesthetics$2;
var parseAestheticsAreaLayer = parseAesthetics$2;
var getCoordX = coordGetter("scaleX");
var getCoordY = coordGetter("scaleY");
function coordGetter(scale2) {
  return function(coord, section) {
    if (propBypassesScaling(coord)) {
      return coord(section);
    }
    return coord.map(section[scale2]);
  };
}
var getCoordsX = coordsGetter("scaleX");
var getCoordsY = coordsGetter("scaleY");
function coordsGetter(scale2) {
  return function(coord, section) {
    if (propBypassesScaling(coord)) {
      return coord(section);
    }
    return nestedMap(coord, section[scale2]);
  };
}
function nestedMap(nestedArray, fn) {
  const result = [];
  for (let i2 = 0; i2 < nestedArray.length; i2++) {
    result.push([]);
    for (let j2 = 0; j2 < nestedArray[i2].length; j2++) {
      result[i2].push(fn(nestedArray[i2][j2]));
    }
  }
  return result;
}
function parseAesthetics$2(props, parsedProps) {
  parsedProps = parsedProps ?? {};
  parsedProps.curve = fallback(props.curve, linear_default);
  return parseAesthetics$1(props, parsedProps);
}
function toRGBA(_color, opacity) {
  const color = _color in COLOR_NAMES ? COLOR_NAMES[_color] : _color;
  const colorTranslator = new nt(color);
  colorTranslator.setA(colorTranslator.A * opacity);
  return colorTranslator.RGBA;
}
var COLOR_NAMES = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  "indianred ": "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgrey: "#d3d3d3",
  lightgreen: "#90ee90",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370d8",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#d87093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function getFillStyle(props) {
  if (props.fill === "none")
    return;
  const opacity = isProvided(props.opacity) ? props.opacity : 1;
  const fillOpacity = isProvided(props.fillOpacity) ? props.fillOpacity : 1;
  return toRGBA(props.fill, opacity * fillOpacity);
}
function getStrokeStyle(props) {
  if (props.stroke === "none")
    return;
  const opacity = isProvided(props.opacity) ? props.opacity : 1;
  const strokeOpacity = isProvided(props.strokeOpacity) ? props.strokeOpacity : 1;
  return toRGBA(props.stroke, opacity * strokeOpacity);
}
function getFont(props) {
  return props.fontWeight === "normal" ? `${props.fontSize}px ${props.fontFamily}` : `${props.fontWeight} ${props.fontSize}px ${props.fontFamily}`;
}
function getAnchorPoint({ anchorPoint }) {
  switch (anchorPoint) {
    case "center":
      return { textAlign: "center", textBaseline: "middle" };
    case "lb":
      return { textAlign: "start", textBaseline: "alphabetic" };
    case "lt":
      return { textAlign: "start", textBaseline: "hanging" };
    case "rt":
      return { textAlign: "end", textBaseline: "hanging" };
    case "rb":
      return { textAlign: "end", textBaseline: "alphabetic" };
    case "l":
      return { textAlign: "start", textBaseline: "middle" };
    case "r":
      return { textAlign: "end", textBaseline: "middle" };
    case "b":
      return { textAlign: "center", textBaseline: "alphabetic" };
    case "t":
      return { textAlign: "center", textBaseline: "hanging" };
    default: {
      return { textAlign: "center", textBaseline: "middle" };
    }
  }
}
var isProvided = (prop) => prop !== void 0;
var markStyler = {
  apply: applyStyling
};
var layerStyler = {
  create(props) {
    const keys = props.keys;
    const getAesthetics = batchAestheticGetter(
      props,
      AESTHETICS,
      keys
    );
    return function apply(context, i2) {
      const aesthetics = getAesthetics(i2);
      applyStyling(context, aesthetics);
    };
  },
  asOnePath(props) {
    return props.asOnePath && areAllStylesGlobal(props, AESTHETICS);
  }
};
var AESTHETICS = [
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "fill",
  "fillOpacity",
  "opacity",
  "lineJoin",
  "miterLimit",
  "dashArray",
  "dashOffset"
];
function applyStyling(context, aesthetics) {
  if (aesthetics.lineJoin) {
    context.lineJoin = aesthetics.lineJoin;
    if (aesthetics.lineJoin === "miter" && aesthetics.miterLimit !== void 0) {
      context.miterLimit = aesthetics.miterLimit;
    }
  }
  if (aesthetics.dashArray) {
    context.setLineDash(aesthetics.dashArray.split(" ").map((x3) => parseInt(x3)));
    if (aesthetics.dashOffset) {
      context.lineDashOffset = aesthetics.dashOffset;
    }
  }
  const strokeStyle = getStrokeStyle(aesthetics);
  const fillStyle = getFillStyle(aesthetics);
  if (fillStyle) {
    context.fillStyle = fillStyle;
    context.fill();
  }
  if (strokeStyle) {
    context.lineWidth = aesthetics.strokeWidth;
    context.strokeStyle = strokeStyle;
    context.stroke();
  }
}
function createArea(_props, section, outputSettings) {
  const props = parseArea(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning(props, section, outputSettings);
  return new Mark(
    positioning,
    props,
    section,
    markStyler,
    "Area"
  );
}
function getPositioning(props, section, outputSettings) {
  const markRecorder = recorderMark();
  const pipeline = createPipeline(
    props,
    section,
    section.indirectScales,
    markRecorder,
    outputSettings
  );
  streamArea(props, pipeline);
  return markRecorder.result();
}
function createAreaLayer(_props, section, outputSettings) {
  const props = parseAreaLayer(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$1(props, section, outputSettings);
  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    "Area"
  );
}
function getPositioning$1(props, section, outputSettings) {
  const layerRecorder = recorderLayer();
  const pipeline = createPipeline(
    props,
    section,
    section.indirectScales,
    layerRecorder,
    outputSettings
  );
  streamAreaLayer(props, pipeline);
  return layerRecorder.result();
}
function streamGeometry(geometry, stream2, i2) {
  streamGeometryType[geometry.type](
    geometry.coordinates,
    stream2,
    i2
  );
}
function streamGeometries(geometries, stream2) {
  let i2 = -1;
  while (++i2 < geometries.length) {
    const geometry = geometries[i2];
    streamGeometryType[geometry.type](
      geometry.coordinates,
      stream2,
      i2
    );
    stream2.markEnd();
  }
}
var streamGeometryType = {
  Point(c2, stream2, i2) {
    stream2.point(c2[0], c2[1]);
  },
  LineString(c2, stream2, i2) {
    streamLineString(c2, stream2);
  },
  Polygon(c2, stream2, i2) {
    streamPolygon$1(c2, stream2);
  },
  MultiLineString(c2, stream2, i2) {
    let j2 = -1;
    while (++j2 < c2.length) {
      stream2.submarkStart();
      streamLineString(c2[j2], stream2);
    }
  },
  MultiPolygon(c2, stream2, i2) {
    let j2 = -1;
    while (++j2 < c2.length) {
      stream2.submarkStart();
      streamPolygon$1(c2[j2], stream2);
    }
  }
};
function streamLineString(c2, stream2, closed = 0) {
  stream2.lineStart();
  streamCoordArray(c2, stream2, closed);
  stream2.lineEnd();
}
function streamPolygon$1(c2, stream2) {
  let i2 = -1;
  stream2.polygonStart();
  while (++i2 < c2.length)
    streamLineString(c2[i2], stream2, 1);
  stream2.polygonEnd();
}
function streamCoordArray(c2, stream2, closed = 0) {
  let i2 = -1;
  const n2 = c2.length - closed;
  while (++i2 < n2)
    stream2.point(c2[i2][0], c2[i2][1]);
}
function createPipeline$1(props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    curveLinear,
    context
  );
}
function curveLinear(context) {
  return new CurveLinear(context);
}
function CurveLinear(context) {
  this._context = context;
}
CurveLinear.prototype = {
  polygonStart() {
    this._line = 0;
  },
  polygonEnd() {
    this._line = NaN;
  },
  lineStart() {
    this._point = 0;
  },
  lineEnd() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point(x3, y3) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x3, y3);
        this._point = 1;
        break;
      }
      default: {
        this._context.lineTo(x3, y3);
      }
    }
  }
};
function createPipeline$2(props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? polarConnector(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    section.coordinateSystem ? null : curveLinear,
    context
  );
}
function polarConnector(coordinateSystem) {
  return (context) => new PolarConnector(coordinateSystem, context);
}
var PolarConnector = class {
  constructor(coordinateSystem, context) {
    this._coordinateSystem = coordinateSystem;
    this._context = context;
    this._overallDirectionIsClockwise = overallDirectionIsClockwise(coordinateSystem);
  }
  polygonStart() {
    this._line = 0;
    this._arc = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  }
  point(theta, r2) {
    const x3 = this._coordinateSystem.x(theta, r2);
    const y3 = this._coordinateSystem.y(theta, r2);
    const adjustedTheta = adjustTheta(theta, this._coordinateSystem);
    switch (this._point) {
      case 0: {
        this._context.moveTo(x3, y3);
        this._point = 1;
        this._lastTheta = adjustedTheta;
        break;
      }
      default: {
        this._handlePolarSegment(x3, y3, adjustedTheta, r2);
        this._lastTheta = adjustedTheta;
      }
    }
  }
  _handlePolarSegment(x3, y3, theta, r2) {
    if (this._lastTheta === theta) {
      this._context.lineTo(x3, y3);
    } else {
      const { midX, midY, halfWidth, halfHeight } = this._coordinateSystem;
      const ccw = getCcw(this._arc, this._overallDirectionIsClockwise);
      this._context.ellipse(
        midX,
        midY,
        halfWidth * r2,
        halfHeight * r2,
        0,
        this._lastTheta,
        theta,
        ccw
      );
      this._arc = 1;
    }
  }
};
var TWO_PI$2 = Math.PI * 2;
function adjustTheta(theta, { flipX, flipY }) {
  if (!flipY && !flipX)
    return theta;
  if (flipY && !flipX)
    return TWO_PI$2 - theta;
  if (!flipY && flipX)
    return Math.PI - theta;
  return Math.PI + theta;
}
function overallDirectionIsClockwise({ flipX, flipY }) {
  if (!flipY && !flipX)
    return true;
  if (flipY && !flipX)
    return false;
  if (!flipY && flipX)
    return false;
  return true;
}
function getCcw(arc, overallDirectionIsClockwise2) {
  if (arc === 0 && overallDirectionIsClockwise2)
    return 0;
  if (arc === 1 && overallDirectionIsClockwise2)
    return 1;
  if (arc === 0 && !overallDirectionIsClockwise2)
    return 1;
  return 0;
}
function createPipeline$3(props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem && !props._resampleIntervals ? transform(section.coordinateSystem) : null,
    section.coordinateSystem && props._resampleIntervals ? polarConnector(section.coordinateSystem) : props.curve,
    outputSettings.round ? round(outputSettings.decimals) : null,
    context
  );
}
function parseLine(props, section) {
  const { parsedProps, scales } = parsePositioning(props, section);
  parseAesthetics$3(props, parsedProps);
  return { props: parsedProps, scales };
}
var parseAestheticsLine = parseAesthetics$3;
var parseAestheticsLineLayer = parseAesthetics$3;
function parseAesthetics$3(props, parsedProps) {
  parsedProps = parsedProps ?? {};
  parsedProps.curve = fallback(props.curve, linear_default);
  parsedProps.strokeWidth = fallback(props.strokeWidth, 3);
  parsedProps.stroke = fallback(props.stroke, "black");
  OPTIONAL_AESTHETICS$1.forEach((style) => {
    if (props[style])
      parsedProps[style] = props[style];
  });
  return parsedProps;
}
var OPTIONAL_AESTHETICS$1 = [
  "opacity",
  "lineCap",
  "lineJoin",
  "miterLimit",
  "dashArray",
  "dashOffset",
  "opacity",
  "keys",
  "clip",
  "asOnePath",
  "_resampleIntervals"
];
var markStyler$1 = {
  apply: applyStyling$1
};
var layerStyler$1 = {
  create(props) {
    const keys = props.keys;
    const getAesthetics = batchAestheticGetter(
      props,
      AESTHETICS$1,
      keys
    );
    return function apply(context, i2) {
      const aesthetics = getAesthetics(i2);
      applyStyling$1(context, aesthetics);
    };
  },
  asOnePath(props) {
    return props.asOnePath && areAllStylesGlobal(props, AESTHETICS$1);
  }
};
var AESTHETICS$1 = [
  "stroke",
  "strokeWidth",
  "opacity",
  "lineCap",
  "lineJoin",
  "miterLimit",
  "dashArray",
  "dashOffset"
];
function applyStyling$1(context, aesthetics) {
  if (aesthetics.lineCap) {
    context.lineCap = aesthetics.lineCap;
  }
  if (aesthetics.lineJoin) {
    context.lineJoin = aesthetics.lineJoin;
    if (aesthetics.lineJoin === "miter" && aesthetics.miterLimit !== void 0) {
      context.miterLimit = aesthetics.miterLimit;
    }
  }
  if (aesthetics.dashArray) {
    context.setLineDash(aesthetics.dashArray.split(" ").map((x3) => parseInt(x3)));
    if (aesthetics.dashOffset) {
      context.lineDashOffset = aesthetics.dashOffset;
    }
  }
  const strokeStyle = getStrokeStyle(aesthetics);
  context.lineWidth = aesthetics.strokeWidth;
  context.strokeStyle = strokeStyle;
  context.fillStyle = "none";
  context.stroke();
}
function createLine(_props, section, outputSettings) {
  const { props, scales } = parseLine(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$2(props, section, scales, outputSettings);
  return new Mark(
    positioning,
    props,
    section,
    markStyler$1,
    "Line"
  );
}
function getPositioning$2(props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const markRecorder = recorderMark();
  const pipeline = createPipeline$3(props, section, scales, markRecorder, outputSettings);
  if (positioningMethod === "florence") {
    streamLine(props, pipeline);
  }
  if (positioningMethod === "geojson") {
    streamGeometry(props.geometry, pipeline);
  }
  return markRecorder.result();
}
function parseFuncLine(props, section) {
  const parsedProps = parsePositioningFuncLine(props, section);
  return parseAesthetics$3(props, parsedProps);
}
function parsePositioningFuncLine(props, section) {
  const parsedProps = {
    func: props.func,
    x: fallback(props.x, getDomainX(section)),
    resolution: fallback(props.resolution, 3)
  };
  return parsedProps;
}
var parseAestheticsFuncLine = parseAesthetics$3;
function getDomainX({ scaleX, rangeX }) {
  return scaleX && scaleX.constructor === Function && scaleX.domain ? scaleX.domain() : rangeX;
}
function createFuncLine(_props, section, outputSettings) {
  const props = parseFuncLine(_props, section);
  const lineCoordinates = generateLineCoordinates(props, section);
  const lineProps = mergeProps(lineCoordinates, props);
  const funcLine = createLine(lineProps, section, outputSettings);
  funcLine.type = "FuncLine";
  return funcLine;
}
function generateLineCoordinates(props, section) {
  const rangeX = section.ranges.rangeX;
  const numberOfPoints = Math.abs(rangeX[0] - rangeX[1]) / props.resolution;
  return interpolatePoints(props.func, props.x, numberOfPoints);
}
function interpolatePoints(func, domainX, numberOfPoints) {
  const points = { x: [], y: [] };
  const delta = (domainX[1] - domainX[0]) / numberOfPoints;
  for (let i2 = 0; i2 <= numberOfPoints; i2++) {
    const x3 = domainX[0] + delta * i2;
    const y3 = func(x3);
    points.x.push(x3);
    points.y.push(y3);
  }
  return points;
}
var POSITIONING_PROPS = /* @__PURE__ */ new Set(["func", "x", "resolution"]);
function mergeProps(lineCoordinates, props) {
  const mergedProps = Object.assign(lineCoordinates, {});
  for (const propName in props) {
    if (!POSITIONING_PROPS.has(propName)) {
      mergedProps[propName] = props[propName];
    }
  }
  mergedProps.curve = linear_default;
  return mergedProps;
}
function createMarkPipeline(props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    labelConnector(props),
    context
  );
}
function createLayerPipeline(props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    labelLayerConnector(props),
    context
  );
}
function labelConnector(props) {
  return function(context) {
    return {
      point(x3, y3) {
        context.translate(x3, y3);
        if (props.rotate) {
          context.rotate(props.rotate);
        }
      }
    };
  };
}
function labelLayerConnector(props) {
  const keys = props.keys;
  const getRotate = aestheticGetter(props.rotate, keys);
  let currentLabel = 0;
  return function(context) {
    return {
      point(x3, y3) {
        const rotate = getRotate(currentLabel);
        context.translate(x3, y3);
        if (rotate) {
          context.rotate(rotate);
        }
        currentLabel++;
      }
    };
  };
}
function parseLabel(props, section) {
  let { parsedProps, scales } = parsePositioning(props, section);
  parsedProps = parseAesthetics$4(props, parsedProps);
  return { props: parsedProps, scales };
}
var parseAestheticsLabel = parseAesthetics$4;
var parseAestheticsLabelLayer = parseAesthetics$4;
function parseAesthetics$4(props, parsedProps) {
  parsedProps = parsedProps ?? {};
  parsedProps.text = fallback(props.text, "Text");
  if (props.rotate)
    parsedProps.rotate = props.rotate;
  parsedProps.anchorPoint = fallback(props.anchorPoint, "center");
  parsedProps.fontSize = fallback(props.fontSize, 16);
  parsedProps.fontFamily = fallback(props.fontFamily, "Helvetica");
  parsedProps.fontWeight = fallback(props.fontWeight, "normal");
  return parseAesthetics$1(props, parsedProps);
}
var markStyler$2 = {
  apply(context, props) {
    const font = getFont(props);
    const anchorPoint = getAnchorPoint(props);
    const strokeStyle = getStrokeStyle(props);
    const fillStyle = getFillStyle(props);
    applyStyling$2(
      context,
      font,
      anchorPoint,
      fillStyle,
      props.text,
      strokeStyle,
      props.strokeWidth
    );
  }
};
var layerStyler$2 = {
  create(props) {
    const keys = props.keys;
    const getAesthetics = batchAestheticGetter(
      props,
      AESTHETICS$2,
      keys
    );
    const getText = aestheticGetter(props.text, keys);
    return function apply(context, i2) {
      const text3 = getText(i2);
      const aesthetics = getAesthetics(i2);
      const font = getFont(aesthetics);
      const anchorPoint = getAnchorPoint(aesthetics);
      const strokeStyle = getStrokeStyle(aesthetics);
      const fillStyle = getFillStyle(aesthetics);
      applyStyling$2(
        context,
        font,
        anchorPoint,
        fillStyle,
        text3,
        strokeStyle,
        aesthetics.strokeWidth
      );
    };
  },
  asOnePath() {
    return false;
  }
};
var AESTHETICS$2 = [
  "fontWeight",
  "fontSize",
  "fontFamily",
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "fill",
  "fillOpacity",
  "opacity",
  "anchorPoint"
];
function applyStyling$2(context, font, anchorPoint, fillStyle, text3, strokeStyle, strokeWidth) {
  context.font = font;
  context.textBaseline = anchorPoint.textBaseline;
  context.textAlign = anchorPoint.textAlign;
  if (fillStyle) {
    context.fillStyle = fillStyle;
    context.fillText(text3, 0, 0);
  }
  if (strokeStyle) {
    context.lineWidth = strokeWidth;
    context.strokeStyle = strokeStyle;
    context.strokeText(text3, 0, 0);
  }
  context.setTransform(1, 0, 0, 1, 0, 0);
}
function createLabel(_props, section, outputSettings) {
  const { props, scales } = parseLabel(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$3(props, section, scales, outputSettings);
  return new Mark(
    positioning,
    props,
    section,
    markStyler$2,
    "Label"
  );
}
function getPositioning$3(props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const markRecorder = recorderLabel();
  const pipeline = createMarkPipeline(props, section, scales, markRecorder, outputSettings);
  if (positioningMethod === "florence") {
    streamPoint(props, pipeline);
  }
  if (positioningMethod === "geojson") {
    streamGeometry(props.geometry, pipeline);
  }
  return markRecorder.result();
}
function createLabelLayer(_props, section, outputSettings) {
  const { props, scales } = parseLabel(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$4(props, section, scales, outputSettings);
  return new Layer(
    positioning,
    props,
    section,
    layerStyler$2,
    "Label"
  );
}
function getPositioning$4(props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const layerRecorder = recorderLabelLayer();
  const pipeline = createLayerPipeline(props, section, scales, layerRecorder, outputSettings);
  if (positioningMethod === "florence") {
    streamPointLayer(props, pipeline);
  }
  if (positioningMethod === "geojson") {
    streamGeometries(props.geometry, pipeline);
  }
  return layerRecorder.result();
}
function createLineLayer(_props, section, outputSettings) {
  const { props, scales } = parseLine(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$5(props, section, scales, outputSettings);
  return new Layer(
    positioning,
    props,
    section,
    layerStyler$1,
    "Line"
  );
}
function getPositioning$5(props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const layerRecorder = recorderLayer();
  const pipeline = createPipeline$3(props, section, scales, layerRecorder, outputSettings);
  if (positioningMethod === "florence") {
    streamLineLayer(props, pipeline);
  }
  if (positioningMethod === "geojson") {
    streamGeometries(props.geometry, pipeline);
  }
  return layerRecorder.result();
}
function createMarkPipeline$1(props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    pointConnector(props),
    context
  );
}
function createLayerPipeline$1(props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    round(outputSettings.decimals),
    pointLayerConnector(props),
    context
  );
}
var TAU = 2 * Math.PI;
function pointConnector(props) {
  return function(context) {
    return {
      point(x3, y3) {
        context.arc(x3, y3, props.radius, 0, TAU);
      }
    };
  };
}
function pointLayerConnector(props) {
  const keys = props.keys;
  const getRadius = aestheticGetter(props.radius, keys);
  let currentPoint = 0;
  return function(context) {
    return {
      point(x3, y3) {
        const radius = getRadius(currentPoint);
        context.moveTo(x3 + radius, y3);
        context.arc(x3, y3, radius, 0, TAU);
        currentPoint++;
      }
    };
  };
}
function createPoint(_props, section, context, outputSettings) {
  const { props, scales } = parsePoint(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$6(props, section, scales, outputSettings);
  return new Mark(
    positioning,
    props,
    section,
    markStyler,
    "Point"
  );
}
function getPositioning$6(props, section, scales, outputSettings) {
  const markRecorder = recorderMark();
  stream(props, section, scales, markRecorder, outputSettings);
  return markRecorder.result();
}
function stream(props, section, scales, context, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const pipeline = createMarkPipeline$1(props, section, scales, context, outputSettings);
  if (positioningMethod === "florence") {
    streamPoint(props, pipeline);
  }
  if (positioningMethod === "geojson") {
    streamGeometry(props.geometry, pipeline);
  }
}
function createPointLayer(_props, section, outputSettings) {
  const { props, scales } = parsePoint(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$7(props, section, scales, outputSettings);
  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    "Point"
  );
}
function getPositioning$7(props, section, scales, outputSettings) {
  const layerRecorder = recorderLayer();
  stream$1(props, section, scales, layerRecorder, outputSettings);
  return layerRecorder.result();
}
function stream$1(props, section, scales, context, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const pipeline = createLayerPipeline$1(props, section, scales, context, outputSettings);
  if (positioningMethod === "florence") {
    streamPointLayer(props, pipeline);
  }
  if (positioningMethod === "geojson") {
    streamGeometries(props.geometry, pipeline);
  }
}
function createPolygon(_props, section, outputSettings) {
  const { props, scales } = parsePolygon(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$8(props, section, scales, outputSettings);
  return new Mark(
    positioning,
    props,
    section,
    markStyler,
    "Polygon"
  );
}
function getPositioning$8(props, section, scales, outputSettings) {
  const markRecorder = recorderMark();
  stream$2(props, section, scales, markRecorder, outputSettings);
  return markRecorder.result();
}
function stream$2(props, section, scales, context, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const pipeline = createPipeline$1(props, section, scales, context, outputSettings);
  if (positioningMethod === "florence") {
    streamPolygon(props, pipeline);
  }
  if (positioningMethod === "geojson") {
    streamGeometry(props.geometry, pipeline);
  }
}
function createPolygonLayer(_props, section, context, outputSettings) {
  const { props, scales } = parsePolygon(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$9(props, section, scales, outputSettings);
  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    "Polygon"
  );
}
function getPositioning$9(props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const layerRecorder = recorderLayer();
  const pipeline = createPipeline$1(props, section, scales, layerRecorder, outputSettings);
  if (positioningMethod === "florence") {
    streamPolygonLayer(props, pipeline);
  }
  if (positioningMethod === "geojson") {
    streamGeometries(props.geometry, pipeline);
  }
  return layerRecorder.result();
}
var parseRectangle = parser(parsePositioning$1);
var parseRectangleLayer = parser(parsePositioningLayer);
function parsePositioning$1({ x1, x2: x23, y1, y2: y23 }, section) {
  const rangeX = section.scaleX.range();
  const rangeY = section.scaleY.range();
  return {
    x1: isDefined(x1) ? getCoordX$1(x1, section) : rangeX[0],
    x2: isDefined(x23) ? getCoordX$1(x23, section) : rangeX[1],
    y1: isDefined(y1) ? getCoordY$1(y1, section) : rangeY[0],
    y2: isDefined(y23) ? getCoordY$1(y23, section) : rangeY[1]
  };
}
var parseAestheticsRectangle = parseAesthetics$1;
var parseAestheticsRectangleLayer = parseAesthetics$1;
function parsePositioningLayer(props, section) {
  const length = getLength(props);
  const { x1, x2: x23, y1, y2: y23 } = props;
  const rangeX = section.scaleX.range();
  const rangeY = section.scaleY.range();
  return {
    x1: isDefined(x1) ? getCoordsX$1(x1, section) : repeat(rangeX[0], length),
    x2: isDefined(x23) ? getCoordsX$1(x23, section) : repeat(rangeX[1], length),
    y1: isDefined(y1) ? getCoordsY$1(y1, section) : repeat(rangeY[0], length),
    y2: isDefined(y23) ? getCoordsY$1(y23, section) : repeat(rangeY[1], length)
  };
}
function parser(positioningFn) {
  return function(props, section) {
    const parsedProps = positioningFn(props, section);
    parseAesthetics$1(props, parsedProps);
    return parsedProps;
  };
}
var getCoordX$1 = coordGetter$1("scaleX");
var getCoordY$1 = coordGetter$1("scaleY");
function coordGetter$1(scale2) {
  return function(coord, section) {
    if (propBypassesScaling(coord)) {
      return coord(section);
    }
    return section[scale2](coord);
  };
}
var getCoordsX$1 = coordsGetter$1("scaleX");
var getCoordsY$1 = coordsGetter$1("scaleY");
function coordsGetter$1(scale2) {
  return function(coord, section) {
    if (propBypassesScaling(coord)) {
      return coord(section);
    }
    return coord.map(section[scale2]);
  };
}
var LENGTH_PROPS = ["x1", "x2", "y1", "y2", "key"];
function getLength(props) {
  for (const propName of LENGTH_PROPS) {
    const prop = props[propName];
    if (prop && prop.constructor === Array) {
      return prop.length;
    }
  }
}
function createRectangle(_props, section, outputSettings) {
  const props = parseRectangle(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$a(props, section, outputSettings);
  return new Mark(
    positioning,
    props,
    section,
    markStyler,
    "Rectangle"
  );
}
function getPositioning$a(props, section, outputSettings) {
  const markRecorder = recorderMark();
  const pipeline = createPipeline$2(props, section, section.indirectScales, markRecorder, outputSettings);
  streamRectangle(props, pipeline);
  return markRecorder.result();
}
function createRectangleLayer(_props, section, outputSettings) {
  const props = parseRectangleLayer(_props, section);
  outputSettings = parseOutputSettings(outputSettings);
  const positioning = getPositioning$b(props, section, outputSettings);
  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    "Rectangle"
  );
}
function getPositioning$b(props, section, outputSettings) {
  const layerRecorder = recorderLayer();
  const pipeline = createPipeline$2(props, section, section.indirectScales, layerRecorder, outputSettings);
  streamRectangleLayer(props, pipeline);
  return layerRecorder.result();
}
function parseSymbol(props, section) {
  const parsedProps = parsePositioning$2(props);
  parseAesthetics$5(props, parsedProps);
  return parsedProps;
}
var parseAestheticsSymbol = parseAesthetics$5;
var parseAestheticsSymbolLayer = parseAesthetics$5;
function parsePositioning$2(props, section) {
  return {
    x: props.x,
    y: props.y
  };
}
function parseAesthetics$5(props, parsedProps) {
  parsedProps = parsedProps ?? {};
  parsedProps.shape = fallback(props.shape, "circle");
  parsedProps.radius = fallback(props.radius, 3);
  return parseAesthetics$1(props, parsedProps);
}
function createScales({ scaleX, scaleY }, { rangeX, rangeY }, { addInvert } = {}) {
  return {
    x: createScale(scaleX, rangeX, addInvert),
    y: createScale(scaleY, rangeY, addInvert)
  };
}
function createScale(scale2, range, addInvert) {
  if (scale2.constructor === Array) {
    return linear().domain(scale2).range(range);
  }
  const newScale = scale2.copy().range(range);
  if (addInvert) {
    newScale.invert = createInvertMethod(newScale);
  }
  return newScale;
}
function createInvertMethod(scale2) {
  if (scale2.invert) {
    return scale2.invert;
  }
  return function invert(value) {
    const [lower, upper] = scale2.range();
    const start = Math.min(lower, upper);
    const stop = Math.max(lower, upper);
    const flipped = upper < lower;
    const domain = scale2.domain();
    const lastIndex = domain.length - 1;
    if (value < start + scale2.padding() * scale2.step()) {
      return domain[0];
    }
    if (value > stop - scale2.padding() * scale2.step()) {
      return domain[lastIndex];
    }
    let index;
    if (isPointScale(scale2)) {
      index = Math.round((value - start - scale2.padding() * scale2.step()) / scale2.step());
    }
    if (isBandScale(scale2)) {
      index = Math.floor((value - start - scale2.padding() * scale2.step()) / scale2.step());
      if (index > lastIndex)
        index = lastIndex;
    }
    return domain[flipped ? lastIndex - index : index];
  };
}
function isPointScale(scale2) {
  return !("paddingInner" in scale2);
}
function isBandScale(scale2) {
  return "paddingInner" in scale2;
}
function cartesian() {
  return function(props, sectionData) {
    const { ranges } = sectionData;
    const scales = parseScales(props, DEFAULT_DOMAINS);
    const { x: scaleX, y: scaleY } = createScales(scales, DEFAULT_RANGES);
    const directScales = createScales(scales, ranges, { addInvert: true });
    const indirectScales = createScales(DEFAULT_DOMAINS, ranges);
    const inverseTotalTransformation = ([x3, y3]) => [
      directScales.x.invert(x3),
      directScales.y.invert(y3)
    ];
    return {
      ...sectionData,
      type: "cartesian",
      scaleX,
      scaleY,
      directScales,
      indirectScales,
      inverseTotalTransformation,
      bwx: scaleX.bandwidth,
      bwy: scaleY.bandwidth,
      px: getPixelMethod(ranges.rangeX),
      py: getPixelMethod(ranges.rangeY),
      pxAt: indirectScales.x.invert,
      pyAt: indirectScales.y.invert
    };
  };
}
function parseScales(props, defaultDomains) {
  return {
    scaleX: props.scaleX ?? defaultDomains.scaleX,
    scaleY: props.scaleY ?? defaultDomains.scaleY
  };
}
var DEFAULT_RANGES = {
  rangeX: [0, 1],
  rangeY: [0, 1]
};
var DEFAULT_DOMAINS = {
  scaleX: [0, 1],
  scaleY: [0, 1]
};
function getPixelMethod([a3, b2]) {
  const factor = b2 - a3;
  if (factor === 0)
    return () => 0;
  return (v2) => v2 / factor;
}
function parseSection(props, parentSection) {
  const positioning = getPositioning$c(props, parentSection);
  return {
    ...positioning,
    coordinates: fallback(props.coordinates, cartesian()),
    scaleX: props.scaleX,
    scaleY: props.scaleY,
    flipX: fallback(props.flipX, false),
    flipY: fallback(props.flipY, false),
    padding: fallback(props.padding, 0),
    zoomIdentity: props.zoomIdentity,
    clip: fallback(props.clip, "padding"),
    id: props.id
  };
}
function getPositioning$c(props, parentSection) {
  if (!parentSection) {
    return {
      x1: props.x1,
      x2: props.x2,
      y1: props.y1,
      y2: props.y2
    };
  }
  const positioning = parsePositioning$1(props, parentSection);
  const { x: x3, y: y3 } = parentSection.indirectScales;
  return {
    x1: x3(positioning.x1),
    x2: x3(positioning.x2),
    y1: y3(positioning.y1),
    y2: y3(positioning.y2)
  };
}
function parsePadding(_padding) {
  const padding = _padding === void 0 ? 0 : _padding;
  if (padding.constructor === Number) {
    return { left: padding, right: padding, top: padding, bottom: padding };
  }
  if (padding.constructor === Object) {
    return Object.assign(
      parsePadding(0),
      padding
    );
  }
  throw invalidPaddingError;
}
var invalidPaddingError = new Error("Invalid padding specification");
function applyPadding(range, offsetMin, offsetMax) {
  warnIfPaddingSmallerThanRange(range, offsetMin, offsetMax);
  if (range[0] < range[1]) {
    return [range[0] + offsetMin, range[1] - offsetMax];
  } else {
    return [range[0] - offsetMax, range[1] + offsetMin];
  }
}
function warnIfPaddingSmallerThanRange(range, min2, max2) {
  if (Math.abs(range[0] - range[1]) < min2 + max2) {
    console.warn("Padding cannot exceed width or height");
  }
}
function getRanges(props, padding) {
  const { flipX, flipY, zoomIdentity } = props;
  let { rangeX, rangeY } = initRanges(props);
  const { left, right, top, bottom } = padding;
  rangeX = applyFlip(rangeX, flipX);
  rangeX = applyPadding(rangeX, left, right);
  if (zoomIdentity) {
    validateZoomFactor(zoomIdentity.kx);
    rangeX = applyZoom(rangeX, zoomIdentity.kx, zoomIdentity.x);
  }
  rangeY = applyFlip(rangeY, flipY);
  rangeY = applyPadding(rangeY, top, bottom);
  if (zoomIdentity) {
    validateZoomFactor(zoomIdentity.ky);
    rangeY = applyZoom(rangeY, zoomIdentity.ky, zoomIdentity.y);
  }
  return { rangeX, rangeY };
}
function initRanges(props) {
  return {
    rangeX: [props.x1, props.x2],
    rangeY: [props.y1, props.y2]
  };
}
function applyFlip(range, flip) {
  return flip ? [range[1], range[0]] : range;
}
function applyZoom(range, k3, translate) {
  return [
    range[0] * k3 + translate,
    range[1] * k3 + translate
  ];
}
function validateZoomFactor(k3) {
  if (k3 < 0)
    throw new Error("Zoom factors have to be positive");
}
var idCounter = 0;
function getId$2() {
  return "sc" + idCounter++;
}
function createSection(_props, parentSection) {
  if (parentSection && parentSection.type !== "cartesian") {
    throw new Error("Cannot nest section inside other section with polar coordinates");
  }
  const props = parseSection(_props, parentSection);
  const id = props.id ? props.id : getId$2();
  const padding = parsePadding(props.padding);
  const zoomIdentity = parseZoomIdentity(props.zoomIdentity);
  const ranges = getRanges(props, padding);
  const bbox = clampBbox(getBbox$3(props), parentSection);
  const paddedBbox = clampBbox(getPaddedBbox(bbox, padding), parentSection);
  return props.coordinates(props, {
    id,
    padding,
    zoomIdentity,
    ranges,
    bbox,
    paddedBbox,
    clip: props.clip
  });
}
function parseZoomIdentity(zoomIdentity) {
  return Object.assign({ x: 0, y: 0, kx: 1, ky: 1 }, zoomIdentity);
}
function getBbox$3({ x1, x2: x23, y1, y2: y23 }) {
  return {
    minX: Math.min(x1, x23),
    maxX: Math.max(x1, x23),
    minY: Math.min(y1, y23),
    maxY: Math.max(y1, y23)
  };
}
function getPaddedBbox({ minX, maxX, minY, maxY }, { left, right, top, bottom }) {
  return {
    minX: minX + left,
    maxX: maxX - right,
    minY: minY + top,
    maxY: maxY - bottom
  };
}
function clampBbox(bbox, parentSection) {
  if (!parentSection)
    return bbox;
  const parentBbox = parentSection.clip === "padding" ? parentSection.paddedBbox : parentSection.bbox;
  return {
    minX: Math.max(bbox.minX, parentBbox.minX),
    maxX: Math.min(bbox.maxX, parentBbox.maxX),
    minY: Math.max(bbox.minY, parentBbox.minY),
    maxY: Math.min(bbox.maxY, parentBbox.maxY)
  };
}
function createPointSection(props, parentSection) {
  const sectionPositioning = getSectionPositioning(props, parentSection);
  const mergedProps = mergeProps$1(sectionPositioning, props);
  return createSection(mergedProps);
}
function getSectionPositioning(props, parentSection) {
  const dx = props.width / 2;
  const dy = props.height / 2;
  if (!parentSection) {
    const { x: x3, y: y3 } = props;
    return {
      x1: x3 - dx,
      x2: x3 + dx,
      y1: y3 - dy,
      y2: y3 + dy
    };
  }
  const pointPositioningContext = circle();
  const { scales } = parsePositioning(props, parentSection);
  stream(props, parentSection, scales, pointPositioningContext, parseOutputSettings());
  const { cx, cy } = pointPositioningContext.result();
  return {
    x1: cx - dx,
    x2: cx + dx,
    y1: cy - dy,
    y2: cy + dy
  };
}
function mergeProps$1(sectionPositioning, props) {
  for (const propName in props) {
    if (!(propName in sectionPositioning)) {
      sectionPositioning[propName] = props[propName];
    }
  }
  return sectionPositioning;
}
var shapes = {
  square: [
    [-1, -1],
    [1, -1],
    [1, 1],
    [-1, 1],
    [-1, -1]
  ],
  cross: [
    [-0.5, -1],
    [0.5, -1],
    [0.5, -0.5],
    [1, -0.5],
    [1, 0.5],
    [0.5, 0.5],
    [0.5, 1],
    [-0.5, 1],
    [-0.5, 0.5],
    [-1, 0.5],
    [-1, -0.5],
    [-0.5, -0.5],
    [-0.5, -1]
  ],
  "cross-sharp": [
    [0, -1],
    [0.2, -0.2],
    [1, 0],
    [0.2, 0.2],
    [0, 1],
    [-0.2, 0.2],
    [-1, 0],
    [-0.2, -0.2],
    [0, -1]
  ],
  diamond: [
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 0],
    [0, -1]
  ],
  "triangle-up": [
    [0, -1],
    [1, 1],
    [-1, 1],
    [0, -1]
  ],
  "triangle-down": [
    [1, -1],
    [0, 1],
    [-1, -1],
    [1, -1]
  ],
  "triangle-right": [
    [-1, -1],
    [1, 0],
    [-1, 1],
    [-1, -1]
  ],
  "triangle-left": [
    [1, -1],
    [-1, 0],
    [1, 1],
    [1, -1]
  ],
  star4: [
    [0, 0.71],
    [1, 1],
    [0.71, 0],
    [1, -1],
    [0, -0.71],
    [-1, -1],
    [-0.71, 0],
    [-1, 1],
    [0, 0.71]
  ],
  star5: [
    [0, 0.5],
    [0.6, 0.8],
    [0.5, 0.1],
    [1, -0.3],
    [0.3, -0.4],
    [0, -1],
    [-0.3, -0.4],
    [-1, -0.3],
    [-0.5, 0.1],
    [-0.6, 0.8],
    [0, 0.5]
  ],
  star: [
    [0, 0.5],
    [0.6, 0.8],
    [0.5, 0.1],
    [1, -0.3],
    [0.3, -0.4],
    [0, -1],
    [-0.3, -0.4],
    [-1, -0.3],
    [-0.5, 0.1],
    [-0.6, 0.8],
    [0, 0.5]
  ],
  star6: [
    [0, 0.58],
    [0.5, 1],
    [0.43, 0.29],
    [1, 0],
    [0.43, -0.29],
    [0.5, -1],
    [0, -0.58],
    [-0.5, -1],
    [-0.43, -0.29],
    [-1, 0],
    [-0.43, 0.29],
    [-0.5, 1],
    [0, 0.58]
  ],
  star8: [
    [0, 0.54],
    [0.41, 1],
    [0.38, 0.38],
    [1, 0.41],
    [0.54, 0],
    [1, -0.41],
    [0.38, -0.38],
    [0.41, -1],
    [0, -0.54],
    [-0.41, -1],
    [-0.38, -0.38],
    [-1, -0.41],
    [-0.54, 0],
    [-1, 0.41],
    [-0.38, 0.38],
    [-0.41, 1],
    [0, 0.54]
  ],
  pentagon: [
    [-1, -0.24],
    [0, -1],
    [1, -0.24],
    [0.62, 1],
    [-0.62, 1],
    [-1, -0.24]
  ],
  hexagon: [
    [-1, 0],
    [-0.57, -1],
    [0.57, -1],
    [1, 0],
    [0.57, 1],
    [-0.57, 1],
    [-1, 0]
  ],
  heptagon: [
    [-1, 0.29],
    [-0.8, -0.6],
    [0, -1],
    [0.8, -0.6],
    [1, 0.29],
    [0.45, 1],
    [-0.45, 1],
    [-1, 0.29]
  ],
  septagon: [
    [-1, 0.29],
    [-0.8, -0.6],
    [0, -1],
    [0.8, -0.6],
    [1, 0.29],
    [0.45, 1],
    [-0.45, 1],
    [-1, 0.29]
  ],
  octagon: [
    [-1, -0.41],
    [-0.41, -1],
    [0.41, -1],
    [1, -0.41],
    [1, 0.41],
    [0.41, 1],
    [-0.41, 1],
    [-1, 0.41],
    [-1, -0.41]
  ],
  nonagon: [
    [0.35, -1],
    [0.88, -0.55],
    [1, 0.15],
    [0.65, 0.76],
    [0, 1],
    [-0.65, 0.76],
    [-1, 0.15],
    [-0.88, -0.55],
    [-0.35, -1],
    [0.35, -1]
  ],
  decagon: [
    [-1, 0],
    [-0.81, -0.62],
    [-0.31, -1],
    [0.31, -1],
    [0.81, -0.62],
    [1, 0],
    [0.81, 0.62],
    [0.31, 1],
    [-0.31, 1],
    [-0.81, 0.62],
    [-1, 0]
  ]
};
function createSymbol(_props, section, outputSettings) {
  const props = parseSymbol(_props);
  if (props.shape === "circle") {
    return createPoint(props, section);
  }
  const pointSection = createPointSection({
    x: props.x,
    y: props.y,
    width: props.radius * 2,
    height: props.radius * 2,
    scaleX: [-1, 1],
    scaleY: [-1, 1]
  }, section);
  const geometry = shapeToGeometry(props.shape);
  const polygonProps = mergeProps$2({ geometry }, props);
  const symbol = createPolygon(polygonProps, pointSection, outputSettings);
  symbol.type = "Symbol";
  return symbol;
}
function shapeToGeometry(shape) {
  return shape in shapes ? asPolygon(shapes[shape]) : shape;
}
function asPolygon(coordinates) {
  return {
    type: "Polygon",
    coordinates: [coordinates]
  };
}
var NOT_ALLOWED_PROPS = /* @__PURE__ */ new Set(["x", "y", "shape", "radius"]);
function mergeProps$2(newProps, props) {
  for (const propName in props) {
    if (!NOT_ALLOWED_PROPS.has(propName)) {
      newProps[propName] = props[propName];
    }
  }
  return newProps;
}
function createSymbolLayer(_props, section, outputSettings) {
  const props = parseSymbol(_props);
  outputSettings = parseOutputSettings(outputSettings);
  const pointPositioningContext = circleLayer();
  const { scales: pointScales } = parsePositioning(_props, section);
  stream$1(props, section, pointScales, pointPositioningContext, outputSettings);
  const coordinates = pointPositioningContext.result();
  const layerRecorder = recorderLayer();
  streamSymbolLayer(coordinates, props, section, layerRecorder, outputSettings);
  const positioning = layerRecorder.result();
  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    "Symbol"
  );
}
function streamSymbolLayer(coordinates, props, section, context, outputSettings) {
  const keys = props.keys;
  const getShape = aestheticGetter(props.shape, keys);
  const getRadius = aestheticGetter(props.radius, keys);
  for (let i2 = 0; i2 < coordinates.length; i2++) {
    const shape = getShape(i2);
    const radius = getRadius(i2);
    if (shape === "circle") {
      streamCircle(coordinates[i2], radius, context);
      context.markEnd();
    }
    if (shape !== "circle") {
      const geometry = shapeToGeometry(shape);
      const scales = {
        x: createScale$1(coordinates[i2].cx, radius),
        y: createScale$1(coordinates[i2].cy, radius)
      };
      const pipeline = createPipeline$1(props, {}, scales, context, outputSettings);
      streamGeometry(geometry, pipeline, i2);
      pipeline.markEnd();
    }
  }
}
var TAU$1 = Math.PI * 2;
function streamCircle(c2, radius, context, i2) {
  context.moveTo(c2.cx + radius, c2.cy);
  context.arc(c2.cx, c2.cy, radius, 0, TAU$1);
}
function createScale$1(c2, r2) {
  return linear().domain([0, 1]).range([c2, r2 + c2]);
}
function polar(options2) {
  options2 = parseOptions(options2);
  return function(props, sectionData) {
    const scales = parseScales(props, DEFAULT_DOMAINS);
    const polarRanges = getPolarRanges(DEFAULT_RANGES, options2);
    const directScales = createScales(scales, polarRanges, { addInvert: true });
    const { x: scaleX, y: scaleY } = createScales(scales, DEFAULT_RANGES);
    const indirectScales = createScales(DEFAULT_DOMAINS, polarRanges);
    const { ranges } = sectionData;
    const coordinateSystem = createCoordinateSystem(ranges);
    const inverseTotalTransformation = ([x3, y3]) => [
      directScales.x.invert(coordinateSystem.invertX(x3, y3)),
      directScales.y.invert(coordinateSystem.invertY(x3, y3))
    ];
    return {
      ...sectionData,
      type: "polar",
      scaleX,
      scaleY,
      directScales,
      indirectScales,
      coordinateSystem,
      inverseTotalTransformation,
      bwx: scaleX.bandwidth,
      bwy: scaleY.bandwidth
    };
  };
}
var TWO_PI$3 = Math.PI * 2;
var HALF_PI$1 = Math.PI / 2;
function parseOptions(options2) {
  const DEFAULT_OPTIONS = {
    startAngle: -HALF_PI$1,
    endAngle: TWO_PI$3 - HALF_PI$1
  };
  if (!options2)
    return DEFAULT_OPTIONS;
  return Object.assign(DEFAULT_OPTIONS, options2);
}
function getPolarRanges(ranges, options2) {
  return {
    rangeX: [options2.startAngle, options2.endAngle],
    rangeY: ranges.rangeY
  };
}
function createCoordinateSystem(ranges) {
  const { rangeX, rangeY } = ranges;
  const halfWidth = getHalfDist(rangeX);
  const halfHeight = getHalfDist(rangeY);
  const midX = getMid(rangeX, halfWidth);
  const midY = getMid(rangeY, halfHeight);
  const scales = createScales(
    { scaleX: [-1, 1], scaleY: [-1, 1] },
    ranges
  );
  return {
    midX,
    midY,
    halfWidth,
    halfHeight,
    flipX: rangeX[0] > rangeX[1],
    flipY: rangeY[0] > rangeY[1],
    x: (theta, r2) => scales.x(r2 * Math.cos(theta)),
    y: (theta, r2) => scales.y(r2 * Math.sin(theta)),
    invertX: createInvertX(scales),
    invertY: createInvertY(scales)
  };
}
function getHalfDist(range) {
  return Math.abs(range[0] - range[1]) / 2;
}
function getMid([a3, b2], extent) {
  return a3 < b2 ? a3 + extent : b2 + extent;
}
function createInvertX(scales) {
  return (x3, y3) => {
    const scaledBackX = scales.x.invert(x3);
    const scaledBackY = scales.y.invert(y3);
    const theta = Math.atan(scaledBackY / scaledBackX);
    const quadrant = getQuadrant$1(scaledBackX, scaledBackY);
    switch (quadrant) {
      case 1:
        return theta;
      case 2:
        return theta + Math.PI;
      case 3:
        return theta + Math.PI;
      case 4:
        return theta + TWO_PI$3;
    }
  };
}
function createInvertY(scales) {
  return (x3, y3) => {
    const scaledBackX = scales.x.invert(x3);
    const scaledBackY = scales.y.invert(y3);
    return Math.sqrt(scaledBackX ** 2 + scaledBackY ** 2);
  };
}
function getQuadrant$1(x3, y3) {
  if (x3 >= 0 && y3 >= 0)
    return 1;
  if (x3 < 0 && y3 >= 0)
    return 2;
  if (x3 < 0 && y3 < 0)
    return 3;
  if (x3 >= 0 && y3 < 0)
    return 4;
}

// node_modules/@snlab/florence/src/components/core/_Clipper.svelte
var file = "node_modules/@snlab/florence/src/components/core/_Clipper.svelte";
function create_fragment(ctx2) {
  let clipPath0;
  let rect0;
  let t2;
  let clipPath1;
  let rect1;
  let clipPath1_id_value;
  let rect0_levels = [
    /*paddingClipRect*/
    ctx2[2]
  ];
  let rect_data_1 = {};
  for (let i2 = 0; i2 < rect0_levels.length; i2 += 1) {
    rect_data_1 = assign(rect_data_1, rect0_levels[i2]);
  }
  let rect1_levels = [
    /*outerClipRect*/
    ctx2[0]
  ];
  let rect_data = {};
  for (let i2 = 0; i2 < rect1_levels.length; i2 += 1) {
    rect_data = assign(rect_data, rect1_levels[i2]);
  }
  const block = {
    c: function create() {
      clipPath0 = svg_element("clipPath");
      rect0 = svg_element("rect");
      t2 = space();
      clipPath1 = svg_element("clipPath");
      rect1 = svg_element("rect");
      set_svg_attributes(rect0, rect_data_1);
      add_location(rect0, file, 12, 2, 332);
      attr_dev(
        clipPath0,
        "id",
        /*paddingClipId*/
        ctx2[3]
      );
      add_location(clipPath0, file, 11, 0, 300);
      set_svg_attributes(rect1, rect_data);
      add_location(rect1, file, 16, 2, 415);
      attr_dev(clipPath1, "id", clipPath1_id_value = `clip-${/*outerClipId*/
      ctx2[1]}`);
      add_location(clipPath1, file, 15, 0, 375);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, clipPath0, anchor);
      append_dev(clipPath0, rect0);
      insert_dev(target, t2, anchor);
      insert_dev(target, clipPath1, anchor);
      append_dev(clipPath1, rect1);
    },
    p: function update(ctx3, [dirty]) {
      set_svg_attributes(rect0, rect_data_1 = get_spread_update(rect0_levels, [dirty & /*paddingClipRect*/
      4 && /*paddingClipRect*/
      ctx3[2]]));
      if (dirty & /*paddingClipId*/
      8) {
        attr_dev(
          clipPath0,
          "id",
          /*paddingClipId*/
          ctx3[3]
        );
      }
      set_svg_attributes(rect1, rect_data = get_spread_update(rect1_levels, [dirty & /*outerClipRect*/
      1 && /*outerClipRect*/
      ctx3[0]]));
      if (dirty & /*outerClipId*/
      2 && clipPath1_id_value !== (clipPath1_id_value = `clip-${/*outerClipId*/
      ctx3[1]}`)) {
        attr_dev(clipPath1, "id", clipPath1_id_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(clipPath0);
        detach_dev(t2);
        detach_dev(clipPath1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let paddingClipId;
  let paddingClipRect;
  let outerClipId;
  let outerClipRect;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Clipper", slots, []);
  let { section } = $$props;
  $$self.$$.on_mount.push(function() {
    if (section === void 0 && !("section" in $$props || $$self.$$.bound[$$self.$$.props["section"]])) {
      console.warn("<Clipper> was created without expected prop 'section'");
    }
  });
  const writable_props = ["section"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Clipper> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(4, section = $$props2.section);
  };
  $$self.$capture_state = () => ({
    bboxToClipRect,
    section,
    outerClipRect,
    outerClipId,
    paddingClipRect,
    paddingClipId
  });
  $$self.$inject_state = ($$props2) => {
    if ("section" in $$props2)
      $$invalidate(4, section = $$props2.section);
    if ("outerClipRect" in $$props2)
      $$invalidate(0, outerClipRect = $$props2.outerClipRect);
    if ("outerClipId" in $$props2)
      $$invalidate(1, outerClipId = $$props2.outerClipId);
    if ("paddingClipRect" in $$props2)
      $$invalidate(2, paddingClipRect = $$props2.paddingClipRect);
    if ("paddingClipId" in $$props2)
      $$invalidate(3, paddingClipId = $$props2.paddingClipId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*section*/
    16) {
      $:
        $$invalidate(3, paddingClipId = `clip-padding-${section.id}`);
    }
    if ($$self.$$.dirty & /*section*/
    16) {
      $:
        $$invalidate(2, paddingClipRect = bboxToClipRect(section.paddedBbox));
    }
    if ($$self.$$.dirty & /*section*/
    16) {
      $:
        $$invalidate(1, outerClipId = `clip-outer-${section.id}`);
    }
    if ($$self.$$.dirty & /*section*/
    16) {
      $:
        $$invalidate(0, outerClipRect = bboxToClipRect(section.bbox));
    }
  };
  return [outerClipRect, outerClipId, paddingClipRect, paddingClipId, section];
}
var Clipper = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance, create_fragment, safe_not_equal, { section: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Clipper",
      options: options2,
      id: create_fragment.name
    });
  }
  get section() {
    throw new Error("<Clipper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set section(value) {
    throw new Error("<Clipper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Clipper_default = Clipper;

// node_modules/@snlab/florence/src/components/marks/utils/any.js
function any_default(...args) {
  for (const arg of args) {
    if (arg !== void 0)
      return true;
  }
  return false;
}

// node_modules/@snlab/florence/src/components/marks/utils/merge.js
function merge(obj1, obj2) {
  const merged = Object.assign(obj1, {});
  for (const key in obj2) {
    merged[key] = obj2[key];
  }
  return merged;
}

// node_modules/@snlab/florence/src/helpers/test.js
var TEST_ENV = typeof process !== "undefined" && false;
function testId(input) {
  if (TEST_ENV) {
    return input;
  }
}

// node_modules/@snlab/florence/src/components/marks/base/Mark.svelte
var file2 = "node_modules/@snlab/florence/src/components/marks/base/Mark.svelte";
function create_if_block_1(ctx2) {
  let t2;
  let if_block1_anchor;
  let if_block0 = (
    /*element*/
    ctx2[2] === "path" && create_if_block_3(ctx2)
  );
  let if_block1 = (
    /*element*/
    ctx2[2] === "text" && create_if_block_2(ctx2)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx3, dirty) {
      if (
        /*element*/
        ctx3[2] === "path"
      ) {
        if (if_block0) {
          if_block0.p(ctx3, dirty);
        } else {
          if_block0 = create_if_block_3(ctx3);
          if_block0.c();
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*element*/
        ctx3[2] === "text"
      ) {
        if (if_block1) {
          if_block1.p(ctx3, dirty);
        } else {
          if_block1 = create_if_block_2(ctx3);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(233:0) {#if renderer === 'svg'}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_3(ctx2) {
  let path3;
  let path_clip_path_value;
  let path_data_testid_value;
  let path_levels = [
    /*svgData*/
    ctx2[4],
    { class: (
      /*className*/
      ctx2[1]
    ) },
    {
      "clip-path": path_clip_path_value = getClipPathURL(
        /*aesthetics*/
        ctx2[0],
        /*$section*/
        ctx2[3]
      )
    },
    {
      "data-testid": path_data_testid_value = testId(
        /*className*/
        ctx2[1]
      )
    }
  ];
  let path_data = {};
  for (let i2 = 0; i2 < path_levels.length; i2 += 1) {
    path_data = assign(path_data, path_levels[i2]);
  }
  const block = {
    c: function create() {
      path3 = svg_element("path");
      set_svg_attributes(path3, path_data);
      add_location(path3, file2, 234, 4, 6697);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path3, anchor);
    },
    p: function update(ctx3, dirty) {
      set_svg_attributes(path3, path_data = get_spread_update(path_levels, [
        dirty[0] & /*svgData*/
        16 && /*svgData*/
        ctx3[4],
        dirty[0] & /*className*/
        2 && { class: (
          /*className*/
          ctx3[1]
        ) },
        dirty[0] & /*aesthetics, $section*/
        9 && path_clip_path_value !== (path_clip_path_value = getClipPathURL(
          /*aesthetics*/
          ctx3[0],
          /*$section*/
          ctx3[3]
        )) && { "clip-path": path_clip_path_value },
        dirty[0] & /*className*/
        2 && path_data_testid_value !== (path_data_testid_value = testId(
          /*className*/
          ctx3[1]
        )) && { "data-testid": path_data_testid_value }
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(234:2) {#if element === 'path'}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_2(ctx2) {
  let text_1;
  let t_value = (
    /*svgData*/
    ctx2[4].text + ""
  );
  let t2;
  let text_1_clip_path_value;
  let text_1_data_testid_value;
  let text_1_levels = [
    /*svgData*/
    ctx2[4],
    { text: void 0 },
    { class: (
      /*className*/
      ctx2[1]
    ) },
    {
      "clip-path": text_1_clip_path_value = getClipPathURL(
        /*aesthetics*/
        ctx2[0],
        /*$section*/
        ctx2[3]
      )
    },
    {
      "data-testid": text_1_data_testid_value = testId(
        /*className*/
        ctx2[1]
      )
    }
  ];
  let text_data = {};
  for (let i2 = 0; i2 < text_1_levels.length; i2 += 1) {
    text_data = assign(text_data, text_1_levels[i2]);
  }
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      t2 = text(t_value);
      set_svg_attributes(text_1, text_data);
      add_location(text_1, file2, 243, 4, 6886);
    },
    m: function mount(target, anchor) {
      insert_dev(target, text_1, anchor);
      append_dev(text_1, t2);
    },
    p: function update(ctx3, dirty) {
      if (dirty[0] & /*svgData*/
      16 && t_value !== (t_value = /*svgData*/
      ctx3[4].text + ""))
        set_data_maybe_contenteditable_dev(t2, t_value, text_data["contenteditable"]);
      set_svg_attributes(text_1, text_data = get_spread_update(text_1_levels, [
        dirty[0] & /*svgData*/
        16 && /*svgData*/
        ctx3[4],
        { text: void 0 },
        dirty[0] & /*className*/
        2 && { class: (
          /*className*/
          ctx3[1]
        ) },
        dirty[0] & /*aesthetics, $section*/
        9 && text_1_clip_path_value !== (text_1_clip_path_value = getClipPathURL(
          /*aesthetics*/
          ctx3[0],
          /*$section*/
          ctx3[3]
        )) && { "clip-path": text_1_clip_path_value },
        dirty[0] & /*className*/
        2 && text_1_data_testid_value !== (text_1_data_testid_value = testId(
          /*className*/
          ctx3[1]
        )) && { "data-testid": text_1_data_testid_value }
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(text_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(243:2) {#if element === 'text'}",
    ctx: ctx2
  });
  return block;
}
function create_if_block(ctx2) {
  let t2;
  const block = {
    c: function create() {
      t2 = text(
        /*id*/
        ctx2[9]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(256:0) {#if renderer === 'canvas'}",
    ctx: ctx2
  });
  return block;
}
function create_fragment2(ctx2) {
  let t2;
  let if_block1_anchor;
  let if_block0 = (
    /*renderer*/
    ctx2[5] === "svg" && create_if_block_1(ctx2)
  );
  let if_block1 = (
    /*renderer*/
    ctx2[5] === "canvas" && create_if_block(ctx2)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx3, dirty) {
      if (
        /*renderer*/
        ctx3[5] === "svg"
      )
        if_block0.p(ctx3, dirty);
      if (
        /*renderer*/
        ctx3[5] === "canvas"
      )
        if_block1.p(ctx3, dirty);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
var markId = 0;
var getId2 = () => "m" + markId++;
function instance2($$self, $$props, $$invalidate) {
  let primaryInput2;
  let isInteractiveMouse;
  let isInteractiveTouch;
  let isSelectable;
  let $interactionManager;
  let $globalBlockReindexing;
  let $section;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Mark", slots, []);
  let { positioning } = $$props;
  let { aesthetics } = $$props;
  let { createMark } = $$props;
  let { parseAesthetics: parseAesthetics2 } = $$props;
  let { className } = $$props;
  let { element: element2 = "path" } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const { renderer, marksAndLayers, dirty, globalBlockReindexing } = getContext("graphic");
  validate_store(globalBlockReindexing, "globalBlockReindexing");
  component_subscribe($$self, globalBlockReindexing, (value) => $$invalidate(39, $globalBlockReindexing = value));
  const section = getContext("section");
  validate_store(section, "section");
  component_subscribe($$self, section, (value) => $$invalidate(3, $section = value));
  const interactionManager = getContext("interactionManager");
  validate_store(interactionManager, "interactionManager");
  component_subscribe($$self, interactionManager, (value) => $$invalidate(33, $interactionManager = value));
  const id = getId2();
  const createSVGContext = element2 === "path" ? svgStyled.path : svgStyled.text;
  let mounted;
  onMount(() => {
    mounted = true;
    if (renderer === "canvas") {
      dirty.set(true);
    }
    updateInteractionManagerIfNecessary();
  });
  const isMounted = () => mounted;
  let mark = create();
  marksAndLayers[id] = mark;
  function create() {
    let _mark = createMark(merge(positioning, aesthetics), $section, outputSettings);
    _mark.id = id;
    return _mark;
  }
  let svgContext;
  let svgData;
  if (renderer === "svg") {
    svgContext = createSVGContext();
    mark.render(svgContext);
    svgData = svgContext.result();
  }
  let updatePositioning = false;
  let updateAesthetics = false;
  function scheduleUpdatePositioning() {
    if (isMounted()) {
      $$invalidate(30, updatePositioning = true);
    }
  }
  function scheduleUpdateAesthetics() {
    if (isMounted()) {
      $$invalidate(31, updateAesthetics = true);
    }
  }
  function updateInteractionManagerIfNecessary() {
    if (blockReindexing === void 0) {
      if ($globalBlockReindexing)
        return;
    } else {
      if (blockReindexing === true)
        return;
    }
    if (isInteractiveMouse || isInteractiveTouch) {
      removeMarkFromSpatialIndexIfNecessary();
      if (isInteractiveMouse) {
        const markInterface = $interactionManager.mouse().marks();
        markInterface.loadMark(mark);
        if (onClick)
          markInterface.addMarkInteraction("click", mark, onClick);
        if (onMousedown)
          markInterface.addMarkInteraction("mousedown", mark, onMousedown);
        if (onMouseup)
          markInterface.addMarkInteraction("mouseup", mark, onMouseup);
        if (onMouseout)
          markInterface.addMarkInteraction("mouseout", mark, onMouseout);
        if (onMouseover)
          markInterface.addMarkInteraction("mouseover", mark, onMouseover);
        if (onMousedrag)
          markInterface.addMarkInteraction("mousedrag", mark, onMousedrag);
      }
      if (isInteractiveTouch) {
        const markInterface = $interactionManager.touch().marks();
        markInterface.loadMark(mark);
        if (onTouchdown)
          markInterface.addMarkInteraction("touchdown", mark, onTouchdown);
        if (onTouchup)
          markInterface.addMarkInteraction("touchup", mark, onTouchup);
        if (onTouchover)
          markInterface.addMarkInteraction("touchover", mark, onTouchover);
        if (onTouchout)
          markInterface.addMarkInteraction("touchout", mark, onTouchout);
        if (onTouchdrag)
          markInterface.addMarkInteraction("touchdrag", mark, onTouchdrag);
      }
    }
    removeMarkFromSelectIfNecessary();
    if (isSelectable) {
      const selectManager = $interactionManager.select();
      selectManager.loadMark(mark, { onSelect, onDeselect });
    }
  }
  function removeMarkFromSpatialIndexIfNecessary() {
    if (primaryInput2 === "mouse") {
      const markMouseInterface = $interactionManager.mouse().marks();
      if (markMouseInterface.markIsLoaded(mark)) {
        markMouseInterface.removeAllMarkInteractions(mark);
        markMouseInterface.removeMark(mark);
      }
    }
    if (primaryInput2 === "touch") {
      const markTouchInterface = $interactionManager.touch().marks();
      if (markTouchInterface.markIsLoaded(mark)) {
        markTouchInterface.removeAllMarkInteractions(mark);
        markTouchInterface.removeMark(mark);
      }
    }
  }
  function removeMarkFromSelectIfNecessary() {
    const selectManager = $interactionManager.select();
    if (selectManager.markIsLoaded(mark)) {
      selectManager.removeMark(mark);
    }
  }
  onDestroy(() => {
    if (renderer === "canvas") {
      delete marksAndLayers[id];
      dirty.set(true);
    }
  });
  $$self.$$.on_mount.push(function() {
    if (positioning === void 0 && !("positioning" in $$props || $$self.$$.bound[$$self.$$.props["positioning"]])) {
      console.warn("<Mark> was created without expected prop 'positioning'");
    }
    if (aesthetics === void 0 && !("aesthetics" in $$props || $$self.$$.bound[$$self.$$.props["aesthetics"]])) {
      console.warn("<Mark> was created without expected prop 'aesthetics'");
    }
    if (createMark === void 0 && !("createMark" in $$props || $$self.$$.bound[$$self.$$.props["createMark"]])) {
      console.warn("<Mark> was created without expected prop 'createMark'");
    }
    if (parseAesthetics2 === void 0 && !("parseAesthetics" in $$props || $$self.$$.bound[$$self.$$.props["parseAesthetics"]])) {
      console.warn("<Mark> was created without expected prop 'parseAesthetics'");
    }
    if (className === void 0 && !("className" in $$props || $$self.$$.bound[$$self.$$.props["className"]])) {
      console.warn("<Mark> was created without expected prop 'className'");
    }
  });
  const writable_props = [
    "positioning",
    "aesthetics",
    "createMark",
    "parseAesthetics",
    "className",
    "element",
    "outputSettings",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Mark> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("positioning" in $$props2)
      $$invalidate(10, positioning = $$props2.positioning);
    if ("aesthetics" in $$props2)
      $$invalidate(0, aesthetics = $$props2.aesthetics);
    if ("createMark" in $$props2)
      $$invalidate(11, createMark = $$props2.createMark);
    if ("parseAesthetics" in $$props2)
      $$invalidate(12, parseAesthetics2 = $$props2.parseAesthetics);
    if ("className" in $$props2)
      $$invalidate(1, className = $$props2.className);
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("outputSettings" in $$props2)
      $$invalidate(13, outputSettings = $$props2.outputSettings);
    if ("blockReindexing" in $$props2)
      $$invalidate(14, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(15, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(16, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(17, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(18, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(19, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(20, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(21, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(22, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(23, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(24, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(25, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(26, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(27, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    markId,
    getId: getId2,
    getContext,
    onMount,
    onDestroy,
    svgStyled,
    getClipPathURL,
    any: any_default,
    merge,
    testId,
    positioning,
    aesthetics,
    createMark,
    parseAesthetics: parseAesthetics2,
    className,
    element: element2,
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    renderer,
    marksAndLayers,
    dirty,
    globalBlockReindexing,
    section,
    interactionManager,
    id,
    createSVGContext,
    mounted,
    isMounted,
    mark,
    create,
    svgContext,
    svgData,
    updatePositioning,
    updateAesthetics,
    scheduleUpdatePositioning,
    scheduleUpdateAesthetics,
    updateInteractionManagerIfNecessary,
    removeMarkFromSpatialIndexIfNecessary,
    removeMarkFromSelectIfNecessary,
    primaryInput: primaryInput2,
    isSelectable,
    isInteractiveTouch,
    isInteractiveMouse,
    $interactionManager,
    $globalBlockReindexing,
    $section
  });
  $$self.$inject_state = ($$props2) => {
    if ("positioning" in $$props2)
      $$invalidate(10, positioning = $$props2.positioning);
    if ("aesthetics" in $$props2)
      $$invalidate(0, aesthetics = $$props2.aesthetics);
    if ("createMark" in $$props2)
      $$invalidate(11, createMark = $$props2.createMark);
    if ("parseAesthetics" in $$props2)
      $$invalidate(12, parseAesthetics2 = $$props2.parseAesthetics);
    if ("className" in $$props2)
      $$invalidate(1, className = $$props2.className);
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("outputSettings" in $$props2)
      $$invalidate(13, outputSettings = $$props2.outputSettings);
    if ("blockReindexing" in $$props2)
      $$invalidate(14, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(15, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(16, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(17, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(18, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(19, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(20, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(21, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(22, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(23, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(24, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(25, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(26, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(27, onDeselect = $$props2.onDeselect);
    if ("mounted" in $$props2)
      mounted = $$props2.mounted;
    if ("mark" in $$props2)
      $$invalidate(28, mark = $$props2.mark);
    if ("svgContext" in $$props2)
      $$invalidate(29, svgContext = $$props2.svgContext);
    if ("svgData" in $$props2)
      $$invalidate(4, svgData = $$props2.svgData);
    if ("updatePositioning" in $$props2)
      $$invalidate(30, updatePositioning = $$props2.updatePositioning);
    if ("updateAesthetics" in $$props2)
      $$invalidate(31, updateAesthetics = $$props2.updateAesthetics);
    if ("primaryInput" in $$props2)
      $$invalidate(32, primaryInput2 = $$props2.primaryInput);
    if ("isSelectable" in $$props2)
      isSelectable = $$props2.isSelectable;
    if ("isInteractiveTouch" in $$props2)
      isInteractiveTouch = $$props2.isInteractiveTouch;
    if ("isInteractiveMouse" in $$props2)
      isInteractiveMouse = $$props2.isInteractiveMouse;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*positioning*/
    1024) {
      $: {
        if (positioning) {
          scheduleUpdatePositioning();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*aesthetics*/
    1) {
      $: {
        if (aesthetics) {
          scheduleUpdateAesthetics();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*$section, outputSettings*/
    8200) {
      $: {
        if ($section || outputSettings) {
          scheduleUpdatePositioning();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*updatePositioning, mark, svgContext, parseAesthetics, aesthetics*/
    1879052289 | $$self.$$.dirty[1] & /*updateAesthetics*/
    1) {
      $: {
        if (updatePositioning) {
          $$invalidate(28, mark = create());
          if (renderer === "svg") {
            $$invalidate(29, svgContext = createSVGContext());
            mark.render(svgContext);
            $$invalidate(4, svgData = svgContext.result());
          }
          if (renderer === "canvas") {
            marksAndLayers[id] = mark;
            dirty.set(true);
          }
          updateInteractionManagerIfNecessary();
        }
        if (!updatePositioning && updateAesthetics) {
          const parsedAesthetics = parseAesthetics2(aesthetics);
          const strokeWidthChanged = mark.props.strokeWidth !== parsedAesthetics.strokeWidth;
          const clipChanged = mark.props.clip !== parsedAesthetics.clip;
          mark.updateAesthetics(parsedAesthetics);
          if (strokeWidthChanged || clipChanged) {
            updateInteractionManagerIfNecessary();
          }
          if (renderer === "svg") {
            $$invalidate(29, svgContext = createSVGContext());
            mark.render(svgContext);
            $$invalidate(4, svgData = svgContext.result());
          }
          if (renderer === "canvas") {
            dirty.set(true);
          }
        }
        $$invalidate(30, updatePositioning = false);
        $$invalidate(31, updateAesthetics = false);
      }
    }
    if ($$self.$$.dirty[1] & /*$interactionManager*/
    4) {
      $:
        $$invalidate(32, primaryInput2 = $interactionManager.getPrimaryInput());
    }
    if ($$self.$$.dirty[0] & /*onClick, onMousedown, onMouseup, onMouseover, onMouseout, onMousedrag*/
    2064384 | $$self.$$.dirty[1] & /*primaryInput*/
    2) {
      $:
        isInteractiveMouse = primaryInput2 === "mouse" && any_default(onClick, onMousedown, onMouseup, onMouseover, onMouseout, onMousedrag);
    }
    if ($$self.$$.dirty[0] & /*onTouchdown, onTouchup, onTouchover, onTouchout, onTouchdrag*/
    65011712 | $$self.$$.dirty[1] & /*primaryInput*/
    2) {
      $:
        isInteractiveTouch = primaryInput2 === "touch" && any_default(onTouchdown, onTouchup, onTouchover, onTouchout, onTouchdrag);
    }
    if ($$self.$$.dirty[0] & /*onSelect, onDeselect*/
    201326592) {
      $:
        isSelectable = any_default(onSelect, onDeselect);
    }
  };
  return [
    aesthetics,
    className,
    element2,
    $section,
    svgData,
    renderer,
    globalBlockReindexing,
    section,
    interactionManager,
    id,
    positioning,
    createMark,
    parseAesthetics2,
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    mark,
    svgContext,
    updatePositioning,
    updateAesthetics,
    primaryInput2,
    $interactionManager
  ];
}
var Mark2 = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        positioning: 10,
        aesthetics: 0,
        createMark: 11,
        parseAesthetics: 12,
        className: 1,
        element: 2,
        outputSettings: 13,
        blockReindexing: 14,
        onClick: 15,
        onMousedown: 16,
        onMouseup: 17,
        onMouseover: 18,
        onMouseout: 19,
        onMousedrag: 20,
        onTouchdown: 21,
        onTouchup: 22,
        onTouchover: 23,
        onTouchout: 24,
        onTouchdrag: 25,
        onSelect: 26,
        onDeselect: 27
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mark",
      options: options2,
      id: create_fragment2.name
    });
  }
  get positioning() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aesthetics() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aesthetics(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get createMark() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createMark(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parseAesthetics() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parseAesthetics(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get className() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set className(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Mark_default = Mark2;

// node_modules/@snlab/florence/src/components/marks/rectangle/Rectangle.svelte
function create_fragment3(ctx2) {
  let mark;
  let current;
  mark = new Mark_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createMark: createRectangle,
      parseAesthetics: parseAestheticsRectangle,
      className: "rectangle",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(mark.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(mark, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const mark_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        mark_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        mark_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        mark_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        mark_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        mark_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        mark_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        mark_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        mark_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        mark_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        mark_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        mark_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        mark_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        mark_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        mark_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        mark_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        mark_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        mark_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      mark.$set(mark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(mark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(mark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(mark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Rectangle", slots, []);
  let { x1 = void 0 } = $$props;
  let { x2: x23 = void 0 } = $$props;
  let { y1 = void 0 } = $$props;
  let { y2: y23 = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x1",
    "x2",
    "y1",
    "y2",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Rectangle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(17, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(18, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(19, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(20, y23 = $$props2.y2);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(24, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(27, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(28, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(29, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(30, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(31, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(32, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createRectangle,
    parseAestheticsRectangle,
    Mark: Mark_default,
    x1,
    x2: x23,
    y1,
    y2: y23,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(17, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(18, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(19, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(20, y23 = $$props2.y2);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(24, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(27, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(28, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(29, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(30, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(31, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(32, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x1, x2, y1, y2*/
    1966080) {
      $:
        $$invalidate(16, positioning = { x1, x2: x23, y1, y2: y23 });
    }
    if ($$self.$$.dirty[0] & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap, lineJoin, miterLimit, dashArray*/
    2145386496 | $$self.$$.dirty[1] & /*dashOffset, clip*/
    3) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          lineJoin,
          miterLimit,
          dashArray,
          dashOffset,
          clip
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x1,
    x23,
    y1,
    y23,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip
  ];
}
var Rectangle = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        x1: 17,
        x2: 18,
        y1: 19,
        y2: 20,
        fill: 21,
        stroke: 22,
        strokeWidth: 23,
        strokeOpacity: 24,
        fillOpacity: 25,
        opacity: 26,
        lineCap: 27,
        lineJoin: 28,
        miterLimit: 29,
        dashArray: 30,
        dashOffset: 31,
        outputSettings: 0,
        clip: 32,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rectangle",
      options: options2,
      id: create_fragment3.name
    });
  }
  get x1() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x1(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x2() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x2(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y1() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y1(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y2() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y2(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<Rectangle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<Rectangle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Rectangle_default = Rectangle;

// node_modules/@snlab/florence/src/components/core/_BaseSection.svelte
var file3 = "node_modules/@snlab/florence/src/components/core/_BaseSection.svelte";
function create_if_block_22(ctx2) {
  let clipper;
  let t02;
  let t12;
  let g2;
  let current;
  clipper = new Clipper_default({
    props: { section: (
      /*section*/
      ctx2[1]
    ) },
    $$inline: true
  });
  let if_block = (
    /*backgroundColor*/
    ctx2[0] && create_if_block_32(ctx2)
  );
  const default_slot_template = (
    /*#slots*/
    ctx2[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx2,
    /*$$scope*/
    ctx2[22],
    null
  );
  const block = {
    c: function create() {
      create_component(clipper.$$.fragment);
      t02 = space();
      if (if_block)
        if_block.c();
      t12 = space();
      g2 = svg_element("g");
      if (default_slot)
        default_slot.c();
      attr_dev(g2, "class", "section");
      add_location(g2, file3, 111, 2, 3565);
    },
    m: function mount(target, anchor) {
      mount_component(clipper, target, anchor);
      insert_dev(target, t02, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t12, anchor);
      insert_dev(target, g2, anchor);
      if (default_slot) {
        default_slot.m(g2, null);
      }
      current = true;
    },
    p: function update(ctx3, dirty) {
      const clipper_changes = {};
      if (dirty & /*section*/
      2)
        clipper_changes.section = /*section*/
        ctx3[1];
      clipper.$set(clipper_changes);
      if (
        /*backgroundColor*/
        ctx3[0]
      ) {
        if (if_block) {
          if_block.p(ctx3, dirty);
          if (dirty & /*backgroundColor*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_32(ctx3);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t12.parentNode, t12);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx3,
            /*$$scope*/
            ctx3[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx3[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx3[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(clipper.$$.fragment, local);
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(clipper.$$.fragment, local);
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(g2);
      }
      destroy_component(clipper, detaching);
      if (if_block)
        if_block.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(105:0) {#if renderer === 'svg'}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_32(ctx2) {
  let rectangle;
  let current;
  rectangle = new Rectangle_default({
    props: { fill: (
      /*backgroundColor*/
      ctx2[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rectangle.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(rectangle, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const rectangle_changes = {};
      if (dirty & /*backgroundColor*/
      1)
        rectangle_changes.fill = /*backgroundColor*/
        ctx3[0];
      rectangle.$set(rectangle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rectangle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rectangle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rectangle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(108:2) {#if backgroundColor}",
    ctx: ctx2
  });
  return block;
}
function create_if_block2(ctx2) {
  let t2;
  let current;
  let if_block = (
    /*backgroundColor*/
    ctx2[0] && create_if_block_12(ctx2)
  );
  const default_slot_template = (
    /*#slots*/
    ctx2[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx2,
    /*$$scope*/
    ctx2[22],
    null
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (
        /*backgroundColor*/
        ctx3[0]
      ) {
        if (if_block) {
          if_block.p(ctx3, dirty);
          if (dirty & /*backgroundColor*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx3);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx3,
            /*$$scope*/
            ctx3[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx3[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx3[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
      if (if_block)
        if_block.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(117:0) {#if renderer === 'canvas'}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_12(ctx2) {
  let rectangle;
  let current;
  rectangle = new Rectangle_default({
    props: { fill: (
      /*backgroundColor*/
      ctx2[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rectangle.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(rectangle, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const rectangle_changes = {};
      if (dirty & /*backgroundColor*/
      1)
        rectangle_changes.fill = /*backgroundColor*/
        ctx3[0];
      rectangle.$set(rectangle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rectangle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rectangle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rectangle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(118:2) {#if backgroundColor}",
    ctx: ctx2
  });
  return block;
}
function create_fragment4(ctx2) {
  let t2;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*renderer*/
    ctx2[2] === "svg" && create_if_block_22(ctx2)
  );
  let if_block1 = (
    /*renderer*/
    ctx2[2] === "canvas" && create_if_block2(ctx2)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx3, [dirty]) {
      if (
        /*renderer*/
        ctx3[2] === "svg"
      )
        if_block0.p(ctx3, dirty);
      if (
        /*renderer*/
        ctx3[2] === "canvas"
      )
        if_block1.p(ctx3, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $parentSection;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BaseSection", slots, ["default"]);
  let { props } = $$props;
  let { id } = $$props;
  let { createFunction } = $$props;
  let { backgroundColor = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onWheel = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousemove = void 0 } = $$props;
  let { onPinch = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchmove = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  const { renderer } = getContext("graphic");
  const parentSection = getContext("section");
  validate_store(parentSection, "parentSection");
  component_subscribe($$self, parentSection, (value) => $$invalidate(21, $parentSection = value));
  const eventManager = getContext("eventManager");
  const sectionContext = writable();
  const interactionManagerContext = writable();
  setContext("section", sectionContext);
  setContext("interactionManager", interactionManagerContext);
  let section;
  const interactionManager = new InteractionManager();
  interactionManager.setId(id);
  interactionManager.linkEventManager(eventManager);
  function removeSectionInteractionsIfNecessary() {
    if (interactionManager.getPrimaryInput() === "mouse") {
      const sectionInterface = interactionManager.mouse().section();
      sectionInterface.removeAllInteractions();
      if (onWheel)
        sectionInterface.addInteraction("wheel", onWheel);
      if (onClick)
        sectionInterface.addInteraction("click", onClick);
      if (onMousedown)
        sectionInterface.addInteraction("mousedown", onMousedown);
      if (onMouseup)
        sectionInterface.addInteraction("mouseup", onMouseup);
      if (onMouseover)
        sectionInterface.addInteraction("mouseover", onMouseover);
      if (onMouseout)
        sectionInterface.addInteraction("mouseout", onMouseout);
      if (onMousemove)
        sectionInterface.addInteraction("mousemove", onMousemove);
    }
    if (interactionManager.getPrimaryInput() === "touch") {
      const sectionInterface = interactionManager.touch().section();
      sectionInterface.removeAllInteractions();
      if (onTouchdown)
        sectionInterface.addInteraction("touchdown", onTouchdown);
      if (onTouchmove)
        sectionInterface.addInteraction("touchmove", onTouchmove);
      if (onTouchup)
        sectionInterface.addInteraction("touchup", onTouchup);
      if (onTouchover)
        sectionInterface.addInteraction("touchover", onTouchover);
      if (onTouchout)
        sectionInterface.addInteraction("touchout", onTouchout);
      if (onPinch)
        sectionInterface.addInteraction("pinch", onPinch);
    }
  }
  const getSM = () => interactionManager.select();
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<BaseSection> was created without expected prop 'props'");
    }
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<BaseSection> was created without expected prop 'id'");
    }
    if (createFunction === void 0 && !("createFunction" in $$props || $$self.$$.bound[$$self.$$.props["createFunction"]])) {
      console.warn("<BaseSection> was created without expected prop 'createFunction'");
    }
  });
  const writable_props = [
    "props",
    "id",
    "createFunction",
    "backgroundColor",
    "onClick",
    "onWheel",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousemove",
    "onPinch",
    "onTouchdown",
    "onTouchmove",
    "onTouchup",
    "onTouchover",
    "onTouchout"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BaseSection> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("id" in $$props2)
      $$invalidate(5, id = $$props2.id);
    if ("createFunction" in $$props2)
      $$invalidate(6, createFunction = $$props2.createFunction);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("onClick" in $$props2)
      $$invalidate(7, onClick = $$props2.onClick);
    if ("onWheel" in $$props2)
      $$invalidate(8, onWheel = $$props2.onWheel);
    if ("onMousedown" in $$props2)
      $$invalidate(9, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(10, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(11, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(12, onMouseout = $$props2.onMouseout);
    if ("onMousemove" in $$props2)
      $$invalidate(13, onMousemove = $$props2.onMousemove);
    if ("onPinch" in $$props2)
      $$invalidate(14, onPinch = $$props2.onPinch);
    if ("onTouchdown" in $$props2)
      $$invalidate(15, onTouchdown = $$props2.onTouchdown);
    if ("onTouchmove" in $$props2)
      $$invalidate(16, onTouchmove = $$props2.onTouchmove);
    if ("onTouchup" in $$props2)
      $$invalidate(17, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(18, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(19, onTouchout = $$props2.onTouchout);
    if ("$$scope" in $$props2)
      $$invalidate(22, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    writable,
    InteractionManager,
    Clipper: Clipper_default,
    Rectangle: Rectangle_default,
    props,
    id,
    createFunction,
    backgroundColor,
    onClick,
    onWheel,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousemove,
    onPinch,
    onTouchdown,
    onTouchmove,
    onTouchup,
    onTouchover,
    onTouchout,
    renderer,
    parentSection,
    eventManager,
    sectionContext,
    interactionManagerContext,
    section,
    interactionManager,
    removeSectionInteractionsIfNecessary,
    getSM,
    $parentSection
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("id" in $$props2)
      $$invalidate(5, id = $$props2.id);
    if ("createFunction" in $$props2)
      $$invalidate(6, createFunction = $$props2.createFunction);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("onClick" in $$props2)
      $$invalidate(7, onClick = $$props2.onClick);
    if ("onWheel" in $$props2)
      $$invalidate(8, onWheel = $$props2.onWheel);
    if ("onMousedown" in $$props2)
      $$invalidate(9, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(10, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(11, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(12, onMouseout = $$props2.onMouseout);
    if ("onMousemove" in $$props2)
      $$invalidate(13, onMousemove = $$props2.onMousemove);
    if ("onPinch" in $$props2)
      $$invalidate(14, onPinch = $$props2.onPinch);
    if ("onTouchdown" in $$props2)
      $$invalidate(15, onTouchdown = $$props2.onTouchdown);
    if ("onTouchmove" in $$props2)
      $$invalidate(16, onTouchmove = $$props2.onTouchmove);
    if ("onTouchup" in $$props2)
      $$invalidate(17, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(18, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(19, onTouchout = $$props2.onTouchout);
    if ("section" in $$props2)
      $$invalidate(1, section = $$props2.section);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*createFunction, props, $parentSection*/
    2097232) {
      $: {
        $$invalidate(1, section = createFunction(props, $parentSection));
      }
    }
    if ($$self.$$.dirty & /*section*/
    2) {
      $: {
        interactionManager.loadSection(section);
      }
    }
    if ($$self.$$.dirty & /*onWheel, onClick, onMousedown, onMouseup, onMouseover, onMouseout, onTouchdown, onTouchmove, onTouchup, onTouchover, onTouchout, onPinch*/
    1040256) {
      $: {
        removeSectionInteractionsIfNecessary(onWheel, onClick, onMousedown, onMouseup, onMouseover, onMouseout, onTouchdown, onTouchmove, onTouchup, onTouchover, onTouchout, onPinch);
      }
    }
    if ($$self.$$.dirty & /*section*/
    2) {
      $: {
        sectionContext.set(section);
      }
    }
  };
  $: {
    interactionManagerContext.set(interactionManager);
  }
  return [
    backgroundColor,
    section,
    renderer,
    parentSection,
    props,
    id,
    createFunction,
    onClick,
    onWheel,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousemove,
    onPinch,
    onTouchdown,
    onTouchmove,
    onTouchup,
    onTouchover,
    onTouchout,
    getSM,
    $parentSection,
    $$scope,
    slots
  ];
}
var BaseSection = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance4, create_fragment4, safe_not_equal, {
      props: 4,
      id: 5,
      createFunction: 6,
      backgroundColor: 0,
      onClick: 7,
      onWheel: 8,
      onMousedown: 9,
      onMouseup: 10,
      onMouseover: 11,
      onMouseout: 12,
      onMousemove: 13,
      onPinch: 14,
      onTouchdown: 15,
      onTouchmove: 16,
      onTouchup: 17,
      onTouchover: 18,
      onTouchout: 19,
      getSM: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BaseSection",
      options: options2,
      id: create_fragment4.name
    });
  }
  get props() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get createFunction() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createFunction(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onWheel() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onWheel(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousemove() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousemove(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPinch() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPinch(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchmove() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchmove(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<BaseSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSM() {
    return this.$$.ctx[20];
  }
  set getSM(value) {
    throw new Error("<BaseSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BaseSection_default = BaseSection;

// node_modules/@snlab/florence/src/components/core/section/Section.svelte
function create_default_slot(ctx2) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx2[38].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx2,
    /*$$scope*/
    ctx2[40],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx3,
            /*$$scope*/
            ctx3[40],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx3[40]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx3[40],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(72:0) <BaseSection   bind:this={node}   {props}   {backgroundColor}   {id}   createFunction={createSection}   {onClick}   {onWheel}   {onMousedown}   {onMouseup}   {onMouseover}   {onMouseout}   {onMousemove}   {onPinch}   {onTouchdown}   {onTouchmove}   {onTouchup}   {onTouchover}   {onTouchout} >",
    ctx: ctx2
  });
  return block;
}
function create_fragment5(ctx2) {
  let basesection;
  let current;
  let basesection_props = {
    props: (
      /*props*/
      ctx2[15]
    ),
    backgroundColor: (
      /*backgroundColor*/
      ctx2[0]
    ),
    id: (
      /*id*/
      ctx2[16]
    ),
    createFunction: createSection,
    onClick: (
      /*onClick*/
      ctx2[1]
    ),
    onWheel: (
      /*onWheel*/
      ctx2[2]
    ),
    onMousedown: (
      /*onMousedown*/
      ctx2[3]
    ),
    onMouseup: (
      /*onMouseup*/
      ctx2[4]
    ),
    onMouseover: (
      /*onMouseover*/
      ctx2[5]
    ),
    onMouseout: (
      /*onMouseout*/
      ctx2[6]
    ),
    onMousemove: (
      /*onMousemove*/
      ctx2[7]
    ),
    onPinch: (
      /*onPinch*/
      ctx2[8]
    ),
    onTouchdown: (
      /*onTouchdown*/
      ctx2[9]
    ),
    onTouchmove: (
      /*onTouchmove*/
      ctx2[10]
    ),
    onTouchup: (
      /*onTouchup*/
      ctx2[11]
    ),
    onTouchover: (
      /*onTouchover*/
      ctx2[12]
    ),
    onTouchout: (
      /*onTouchout*/
      ctx2[13]
    ),
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx: ctx2 }
  };
  basesection = new BaseSection_default({ props: basesection_props, $$inline: true });
  ctx2[39](basesection);
  const block = {
    c: function create() {
      create_component(basesection.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(basesection, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const basesection_changes = {};
      if (dirty[0] & /*props*/
      32768)
        basesection_changes.props = /*props*/
        ctx3[15];
      if (dirty[0] & /*backgroundColor*/
      1)
        basesection_changes.backgroundColor = /*backgroundColor*/
        ctx3[0];
      if (dirty[0] & /*onClick*/
      2)
        basesection_changes.onClick = /*onClick*/
        ctx3[1];
      if (dirty[0] & /*onWheel*/
      4)
        basesection_changes.onWheel = /*onWheel*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        basesection_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        basesection_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        basesection_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        basesection_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousemove*/
      128)
        basesection_changes.onMousemove = /*onMousemove*/
        ctx3[7];
      if (dirty[0] & /*onPinch*/
      256)
        basesection_changes.onPinch = /*onPinch*/
        ctx3[8];
      if (dirty[0] & /*onTouchdown*/
      512)
        basesection_changes.onTouchdown = /*onTouchdown*/
        ctx3[9];
      if (dirty[0] & /*onTouchmove*/
      1024)
        basesection_changes.onTouchmove = /*onTouchmove*/
        ctx3[10];
      if (dirty[0] & /*onTouchup*/
      2048)
        basesection_changes.onTouchup = /*onTouchup*/
        ctx3[11];
      if (dirty[0] & /*onTouchover*/
      4096)
        basesection_changes.onTouchover = /*onTouchover*/
        ctx3[12];
      if (dirty[0] & /*onTouchout*/
      8192)
        basesection_changes.onTouchout = /*onTouchout*/
        ctx3[13];
      if (dirty[1] & /*$$scope*/
      512) {
        basesection_changes.$$scope = { dirty, ctx: ctx3 };
      }
      basesection.$set(basesection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(basesection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basesection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx2[39](null);
      destroy_component(basesection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
var idCounter2 = 0;
function getId3() {
  return "sc" + idCounter2++;
}
function instance5($$self, $$props, $$invalidate) {
  let props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Section", slots, ["default"]);
  const id = getId3();
  let { x1 = void 0 } = $$props;
  let { x2: x23 = void 0 } = $$props;
  let { y1 = void 0 } = $$props;
  let { y2: y23 = void 0 } = $$props;
  let { backgroundColor = void 0 } = $$props;
  let { coordinates = void 0 } = $$props;
  let { scaleX = void 0 } = $$props;
  let { scaleY = void 0 } = $$props;
  let { flipX = false } = $$props;
  let { flipY = false } = $$props;
  let { padding = 0 } = $$props;
  let { zoomIdentity = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onWheel = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousemove = void 0 } = $$props;
  let { onPinch = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchmove = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { clip = "padding" } = $$props;
  let node;
  const getSM = () => node.getSM();
  const selectRectangle = (rect) => node.getSM().selectRectangle(rect);
  const updateSelectRectangle = (rect) => node.getSM().updateSelectRectangle(rect);
  const resetSelectRectangle = () => node.getSM().resetSelectRectangle();
  const startSelectPolygon = (c2) => node.getSM().startSelectPolygon(c2);
  const addPointToSelectPolygon = (c2) => node.getSM().addPointToSelectPolygon(c2);
  const moveSelectPolygon = (delta) => node.getSM().moveSelectPolygon(delta);
  const getSelectPolygon = () => node.getSM().getSelectPolygon();
  const resetSelectPolygon = () => node.getSM().resetSelectPolygon();
  const writable_props = [
    "x1",
    "x2",
    "y1",
    "y2",
    "backgroundColor",
    "coordinates",
    "scaleX",
    "scaleY",
    "flipX",
    "flipY",
    "padding",
    "zoomIdentity",
    "onClick",
    "onWheel",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousemove",
    "onPinch",
    "onTouchdown",
    "onTouchmove",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "clip"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Section> was created with unknown prop '${key}'`);
  });
  function basesection_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(14, node);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(17, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(18, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(19, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(20, y23 = $$props2.y2);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("coordinates" in $$props2)
      $$invalidate(21, coordinates = $$props2.coordinates);
    if ("scaleX" in $$props2)
      $$invalidate(22, scaleX = $$props2.scaleX);
    if ("scaleY" in $$props2)
      $$invalidate(23, scaleY = $$props2.scaleY);
    if ("flipX" in $$props2)
      $$invalidate(24, flipX = $$props2.flipX);
    if ("flipY" in $$props2)
      $$invalidate(25, flipY = $$props2.flipY);
    if ("padding" in $$props2)
      $$invalidate(26, padding = $$props2.padding);
    if ("zoomIdentity" in $$props2)
      $$invalidate(27, zoomIdentity = $$props2.zoomIdentity);
    if ("onClick" in $$props2)
      $$invalidate(1, onClick = $$props2.onClick);
    if ("onWheel" in $$props2)
      $$invalidate(2, onWheel = $$props2.onWheel);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousemove" in $$props2)
      $$invalidate(7, onMousemove = $$props2.onMousemove);
    if ("onPinch" in $$props2)
      $$invalidate(8, onPinch = $$props2.onPinch);
    if ("onTouchdown" in $$props2)
      $$invalidate(9, onTouchdown = $$props2.onTouchdown);
    if ("onTouchmove" in $$props2)
      $$invalidate(10, onTouchmove = $$props2.onTouchmove);
    if ("onTouchup" in $$props2)
      $$invalidate(11, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(12, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(13, onTouchout = $$props2.onTouchout);
    if ("clip" in $$props2)
      $$invalidate(28, clip = $$props2.clip);
    if ("$$scope" in $$props2)
      $$invalidate(40, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    idCounter: idCounter2,
    getId: getId3,
    createSection,
    BaseSection: BaseSection_default,
    id,
    x1,
    x2: x23,
    y1,
    y2: y23,
    backgroundColor,
    coordinates,
    scaleX,
    scaleY,
    flipX,
    flipY,
    padding,
    zoomIdentity,
    onClick,
    onWheel,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousemove,
    onPinch,
    onTouchdown,
    onTouchmove,
    onTouchup,
    onTouchover,
    onTouchout,
    clip,
    node,
    getSM,
    selectRectangle,
    updateSelectRectangle,
    resetSelectRectangle,
    startSelectPolygon,
    addPointToSelectPolygon,
    moveSelectPolygon,
    getSelectPolygon,
    resetSelectPolygon,
    props
  });
  $$self.$inject_state = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(17, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(18, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(19, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(20, y23 = $$props2.y2);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("coordinates" in $$props2)
      $$invalidate(21, coordinates = $$props2.coordinates);
    if ("scaleX" in $$props2)
      $$invalidate(22, scaleX = $$props2.scaleX);
    if ("scaleY" in $$props2)
      $$invalidate(23, scaleY = $$props2.scaleY);
    if ("flipX" in $$props2)
      $$invalidate(24, flipX = $$props2.flipX);
    if ("flipY" in $$props2)
      $$invalidate(25, flipY = $$props2.flipY);
    if ("padding" in $$props2)
      $$invalidate(26, padding = $$props2.padding);
    if ("zoomIdentity" in $$props2)
      $$invalidate(27, zoomIdentity = $$props2.zoomIdentity);
    if ("onClick" in $$props2)
      $$invalidate(1, onClick = $$props2.onClick);
    if ("onWheel" in $$props2)
      $$invalidate(2, onWheel = $$props2.onWheel);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousemove" in $$props2)
      $$invalidate(7, onMousemove = $$props2.onMousemove);
    if ("onPinch" in $$props2)
      $$invalidate(8, onPinch = $$props2.onPinch);
    if ("onTouchdown" in $$props2)
      $$invalidate(9, onTouchdown = $$props2.onTouchdown);
    if ("onTouchmove" in $$props2)
      $$invalidate(10, onTouchmove = $$props2.onTouchmove);
    if ("onTouchup" in $$props2)
      $$invalidate(11, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(12, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(13, onTouchout = $$props2.onTouchout);
    if ("clip" in $$props2)
      $$invalidate(28, clip = $$props2.clip);
    if ("node" in $$props2)
      $$invalidate(14, node = $$props2.node);
    if ("props" in $$props2)
      $$invalidate(15, props = $$props2.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x1, x2, y1, y2, coordinates, scaleX, scaleY, flipX, flipY, padding, zoomIdentity, clip*/
    536739840) {
      $:
        $$invalidate(15, props = {
          x1,
          x2: x23,
          y1,
          y2: y23,
          coordinates,
          scaleX,
          scaleY,
          flipX,
          flipY,
          padding,
          zoomIdentity,
          clip
        });
    }
  };
  return [
    backgroundColor,
    onClick,
    onWheel,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousemove,
    onPinch,
    onTouchdown,
    onTouchmove,
    onTouchup,
    onTouchover,
    onTouchout,
    node,
    props,
    id,
    x1,
    x23,
    y1,
    y23,
    coordinates,
    scaleX,
    scaleY,
    flipX,
    flipY,
    padding,
    zoomIdentity,
    clip,
    getSM,
    selectRectangle,
    updateSelectRectangle,
    resetSelectRectangle,
    startSelectPolygon,
    addPointToSelectPolygon,
    moveSelectPolygon,
    getSelectPolygon,
    resetSelectPolygon,
    slots,
    basesection_binding,
    $$scope
  ];
}
var Section = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        x1: 17,
        x2: 18,
        y1: 19,
        y2: 20,
        backgroundColor: 0,
        coordinates: 21,
        scaleX: 22,
        scaleY: 23,
        flipX: 24,
        flipY: 25,
        padding: 26,
        zoomIdentity: 27,
        onClick: 1,
        onWheel: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousemove: 7,
        onPinch: 8,
        onTouchdown: 9,
        onTouchmove: 10,
        onTouchup: 11,
        onTouchover: 12,
        onTouchout: 13,
        clip: 28,
        getSM: 29,
        selectRectangle: 30,
        updateSelectRectangle: 31,
        resetSelectRectangle: 32,
        startSelectPolygon: 33,
        addPointToSelectPolygon: 34,
        moveSelectPolygon: 35,
        getSelectPolygon: 36,
        resetSelectPolygon: 37
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Section",
      options: options2,
      id: create_fragment5.name
    });
  }
  get x1() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x1(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x2() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x2(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y1() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y1(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y2() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y2(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get coordinates() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set coordinates(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleX() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleX(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleY() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleY(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipX() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipX(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipY() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipY(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomIdentity() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomIdentity(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onWheel() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onWheel(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousemove() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousemove(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPinch() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPinch(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchmove() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchmove(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSM() {
    return this.$$.ctx[29];
  }
  set getSM(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectRectangle() {
    return this.$$.ctx[30];
  }
  set selectRectangle(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateSelectRectangle() {
    return this.$$.ctx[31];
  }
  set updateSelectRectangle(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetSelectRectangle() {
    return this.$$.ctx[32];
  }
  set resetSelectRectangle(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startSelectPolygon() {
    return this.$$.ctx[33];
  }
  set startSelectPolygon(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addPointToSelectPolygon() {
    return this.$$.ctx[34];
  }
  set addPointToSelectPolygon(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get moveSelectPolygon() {
    return this.$$.ctx[35];
  }
  set moveSelectPolygon(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectPolygon() {
    return this.$$.ctx[36];
  }
  set getSelectPolygon(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetSelectPolygon() {
    return this.$$.ctx[37];
  }
  set resetSelectPolygon(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Section_default = Section;

// node_modules/@snlab/florence/src/components/core/graphic/Graphic.svelte
var file4 = "node_modules/@snlab/florence/src/components/core/graphic/Graphic.svelte";
function create_if_block_13(ctx2) {
  let svg;
  let section;
  let svg_data_testid_value;
  let current;
  let section_props = {
    x1: 0,
    x2: (
      /*width*/
      ctx2[0]
    ),
    y1: 0,
    y2: (
      /*height*/
      ctx2[1]
    ),
    backgroundColor: (
      /*backgroundColor*/
      ctx2[2]
    ),
    coordinates: (
      /*coordinates*/
      ctx2[3]
    ),
    scaleX: (
      /*scaleX*/
      ctx2[4]
    ),
    scaleY: (
      /*scaleY*/
      ctx2[5]
    ),
    flipX: (
      /*flipX*/
      ctx2[6]
    ),
    flipY: (
      /*flipY*/
      ctx2[7]
    ),
    padding: (
      /*padding*/
      ctx2[8]
    ),
    zoomIdentity: (
      /*zoomIdentity*/
      ctx2[9]
    ),
    onClick: (
      /*onClick*/
      ctx2[10]
    ),
    onWheel: (
      /*onWheel*/
      ctx2[11]
    ),
    onMousedown: (
      /*onMousedown*/
      ctx2[12]
    ),
    onMouseup: (
      /*onMouseup*/
      ctx2[13]
    ),
    onMouseover: (
      /*onMouseover*/
      ctx2[14]
    ),
    onMouseout: (
      /*onMouseout*/
      ctx2[15]
    ),
    onMousemove: (
      /*onMousemove*/
      ctx2[16]
    ),
    onPinch: (
      /*onPinch*/
      ctx2[17]
    ),
    onTouchdown: (
      /*onTouchdown*/
      ctx2[18]
    ),
    onTouchmove: (
      /*onTouchmove*/
      ctx2[19]
    ),
    onTouchup: (
      /*onTouchup*/
      ctx2[20]
    ),
    onTouchover: (
      /*onTouchover*/
      ctx2[21]
    ),
    onTouchout: (
      /*onTouchout*/
      ctx2[22]
    ),
    clip: (
      /*clip*/
      ctx2[23]
    ),
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx: ctx2 }
  };
  section = new Section_default({ props: section_props, $$inline: true });
  ctx2[41](section);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      create_component(section.$$.fragment);
      attr_dev(
        svg,
        "id",
        /*id*/
        ctx2[27]
      );
      attr_dev(
        svg,
        "width",
        /*width*/
        ctx2[0]
      );
      attr_dev(
        svg,
        "height",
        /*height*/
        ctx2[1]
      );
      attr_dev(svg, "data-testid", svg_data_testid_value = testId("root"));
      add_location(svg, file4, 136, 2, 3797);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      mount_component(section, svg, null);
      ctx2[42](svg);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const section_changes = {};
      if (dirty[0] & /*width*/
      1)
        section_changes.x2 = /*width*/
        ctx3[0];
      if (dirty[0] & /*height*/
      2)
        section_changes.y2 = /*height*/
        ctx3[1];
      if (dirty[0] & /*backgroundColor*/
      4)
        section_changes.backgroundColor = /*backgroundColor*/
        ctx3[2];
      if (dirty[0] & /*coordinates*/
      8)
        section_changes.coordinates = /*coordinates*/
        ctx3[3];
      if (dirty[0] & /*scaleX*/
      16)
        section_changes.scaleX = /*scaleX*/
        ctx3[4];
      if (dirty[0] & /*scaleY*/
      32)
        section_changes.scaleY = /*scaleY*/
        ctx3[5];
      if (dirty[0] & /*flipX*/
      64)
        section_changes.flipX = /*flipX*/
        ctx3[6];
      if (dirty[0] & /*flipY*/
      128)
        section_changes.flipY = /*flipY*/
        ctx3[7];
      if (dirty[0] & /*padding*/
      256)
        section_changes.padding = /*padding*/
        ctx3[8];
      if (dirty[0] & /*zoomIdentity*/
      512)
        section_changes.zoomIdentity = /*zoomIdentity*/
        ctx3[9];
      if (dirty[0] & /*onClick*/
      1024)
        section_changes.onClick = /*onClick*/
        ctx3[10];
      if (dirty[0] & /*onWheel*/
      2048)
        section_changes.onWheel = /*onWheel*/
        ctx3[11];
      if (dirty[0] & /*onMousedown*/
      4096)
        section_changes.onMousedown = /*onMousedown*/
        ctx3[12];
      if (dirty[0] & /*onMouseup*/
      8192)
        section_changes.onMouseup = /*onMouseup*/
        ctx3[13];
      if (dirty[0] & /*onMouseover*/
      16384)
        section_changes.onMouseover = /*onMouseover*/
        ctx3[14];
      if (dirty[0] & /*onMouseout*/
      32768)
        section_changes.onMouseout = /*onMouseout*/
        ctx3[15];
      if (dirty[0] & /*onMousemove*/
      65536)
        section_changes.onMousemove = /*onMousemove*/
        ctx3[16];
      if (dirty[0] & /*onPinch*/
      131072)
        section_changes.onPinch = /*onPinch*/
        ctx3[17];
      if (dirty[0] & /*onTouchdown*/
      262144)
        section_changes.onTouchdown = /*onTouchdown*/
        ctx3[18];
      if (dirty[0] & /*onTouchmove*/
      524288)
        section_changes.onTouchmove = /*onTouchmove*/
        ctx3[19];
      if (dirty[0] & /*onTouchup*/
      1048576)
        section_changes.onTouchup = /*onTouchup*/
        ctx3[20];
      if (dirty[0] & /*onTouchover*/
      2097152)
        section_changes.onTouchover = /*onTouchover*/
        ctx3[21];
      if (dirty[0] & /*onTouchout*/
      4194304)
        section_changes.onTouchout = /*onTouchout*/
        ctx3[22];
      if (dirty[0] & /*clip*/
      8388608)
        section_changes.clip = /*clip*/
        ctx3[23];
      if (dirty[1] & /*$$scope*/
      16384) {
        section_changes.$$scope = { dirty, ctx: ctx3 };
      }
      section.$set(section_changes);
      if (!current || dirty[0] & /*width*/
      1) {
        attr_dev(
          svg,
          "width",
          /*width*/
          ctx3[0]
        );
      }
      if (!current || dirty[0] & /*height*/
      2) {
        attr_dev(
          svg,
          "height",
          /*height*/
          ctx3[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      ctx2[41](null);
      destroy_component(section);
      ctx2[42](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(135:0) {#if renderer === 'svg'}",
    ctx: ctx2
  });
  return block;
}
function create_default_slot_1(ctx2) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx2[40].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx2,
    /*$$scope*/
    ctx2[45],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx3,
            /*$$scope*/
            ctx3[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx3[45]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx3[45],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(139:4) <Section       bind:this={node}       x1={0}       x2={width}       y1={0}       y2={height}       {backgroundColor}       {coordinates}       {scaleX}       {scaleY}       {flipX}       {flipY}       {padding}       {zoomIdentity}       {onClick}       {onWheel}       {onMousedown}       {onMouseup}       {onMouseover}       {onMouseout}       {onMousemove}       {onPinch}       {onTouchdown}       {onTouchmove}       {onTouchup}       {onTouchover}       {onTouchout}       {clip}     >",
    ctx: ctx2
  });
  return block;
}
function create_if_block3(ctx2) {
  let canvas2;
  let canvas_data_testid_value;
  let t2;
  let section;
  let current;
  let section_props = {
    x1: 0,
    x2: (
      /*width*/
      ctx2[0]
    ),
    y1: 0,
    y2: (
      /*height*/
      ctx2[1]
    ),
    backgroundColor: (
      /*backgroundColor*/
      ctx2[2]
    ),
    coordinates: (
      /*coordinates*/
      ctx2[3]
    ),
    scaleX: (
      /*scaleX*/
      ctx2[4]
    ),
    scaleY: (
      /*scaleY*/
      ctx2[5]
    ),
    flipX: (
      /*flipX*/
      ctx2[6]
    ),
    flipY: (
      /*flipY*/
      ctx2[7]
    ),
    padding: (
      /*padding*/
      ctx2[8]
    ),
    zoomIdentity: (
      /*zoomIdentity*/
      ctx2[9]
    ),
    onClick: (
      /*onClick*/
      ctx2[10]
    ),
    onWheel: (
      /*onWheel*/
      ctx2[11]
    ),
    onMousedown: (
      /*onMousedown*/
      ctx2[12]
    ),
    onMouseup: (
      /*onMouseup*/
      ctx2[13]
    ),
    onMouseover: (
      /*onMouseover*/
      ctx2[14]
    ),
    onMouseout: (
      /*onMouseout*/
      ctx2[15]
    ),
    onMousemove: (
      /*onMousemove*/
      ctx2[16]
    ),
    onPinch: (
      /*onPinch*/
      ctx2[17]
    ),
    onTouchdown: (
      /*onTouchdown*/
      ctx2[18]
    ),
    onTouchmove: (
      /*onTouchmove*/
      ctx2[19]
    ),
    onTouchup: (
      /*onTouchup*/
      ctx2[20]
    ),
    onTouchover: (
      /*onTouchover*/
      ctx2[21]
    ),
    onTouchout: (
      /*onTouchout*/
      ctx2[22]
    ),
    clip: (
      /*clip*/
      ctx2[23]
    ),
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx: ctx2 }
  };
  section = new Section_default({ props: section_props, $$inline: true });
  ctx2[44](section);
  const block = {
    c: function create() {
      canvas2 = element("canvas");
      t2 = space();
      create_component(section.$$.fragment);
      attr_dev(
        canvas2,
        "id",
        /*id*/
        ctx2[27]
      );
      attr_dev(
        canvas2,
        "width",
        /*width*/
        ctx2[0]
      );
      attr_dev(
        canvas2,
        "height",
        /*height*/
        ctx2[1]
      );
      attr_dev(canvas2, "data-testid", canvas_data_testid_value = testId("root"));
      add_location(canvas2, file4, 178, 2, 4458);
    },
    m: function mount(target, anchor) {
      insert_dev(target, canvas2, anchor);
      ctx2[43](canvas2);
      insert_dev(target, t2, anchor);
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (!current || dirty[0] & /*width*/
      1) {
        attr_dev(
          canvas2,
          "width",
          /*width*/
          ctx3[0]
        );
      }
      if (!current || dirty[0] & /*height*/
      2) {
        attr_dev(
          canvas2,
          "height",
          /*height*/
          ctx3[1]
        );
      }
      const section_changes = {};
      if (dirty[0] & /*width*/
      1)
        section_changes.x2 = /*width*/
        ctx3[0];
      if (dirty[0] & /*height*/
      2)
        section_changes.y2 = /*height*/
        ctx3[1];
      if (dirty[0] & /*backgroundColor*/
      4)
        section_changes.backgroundColor = /*backgroundColor*/
        ctx3[2];
      if (dirty[0] & /*coordinates*/
      8)
        section_changes.coordinates = /*coordinates*/
        ctx3[3];
      if (dirty[0] & /*scaleX*/
      16)
        section_changes.scaleX = /*scaleX*/
        ctx3[4];
      if (dirty[0] & /*scaleY*/
      32)
        section_changes.scaleY = /*scaleY*/
        ctx3[5];
      if (dirty[0] & /*flipX*/
      64)
        section_changes.flipX = /*flipX*/
        ctx3[6];
      if (dirty[0] & /*flipY*/
      128)
        section_changes.flipY = /*flipY*/
        ctx3[7];
      if (dirty[0] & /*padding*/
      256)
        section_changes.padding = /*padding*/
        ctx3[8];
      if (dirty[0] & /*zoomIdentity*/
      512)
        section_changes.zoomIdentity = /*zoomIdentity*/
        ctx3[9];
      if (dirty[0] & /*onClick*/
      1024)
        section_changes.onClick = /*onClick*/
        ctx3[10];
      if (dirty[0] & /*onWheel*/
      2048)
        section_changes.onWheel = /*onWheel*/
        ctx3[11];
      if (dirty[0] & /*onMousedown*/
      4096)
        section_changes.onMousedown = /*onMousedown*/
        ctx3[12];
      if (dirty[0] & /*onMouseup*/
      8192)
        section_changes.onMouseup = /*onMouseup*/
        ctx3[13];
      if (dirty[0] & /*onMouseover*/
      16384)
        section_changes.onMouseover = /*onMouseover*/
        ctx3[14];
      if (dirty[0] & /*onMouseout*/
      32768)
        section_changes.onMouseout = /*onMouseout*/
        ctx3[15];
      if (dirty[0] & /*onMousemove*/
      65536)
        section_changes.onMousemove = /*onMousemove*/
        ctx3[16];
      if (dirty[0] & /*onPinch*/
      131072)
        section_changes.onPinch = /*onPinch*/
        ctx3[17];
      if (dirty[0] & /*onTouchdown*/
      262144)
        section_changes.onTouchdown = /*onTouchdown*/
        ctx3[18];
      if (dirty[0] & /*onTouchmove*/
      524288)
        section_changes.onTouchmove = /*onTouchmove*/
        ctx3[19];
      if (dirty[0] & /*onTouchup*/
      1048576)
        section_changes.onTouchup = /*onTouchup*/
        ctx3[20];
      if (dirty[0] & /*onTouchover*/
      2097152)
        section_changes.onTouchover = /*onTouchover*/
        ctx3[21];
      if (dirty[0] & /*onTouchout*/
      4194304)
        section_changes.onTouchout = /*onTouchout*/
        ctx3[22];
      if (dirty[0] & /*clip*/
      8388608)
        section_changes.clip = /*clip*/
        ctx3[23];
      if (dirty[1] & /*$$scope*/
      16384) {
        section_changes.$$scope = { dirty, ctx: ctx3 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(canvas2);
        detach_dev(t2);
      }
      ctx2[43](null);
      ctx2[44](null);
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(177:0) {#if renderer === 'canvas'}",
    ctx: ctx2
  });
  return block;
}
function create_default_slot2(ctx2) {
  let div;
  let div_id_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx2[40].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx2,
    /*$$scope*/
    ctx2[45],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      set_style(div, "display", "none");
      attr_dev(div, "id", div_id_value = `div-${/*id*/
      ctx2[27]}`);
      add_location(div, file4, 210, 4, 4992);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx3,
            /*$$scope*/
            ctx3[45],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx3[45]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx3[45],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(181:2) <Section     bind:this={node}     x1={0}     x2={width}     y1={0}     y2={height}     {backgroundColor}     {coordinates}     {scaleX}     {scaleY}     {flipX}     {flipY}     {padding}     {zoomIdentity}     {onClick}     {onWheel}     {onMousedown}     {onMouseup}     {onMouseover}     {onMouseout}     {onMousemove}     {onPinch}     {onTouchdown}     {onTouchmove}     {onTouchup}     {onTouchover}     {onTouchout}     {clip}   >",
    ctx: ctx2
  });
  return block;
}
function create_fragment6(ctx2) {
  let t2;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*renderer*/
    ctx2[24] === "svg" && create_if_block_13(ctx2)
  );
  let if_block1 = (
    /*renderer*/
    ctx2[24] === "canvas" && create_if_block3(ctx2)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (
        /*renderer*/
        ctx3[24] === "svg"
      ) {
        if (if_block0) {
          if_block0.p(ctx3, dirty);
          if (dirty[0] & /*renderer*/
          16777216) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx3);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*renderer*/
        ctx3[24] === "canvas"
      ) {
        if (if_block1) {
          if_block1.p(ctx3, dirty);
          if (dirty[0] & /*renderer*/
          16777216) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx3);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
var idCounter3 = 0;
function getId4() {
  return "gr" + idCounter3++;
}
function instance6($$self, $$props, $$invalidate) {
  let $dirty;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Graphic", slots, ["default"]);
  let { width = 500 } = $$props;
  let { height = 500 } = $$props;
  let { backgroundColor = void 0 } = $$props;
  let { coordinates = void 0 } = $$props;
  let { scaleX = void 0 } = $$props;
  let { scaleY = void 0 } = $$props;
  let { flipX = false } = $$props;
  let { flipY = false } = $$props;
  let { padding = 0 } = $$props;
  let { zoomIdentity = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onWheel = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousemove = void 0 } = $$props;
  let { onPinch = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchmove = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { clip = "padding" } = $$props;
  let { renderer = "svg" } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { _testDummies = void 0 } = $$props;
  let mounted = false;
  const isMounted = () => mounted;
  const id = getId4();
  let rootNode;
  let context;
  let dirty = writable(false);
  validate_store(dirty, "dirty");
  component_subscribe($$self, dirty, (value) => $$invalidate(39, $dirty = value));
  let globalBlockReindexing = writable(blockReindexing);
  const marksAndLayers = {};
  setContext("graphic", {
    renderer,
    dirty,
    marksAndLayers,
    globalBlockReindexing
  });
  const eventManager = new EventManager();
  setContext("eventManager", eventManager);
  onMount(() => {
    if (!rootNode) {
      $$invalidate(25, rootNode = document.getElementById(id));
    }
    if (renderer === "canvas") {
      context = rootNode.getContext("2d");
    }
    if (TEST_ENV && _testDummies) {
      const { dummyRoot, dummyWindow } = _testDummies;
      eventManager.addRootNode(dummyRoot, renderer, dummyWindow);
    } else {
      eventManager.addRootNode(rootNode, renderer);
    }
    eventManager.attachEventListeners();
    mounted = true;
  });
  const isEmpty = (id2) => [" ", ""].includes(id2);
  function render() {
    context.clearRect(0, 0, width, height);
    const childArray = Array.from(document.getElementById(`div-${id}`).childNodes);
    for (let i2 = 0; i2 < childArray.length; i2++) {
      const id2 = childArray[i2].data;
      if (!isEmpty(id2)) {
        marksAndLayers[id2].render(context);
      }
    }
  }
  let node;
  const selectRectangle = (rect) => node.getSM().selectRectangle(rect);
  const updateSelectRectangle = (rect) => node.getSM().updateSelectRectangle(rect);
  const resetSelectRectangle = () => node.getSM().resetSelectRectangle();
  const startSelectPolygon = (c2) => node.getSM().startSelectPolygon(c2);
  const addPointToSelectPolygon = (c2) => node.getSM().addPointToSelectPolygon(c2);
  const moveSelectPolygon = (delta) => node.getSM().moveSelectPolygon(delta);
  const getSelectPolygon = () => node.getSM().getSelectPolygon();
  const resetSelectPolygon = () => node.getSM().resetSelectPolygon();
  const writable_props = [
    "width",
    "height",
    "backgroundColor",
    "coordinates",
    "scaleX",
    "scaleY",
    "flipX",
    "flipY",
    "padding",
    "zoomIdentity",
    "onClick",
    "onWheel",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousemove",
    "onPinch",
    "onTouchdown",
    "onTouchmove",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "clip",
    "renderer",
    "blockReindexing",
    "_testDummies"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Graphic> was created with unknown prop '${key}'`);
  });
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(26, node);
    });
  }
  function svg_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rootNode = $$value;
      $$invalidate(25, rootNode);
    });
  }
  function canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rootNode = $$value;
      $$invalidate(25, rootNode);
    });
  }
  function section_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(26, node);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("backgroundColor" in $$props2)
      $$invalidate(2, backgroundColor = $$props2.backgroundColor);
    if ("coordinates" in $$props2)
      $$invalidate(3, coordinates = $$props2.coordinates);
    if ("scaleX" in $$props2)
      $$invalidate(4, scaleX = $$props2.scaleX);
    if ("scaleY" in $$props2)
      $$invalidate(5, scaleY = $$props2.scaleY);
    if ("flipX" in $$props2)
      $$invalidate(6, flipX = $$props2.flipX);
    if ("flipY" in $$props2)
      $$invalidate(7, flipY = $$props2.flipY);
    if ("padding" in $$props2)
      $$invalidate(8, padding = $$props2.padding);
    if ("zoomIdentity" in $$props2)
      $$invalidate(9, zoomIdentity = $$props2.zoomIdentity);
    if ("onClick" in $$props2)
      $$invalidate(10, onClick = $$props2.onClick);
    if ("onWheel" in $$props2)
      $$invalidate(11, onWheel = $$props2.onWheel);
    if ("onMousedown" in $$props2)
      $$invalidate(12, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(13, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(14, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(15, onMouseout = $$props2.onMouseout);
    if ("onMousemove" in $$props2)
      $$invalidate(16, onMousemove = $$props2.onMousemove);
    if ("onPinch" in $$props2)
      $$invalidate(17, onPinch = $$props2.onPinch);
    if ("onTouchdown" in $$props2)
      $$invalidate(18, onTouchdown = $$props2.onTouchdown);
    if ("onTouchmove" in $$props2)
      $$invalidate(19, onTouchmove = $$props2.onTouchmove);
    if ("onTouchup" in $$props2)
      $$invalidate(20, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(21, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(22, onTouchout = $$props2.onTouchout);
    if ("clip" in $$props2)
      $$invalidate(23, clip = $$props2.clip);
    if ("renderer" in $$props2)
      $$invalidate(24, renderer = $$props2.renderer);
    if ("blockReindexing" in $$props2)
      $$invalidate(29, blockReindexing = $$props2.blockReindexing);
    if ("_testDummies" in $$props2)
      $$invalidate(30, _testDummies = $$props2._testDummies);
    if ("$$scope" in $$props2)
      $$invalidate(45, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    idCounter: idCounter3,
    getId: getId4,
    onMount,
    setContext,
    tick,
    writable,
    EventManager,
    Section: Section_default,
    testId,
    TEST_ENV,
    width,
    height,
    backgroundColor,
    coordinates,
    scaleX,
    scaleY,
    flipX,
    flipY,
    padding,
    zoomIdentity,
    onClick,
    onWheel,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousemove,
    onPinch,
    onTouchdown,
    onTouchmove,
    onTouchup,
    onTouchover,
    onTouchout,
    clip,
    renderer,
    blockReindexing,
    _testDummies,
    mounted,
    isMounted,
    id,
    rootNode,
    context,
    dirty,
    globalBlockReindexing,
    marksAndLayers,
    eventManager,
    isEmpty,
    render,
    node,
    selectRectangle,
    updateSelectRectangle,
    resetSelectRectangle,
    startSelectPolygon,
    addPointToSelectPolygon,
    moveSelectPolygon,
    getSelectPolygon,
    resetSelectPolygon,
    $dirty
  });
  $$self.$inject_state = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("backgroundColor" in $$props2)
      $$invalidate(2, backgroundColor = $$props2.backgroundColor);
    if ("coordinates" in $$props2)
      $$invalidate(3, coordinates = $$props2.coordinates);
    if ("scaleX" in $$props2)
      $$invalidate(4, scaleX = $$props2.scaleX);
    if ("scaleY" in $$props2)
      $$invalidate(5, scaleY = $$props2.scaleY);
    if ("flipX" in $$props2)
      $$invalidate(6, flipX = $$props2.flipX);
    if ("flipY" in $$props2)
      $$invalidate(7, flipY = $$props2.flipY);
    if ("padding" in $$props2)
      $$invalidate(8, padding = $$props2.padding);
    if ("zoomIdentity" in $$props2)
      $$invalidate(9, zoomIdentity = $$props2.zoomIdentity);
    if ("onClick" in $$props2)
      $$invalidate(10, onClick = $$props2.onClick);
    if ("onWheel" in $$props2)
      $$invalidate(11, onWheel = $$props2.onWheel);
    if ("onMousedown" in $$props2)
      $$invalidate(12, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(13, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(14, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(15, onMouseout = $$props2.onMouseout);
    if ("onMousemove" in $$props2)
      $$invalidate(16, onMousemove = $$props2.onMousemove);
    if ("onPinch" in $$props2)
      $$invalidate(17, onPinch = $$props2.onPinch);
    if ("onTouchdown" in $$props2)
      $$invalidate(18, onTouchdown = $$props2.onTouchdown);
    if ("onTouchmove" in $$props2)
      $$invalidate(19, onTouchmove = $$props2.onTouchmove);
    if ("onTouchup" in $$props2)
      $$invalidate(20, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(21, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(22, onTouchout = $$props2.onTouchout);
    if ("clip" in $$props2)
      $$invalidate(23, clip = $$props2.clip);
    if ("renderer" in $$props2)
      $$invalidate(24, renderer = $$props2.renderer);
    if ("blockReindexing" in $$props2)
      $$invalidate(29, blockReindexing = $$props2.blockReindexing);
    if ("_testDummies" in $$props2)
      $$invalidate(30, _testDummies = $$props2._testDummies);
    if ("mounted" in $$props2)
      mounted = $$props2.mounted;
    if ("rootNode" in $$props2)
      $$invalidate(25, rootNode = $$props2.rootNode);
    if ("context" in $$props2)
      context = $$props2.context;
    if ("dirty" in $$props2)
      $$invalidate(28, dirty = $$props2.dirty);
    if ("globalBlockReindexing" in $$props2)
      $$invalidate(49, globalBlockReindexing = $$props2.globalBlockReindexing);
    if ("node" in $$props2)
      $$invalidate(26, node = $$props2.node);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*blockReindexing*/
    536870912) {
      $: {
        if (isMounted())
          globalBlockReindexing.set(blockReindexing);
      }
    }
    if ($$self.$$.dirty[1] & /*$dirty*/
    256) {
      $: {
        if ($dirty) {
          tick().then(() => {
            render();
            dirty.set(false);
          });
        }
      }
    }
  };
  return [
    width,
    height,
    backgroundColor,
    coordinates,
    scaleX,
    scaleY,
    flipX,
    flipY,
    padding,
    zoomIdentity,
    onClick,
    onWheel,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousemove,
    onPinch,
    onTouchdown,
    onTouchmove,
    onTouchup,
    onTouchover,
    onTouchout,
    clip,
    renderer,
    rootNode,
    node,
    id,
    dirty,
    blockReindexing,
    _testDummies,
    selectRectangle,
    updateSelectRectangle,
    resetSelectRectangle,
    startSelectPolygon,
    addPointToSelectPolygon,
    moveSelectPolygon,
    getSelectPolygon,
    resetSelectPolygon,
    $dirty,
    slots,
    section_binding,
    svg_binding,
    canvas_binding,
    section_binding_1,
    $$scope
  ];
}
var Graphic = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        width: 0,
        height: 1,
        backgroundColor: 2,
        coordinates: 3,
        scaleX: 4,
        scaleY: 5,
        flipX: 6,
        flipY: 7,
        padding: 8,
        zoomIdentity: 9,
        onClick: 10,
        onWheel: 11,
        onMousedown: 12,
        onMouseup: 13,
        onMouseover: 14,
        onMouseout: 15,
        onMousemove: 16,
        onPinch: 17,
        onTouchdown: 18,
        onTouchmove: 19,
        onTouchup: 20,
        onTouchover: 21,
        onTouchout: 22,
        clip: 23,
        renderer: 24,
        blockReindexing: 29,
        _testDummies: 30,
        selectRectangle: 31,
        updateSelectRectangle: 32,
        resetSelectRectangle: 33,
        startSelectPolygon: 34,
        addPointToSelectPolygon: 35,
        moveSelectPolygon: 36,
        getSelectPolygon: 37,
        resetSelectPolygon: 38
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Graphic",
      options: options2,
      id: create_fragment6.name
    });
  }
  get width() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get coordinates() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set coordinates(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleX() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleX(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleY() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleY(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipX() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipX(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipY() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipY(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomIdentity() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomIdentity(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onWheel() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onWheel(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousemove() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousemove(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPinch() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPinch(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchmove() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchmove(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderer() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderer(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get _testDummies() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set _testDummies(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectRectangle() {
    return this.$$.ctx[31];
  }
  set selectRectangle(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateSelectRectangle() {
    return this.$$.ctx[32];
  }
  set updateSelectRectangle(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetSelectRectangle() {
    return this.$$.ctx[33];
  }
  set resetSelectRectangle(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startSelectPolygon() {
    return this.$$.ctx[34];
  }
  set startSelectPolygon(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addPointToSelectPolygon() {
    return this.$$.ctx[35];
  }
  set addPointToSelectPolygon(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get moveSelectPolygon() {
    return this.$$.ctx[36];
  }
  set moveSelectPolygon(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectPolygon() {
    return this.$$.ctx[37];
  }
  set getSelectPolygon(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetSelectPolygon() {
    return this.$$.ctx[38];
  }
  set resetSelectPolygon(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Graphic_default = Graphic;

// node_modules/@snlab/florence/src/components/core/grid/Grid.svelte
var get_default_slot_changes = (dirty) => ({ cells: dirty & /*cells*/
32 });
var get_default_slot_context = (ctx2) => ({ cells: (
  /*cells*/
  ctx2[5]
) });
function create_default_slot3(ctx2) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx2[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx2,
    /*$$scope*/
    ctx2[12],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, cells*/
        4128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx3,
            /*$$scope*/
            ctx3[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx3[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx3[12],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(26:0) <Section {x1} {x2} {y1} {y2} {padding}>",
    ctx: ctx2
  });
  return block;
}
function create_fragment7(ctx2) {
  let section;
  let current;
  section = new Section_default({
    props: {
      x1: (
        /*x1*/
        ctx2[0]
      ),
      x2: (
        /*x2*/
        ctx2[1]
      ),
      y1: (
        /*y1*/
        ctx2[2]
      ),
      y2: (
        /*y2*/
        ctx2[3]
      ),
      padding: (
        /*padding*/
        ctx2[4]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx: ctx2 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(section.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx3, [dirty]) {
      const section_changes = {};
      if (dirty & /*x1*/
      1)
        section_changes.x1 = /*x1*/
        ctx3[0];
      if (dirty & /*x2*/
      2)
        section_changes.x2 = /*x2*/
        ctx3[1];
      if (dirty & /*y1*/
      4)
        section_changes.y1 = /*y1*/
        ctx3[2];
      if (dirty & /*y2*/
      8)
        section_changes.y2 = /*y2*/
        ctx3[3];
      if (dirty & /*padding*/
      16)
        section_changes.padding = /*padding*/
        ctx3[4];
      if (dirty & /*$$scope, cells*/
      4128) {
        section_changes.$$scope = { dirty, ctx: ctx3 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let cells;
  let $parentSection;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Grid", slots, ["default"]);
  let { x1 = void 0 } = $$props;
  let { x2: x23 = void 0 } = $$props;
  let { y1 = void 0 } = $$props;
  let { y2: y23 = void 0 } = $$props;
  let { padding = void 0 } = $$props;
  let { numberOfCells } = $$props;
  let { rows = void 0 } = $$props;
  let { columns = void 0 } = $$props;
  const parentSection = getContext("section");
  validate_store(parentSection, "parentSection");
  component_subscribe($$self, parentSection, (value) => $$invalidate(10, $parentSection = value));
  $$self.$$.on_mount.push(function() {
    if (numberOfCells === void 0 && !("numberOfCells" in $$props || $$self.$$.bound[$$self.$$.props["numberOfCells"]])) {
      console.warn("<Grid> was created without expected prop 'numberOfCells'");
    }
  });
  const writable_props = ["x1", "x2", "y1", "y2", "padding", "numberOfCells", "rows", "columns"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Grid> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(0, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(1, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(2, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(3, y23 = $$props2.y2);
    if ("padding" in $$props2)
      $$invalidate(4, padding = $$props2.padding);
    if ("numberOfCells" in $$props2)
      $$invalidate(7, numberOfCells = $$props2.numberOfCells);
    if ("rows" in $$props2)
      $$invalidate(8, rows = $$props2.rows);
    if ("columns" in $$props2)
      $$invalidate(9, columns = $$props2.columns);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    getGridCells,
    Section: Section_default,
    x1,
    x2: x23,
    y1,
    y2: y23,
    padding,
    numberOfCells,
    rows,
    columns,
    parentSection,
    cells,
    $parentSection
  });
  $$self.$inject_state = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(0, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(1, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(2, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(3, y23 = $$props2.y2);
    if ("padding" in $$props2)
      $$invalidate(4, padding = $$props2.padding);
    if ("numberOfCells" in $$props2)
      $$invalidate(7, numberOfCells = $$props2.numberOfCells);
    if ("rows" in $$props2)
      $$invalidate(8, rows = $$props2.rows);
    if ("columns" in $$props2)
      $$invalidate(9, columns = $$props2.columns);
    if ("cells" in $$props2)
      $$invalidate(5, cells = $$props2.cells);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*numberOfCells, rows, columns, $parentSection*/
    1920) {
      $:
        $$invalidate(5, cells = getGridCells({ numberOfCells, rows, columns }, $parentSection));
    }
  };
  return [
    x1,
    x23,
    y1,
    y23,
    padding,
    cells,
    parentSection,
    numberOfCells,
    rows,
    columns,
    $parentSection,
    slots,
    $$scope
  ];
}
var Grid = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance7, create_fragment7, safe_not_equal, {
      x1: 0,
      x2: 1,
      y1: 2,
      y2: 3,
      padding: 4,
      numberOfCells: 7,
      rows: 8,
      columns: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options: options2,
      id: create_fragment7.name
    });
  }
  get x1() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x1(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x2() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x2(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y1() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y1(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y2() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y2(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get numberOfCells() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set numberOfCells(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columns() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// node_modules/@snlab/florence/src/components/core/glyph/Glyph.svelte
function create_default_slot4(ctx2) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx2[37].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx2,
    /*$$scope*/
    ctx2[39],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx3,
            /*$$scope*/
            ctx3[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx3[39]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx3[39],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(71:0) <BaseSection   bind:this={node}   {props}   {backgroundColor}   {id}   createFunction={createPointSection}   {onClick}   {onWheel}   {onMousedown}   {onMouseup}   {onMouseover}   {onMouseout}   {onMousemove}   {onPinch}   {onTouchdown}   {onTouchmove}   {onTouchup}   {onTouchover}   {onTouchout} >",
    ctx: ctx2
  });
  return block;
}
function create_fragment8(ctx2) {
  let basesection;
  let current;
  let basesection_props = {
    props: (
      /*props*/
      ctx2[15]
    ),
    backgroundColor: (
      /*backgroundColor*/
      ctx2[0]
    ),
    id: (
      /*id*/
      ctx2[16]
    ),
    createFunction: createPointSection,
    onClick: (
      /*onClick*/
      ctx2[1]
    ),
    onWheel: (
      /*onWheel*/
      ctx2[2]
    ),
    onMousedown: (
      /*onMousedown*/
      ctx2[3]
    ),
    onMouseup: (
      /*onMouseup*/
      ctx2[4]
    ),
    onMouseover: (
      /*onMouseover*/
      ctx2[5]
    ),
    onMouseout: (
      /*onMouseout*/
      ctx2[6]
    ),
    onMousemove: (
      /*onMousemove*/
      ctx2[7]
    ),
    onPinch: (
      /*onPinch*/
      ctx2[8]
    ),
    onTouchdown: (
      /*onTouchdown*/
      ctx2[9]
    ),
    onTouchmove: (
      /*onTouchmove*/
      ctx2[10]
    ),
    onTouchup: (
      /*onTouchup*/
      ctx2[11]
    ),
    onTouchover: (
      /*onTouchover*/
      ctx2[12]
    ),
    onTouchout: (
      /*onTouchout*/
      ctx2[13]
    ),
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx: ctx2 }
  };
  basesection = new BaseSection_default({ props: basesection_props, $$inline: true });
  ctx2[38](basesection);
  const block = {
    c: function create() {
      create_component(basesection.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(basesection, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const basesection_changes = {};
      if (dirty[0] & /*props*/
      32768)
        basesection_changes.props = /*props*/
        ctx3[15];
      if (dirty[0] & /*backgroundColor*/
      1)
        basesection_changes.backgroundColor = /*backgroundColor*/
        ctx3[0];
      if (dirty[0] & /*onClick*/
      2)
        basesection_changes.onClick = /*onClick*/
        ctx3[1];
      if (dirty[0] & /*onWheel*/
      4)
        basesection_changes.onWheel = /*onWheel*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        basesection_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        basesection_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        basesection_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        basesection_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousemove*/
      128)
        basesection_changes.onMousemove = /*onMousemove*/
        ctx3[7];
      if (dirty[0] & /*onPinch*/
      256)
        basesection_changes.onPinch = /*onPinch*/
        ctx3[8];
      if (dirty[0] & /*onTouchdown*/
      512)
        basesection_changes.onTouchdown = /*onTouchdown*/
        ctx3[9];
      if (dirty[0] & /*onTouchmove*/
      1024)
        basesection_changes.onTouchmove = /*onTouchmove*/
        ctx3[10];
      if (dirty[0] & /*onTouchup*/
      2048)
        basesection_changes.onTouchup = /*onTouchup*/
        ctx3[11];
      if (dirty[0] & /*onTouchover*/
      4096)
        basesection_changes.onTouchover = /*onTouchover*/
        ctx3[12];
      if (dirty[0] & /*onTouchout*/
      8192)
        basesection_changes.onTouchout = /*onTouchout*/
        ctx3[13];
      if (dirty[1] & /*$$scope*/
      256) {
        basesection_changes.$$scope = { dirty, ctx: ctx3 };
      }
      basesection.$set(basesection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(basesection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basesection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx2[38](null);
      destroy_component(basesection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
var idCounter4 = 0;
function getId5() {
  return "psc" + idCounter4++;
}
function instance8($$self, $$props, $$invalidate) {
  let props;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Glyph", slots, ["default"]);
  const id = getId5();
  let { x: x3 } = $$props;
  let { y: y3 } = $$props;
  let { width } = $$props;
  let { height } = $$props;
  let { backgroundColor = void 0 } = $$props;
  let { coordinates = void 0 } = $$props;
  let { scaleX = void 0 } = $$props;
  let { scaleY = void 0 } = $$props;
  let { flipX = false } = $$props;
  let { flipY = false } = $$props;
  let { padding = 0 } = $$props;
  let { zoomIdentity = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onWheel = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousemove = void 0 } = $$props;
  let { onPinch = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchmove = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { clip = "padding" } = $$props;
  let node;
  const selectRectangle = (rect) => node.getSM().selectRectangle(rect);
  const updateSelectRectangle = (rect) => node.getSM().updateSelectRectangle(rect);
  const resetSelectRectangle = () => node.getSM().resetSelectRectangle();
  const startSelectPolygon = (c2) => node.getSM().startSelectPolygon(c2);
  const addPointToSelectPolygon = (c2) => node.getSM().addPointToSelectPolygon(c2);
  const moveSelectPolygon = (delta) => node.getSM().moveSelectPolygon(delta);
  const getSelectPolygon = () => node.getSM().getSelectPolygon();
  const resetSelectPolygon = () => node.getSM().resetSelectPolygon();
  $$self.$$.on_mount.push(function() {
    if (x3 === void 0 && !("x" in $$props || $$self.$$.bound[$$self.$$.props["x"]])) {
      console.warn("<Glyph> was created without expected prop 'x'");
    }
    if (y3 === void 0 && !("y" in $$props || $$self.$$.bound[$$self.$$.props["y"]])) {
      console.warn("<Glyph> was created without expected prop 'y'");
    }
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<Glyph> was created without expected prop 'width'");
    }
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<Glyph> was created without expected prop 'height'");
    }
  });
  const writable_props = [
    "x",
    "y",
    "width",
    "height",
    "backgroundColor",
    "coordinates",
    "scaleX",
    "scaleY",
    "flipX",
    "flipY",
    "padding",
    "zoomIdentity",
    "onClick",
    "onWheel",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousemove",
    "onPinch",
    "onTouchdown",
    "onTouchmove",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "clip"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Glyph> was created with unknown prop '${key}'`);
  });
  function basesection_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      node = $$value;
      $$invalidate(14, node);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("width" in $$props2)
      $$invalidate(19, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(20, height = $$props2.height);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("coordinates" in $$props2)
      $$invalidate(21, coordinates = $$props2.coordinates);
    if ("scaleX" in $$props2)
      $$invalidate(22, scaleX = $$props2.scaleX);
    if ("scaleY" in $$props2)
      $$invalidate(23, scaleY = $$props2.scaleY);
    if ("flipX" in $$props2)
      $$invalidate(24, flipX = $$props2.flipX);
    if ("flipY" in $$props2)
      $$invalidate(25, flipY = $$props2.flipY);
    if ("padding" in $$props2)
      $$invalidate(26, padding = $$props2.padding);
    if ("zoomIdentity" in $$props2)
      $$invalidate(27, zoomIdentity = $$props2.zoomIdentity);
    if ("onClick" in $$props2)
      $$invalidate(1, onClick = $$props2.onClick);
    if ("onWheel" in $$props2)
      $$invalidate(2, onWheel = $$props2.onWheel);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousemove" in $$props2)
      $$invalidate(7, onMousemove = $$props2.onMousemove);
    if ("onPinch" in $$props2)
      $$invalidate(8, onPinch = $$props2.onPinch);
    if ("onTouchdown" in $$props2)
      $$invalidate(9, onTouchdown = $$props2.onTouchdown);
    if ("onTouchmove" in $$props2)
      $$invalidate(10, onTouchmove = $$props2.onTouchmove);
    if ("onTouchup" in $$props2)
      $$invalidate(11, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(12, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(13, onTouchout = $$props2.onTouchout);
    if ("clip" in $$props2)
      $$invalidate(28, clip = $$props2.clip);
    if ("$$scope" in $$props2)
      $$invalidate(39, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    idCounter: idCounter4,
    getId: getId5,
    createPointSection,
    BaseSection: BaseSection_default,
    id,
    x: x3,
    y: y3,
    width,
    height,
    backgroundColor,
    coordinates,
    scaleX,
    scaleY,
    flipX,
    flipY,
    padding,
    zoomIdentity,
    onClick,
    onWheel,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousemove,
    onPinch,
    onTouchdown,
    onTouchmove,
    onTouchup,
    onTouchover,
    onTouchout,
    clip,
    node,
    selectRectangle,
    updateSelectRectangle,
    resetSelectRectangle,
    startSelectPolygon,
    addPointToSelectPolygon,
    moveSelectPolygon,
    getSelectPolygon,
    resetSelectPolygon,
    props
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("width" in $$props2)
      $$invalidate(19, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(20, height = $$props2.height);
    if ("backgroundColor" in $$props2)
      $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("coordinates" in $$props2)
      $$invalidate(21, coordinates = $$props2.coordinates);
    if ("scaleX" in $$props2)
      $$invalidate(22, scaleX = $$props2.scaleX);
    if ("scaleY" in $$props2)
      $$invalidate(23, scaleY = $$props2.scaleY);
    if ("flipX" in $$props2)
      $$invalidate(24, flipX = $$props2.flipX);
    if ("flipY" in $$props2)
      $$invalidate(25, flipY = $$props2.flipY);
    if ("padding" in $$props2)
      $$invalidate(26, padding = $$props2.padding);
    if ("zoomIdentity" in $$props2)
      $$invalidate(27, zoomIdentity = $$props2.zoomIdentity);
    if ("onClick" in $$props2)
      $$invalidate(1, onClick = $$props2.onClick);
    if ("onWheel" in $$props2)
      $$invalidate(2, onWheel = $$props2.onWheel);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousemove" in $$props2)
      $$invalidate(7, onMousemove = $$props2.onMousemove);
    if ("onPinch" in $$props2)
      $$invalidate(8, onPinch = $$props2.onPinch);
    if ("onTouchdown" in $$props2)
      $$invalidate(9, onTouchdown = $$props2.onTouchdown);
    if ("onTouchmove" in $$props2)
      $$invalidate(10, onTouchmove = $$props2.onTouchmove);
    if ("onTouchup" in $$props2)
      $$invalidate(11, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(12, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(13, onTouchout = $$props2.onTouchout);
    if ("clip" in $$props2)
      $$invalidate(28, clip = $$props2.clip);
    if ("node" in $$props2)
      $$invalidate(14, node = $$props2.node);
    if ("props" in $$props2)
      $$invalidate(15, props = $$props2.props);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, width, height, coordinates, scaleX, scaleY, flipX, flipY, padding, zoomIdentity, clip*/
    536739840) {
      $:
        $$invalidate(15, props = {
          x: x3,
          y: y3,
          width,
          height,
          coordinates,
          scaleX,
          scaleY,
          flipX,
          flipY,
          padding,
          zoomIdentity,
          clip
        });
    }
  };
  return [
    backgroundColor,
    onClick,
    onWheel,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousemove,
    onPinch,
    onTouchdown,
    onTouchmove,
    onTouchup,
    onTouchover,
    onTouchout,
    node,
    props,
    id,
    x3,
    y3,
    width,
    height,
    coordinates,
    scaleX,
    scaleY,
    flipX,
    flipY,
    padding,
    zoomIdentity,
    clip,
    selectRectangle,
    updateSelectRectangle,
    resetSelectRectangle,
    startSelectPolygon,
    addPointToSelectPolygon,
    moveSelectPolygon,
    getSelectPolygon,
    resetSelectPolygon,
    slots,
    basesection_binding,
    $$scope
  ];
}
var Glyph = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        width: 19,
        height: 20,
        backgroundColor: 0,
        coordinates: 21,
        scaleX: 22,
        scaleY: 23,
        flipX: 24,
        flipY: 25,
        padding: 26,
        zoomIdentity: 27,
        onClick: 1,
        onWheel: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousemove: 7,
        onPinch: 8,
        onTouchdown: 9,
        onTouchmove: 10,
        onTouchup: 11,
        onTouchover: 12,
        onTouchout: 13,
        clip: 28,
        selectRectangle: 29,
        updateSelectRectangle: 30,
        resetSelectRectangle: 31,
        startSelectPolygon: 32,
        addPointToSelectPolygon: 33,
        moveSelectPolygon: 34,
        getSelectPolygon: 35,
        resetSelectPolygon: 36
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Glyph",
      options: options2,
      id: create_fragment8.name
    });
  }
  get x() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get coordinates() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set coordinates(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleX() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleX(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scaleY() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scaleY(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipX() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipX(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flipY() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flipY(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zoomIdentity() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zoomIdentity(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onWheel() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onWheel(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousemove() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousemove(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPinch() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPinch(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchmove() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchmove(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Glyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectRectangle() {
    return this.$$.ctx[29];
  }
  set selectRectangle(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateSelectRectangle() {
    return this.$$.ctx[30];
  }
  set updateSelectRectangle(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetSelectRectangle() {
    return this.$$.ctx[31];
  }
  set resetSelectRectangle(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get startSelectPolygon() {
    return this.$$.ctx[32];
  }
  set startSelectPolygon(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addPointToSelectPolygon() {
    return this.$$.ctx[33];
  }
  set addPointToSelectPolygon(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get moveSelectPolygon() {
    return this.$$.ctx[34];
  }
  set moveSelectPolygon(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectPolygon() {
    return this.$$.ctx[35];
  }
  set getSelectPolygon(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetSelectPolygon() {
    return this.$$.ctx[36];
  }
  set resetSelectPolygon(value) {
    throw new Error("<Glyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Glyph_default = Glyph;

// node_modules/@snlab/florence/src/components/marks/area/Area.svelte
function create_fragment9(ctx2) {
  let mark;
  let current;
  mark = new Mark_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createMark: createArea,
      parseAesthetics: parseAestheticsArea,
      className: "area",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(mark.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(mark, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const mark_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        mark_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        mark_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        mark_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        mark_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        mark_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        mark_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        mark_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        mark_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        mark_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        mark_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        mark_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        mark_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        mark_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        mark_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        mark_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        mark_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        mark_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      mark.$set(mark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(mark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(mark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(mark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Area", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { x1 = void 0 } = $$props;
  let { x2: x23 = void 0 } = $$props;
  let { y1 = void 0 } = $$props;
  let { y2: y23 = void 0 } = $$props;
  let { curve = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "x1",
    "x2",
    "y1",
    "y2",
    "curve",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Area> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("x1" in $$props2)
      $$invalidate(19, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(20, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(21, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(22, y23 = $$props2.y2);
    if ("curve" in $$props2)
      $$invalidate(23, curve = $$props2.curve);
    if ("fill" in $$props2)
      $$invalidate(24, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(25, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(26, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(27, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(28, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(29, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(30, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(31, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(32, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(33, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(34, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(35, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createArea,
    parseAestheticsArea,
    Mark: Mark_default,
    x: x3,
    y: y3,
    x1,
    x2: x23,
    y1,
    y2: y23,
    curve,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("x1" in $$props2)
      $$invalidate(19, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(20, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(21, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(22, y23 = $$props2.y2);
    if ("curve" in $$props2)
      $$invalidate(23, curve = $$props2.curve);
    if ("fill" in $$props2)
      $$invalidate(24, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(25, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(26, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(27, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(28, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(29, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(30, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(31, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(32, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(33, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(34, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(35, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, x1, x2, y1, y2, curve*/
    16646144) {
      $:
        $$invalidate(16, positioning = { x: x3, y: y3, x1, x2: x23, y1, y2: y23, curve });
    }
    if ($$self.$$.dirty[0] & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap*/
    2130706432 | $$self.$$.dirty[1] & /*lineJoin, miterLimit, dashArray, dashOffset, clip*/
    31) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          lineJoin,
          miterLimit,
          dashArray,
          dashOffset,
          clip
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    x1,
    x23,
    y1,
    y23,
    curve,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip
  ];
}
var Area = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        x1: 19,
        x2: 20,
        y1: 21,
        y2: 22,
        curve: 23,
        fill: 24,
        stroke: 25,
        strokeWidth: 26,
        strokeOpacity: 27,
        fillOpacity: 28,
        opacity: 29,
        lineCap: 30,
        lineJoin: 31,
        miterLimit: 32,
        dashArray: 33,
        dashOffset: 34,
        outputSettings: 0,
        clip: 35,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Area",
      options: options2,
      id: create_fragment9.name
    });
  }
  get x() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x1() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x1(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x2() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x2(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y1() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y1(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y2() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y2(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get curve() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set curve(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<Area>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<Area>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Area_default = Area;

// node_modules/@snlab/florence/src/components/marks/funcLine/FuncLine.svelte
function create_fragment10(ctx2) {
  let mark;
  let current;
  mark = new Mark_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createMark: createFuncLine,
      parseAesthetics: parseAestheticsFuncLine,
      className: "funcline",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(mark.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(mark, target, anchor);
      current = true;
    },
    p: function update(ctx3, [dirty]) {
      const mark_changes = {};
      if (dirty & /*positioning*/
      65536)
        mark_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty & /*aesthetics*/
      32768)
        mark_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty & /*outputSettings*/
      1)
        mark_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty & /*blockReindexing*/
      2)
        mark_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty & /*onClick*/
      4)
        mark_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty & /*onMousedown*/
      8)
        mark_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty & /*onMouseup*/
      16)
        mark_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty & /*onMouseover*/
      32)
        mark_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty & /*onMouseout*/
      64)
        mark_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty & /*onMousedrag*/
      128)
        mark_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty & /*onTouchdown*/
      256)
        mark_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty & /*onTouchup*/
      512)
        mark_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty & /*onTouchover*/
      1024)
        mark_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty & /*onTouchout*/
      2048)
        mark_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty & /*onTouchdrag*/
      4096)
        mark_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty & /*onSelect*/
      8192)
        mark_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty & /*onDeselect*/
      16384)
        mark_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      mark.$set(mark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(mark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(mark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(mark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FuncLine", slots, []);
  let { func = void 0 } = $$props;
  let { x: x3 = void 0 } = $$props;
  let { resolution = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "func",
    "x",
    "resolution",
    "stroke",
    "strokeWidth",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FuncLine> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("func" in $$props2)
      $$invalidate(17, func = $$props2.func);
    if ("x" in $$props2)
      $$invalidate(18, x3 = $$props2.x);
    if ("resolution" in $$props2)
      $$invalidate(19, resolution = $$props2.resolution);
    if ("stroke" in $$props2)
      $$invalidate(20, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(21, strokeWidth = $$props2.strokeWidth);
    if ("opacity" in $$props2)
      $$invalidate(22, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(23, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(24, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(25, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(26, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(27, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(28, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createFuncLine,
    parseAestheticsFuncLine,
    Mark: Mark_default,
    func,
    x: x3,
    resolution,
    stroke,
    strokeWidth,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("func" in $$props2)
      $$invalidate(17, func = $$props2.func);
    if ("x" in $$props2)
      $$invalidate(18, x3 = $$props2.x);
    if ("resolution" in $$props2)
      $$invalidate(19, resolution = $$props2.resolution);
    if ("stroke" in $$props2)
      $$invalidate(20, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(21, strokeWidth = $$props2.strokeWidth);
    if ("opacity" in $$props2)
      $$invalidate(22, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(23, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(24, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(25, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(26, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(27, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(28, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*func, x, resolution*/
    917504) {
      $:
        $$invalidate(16, positioning = { func, x: x3, resolution });
    }
    if ($$self.$$.dirty & /*stroke, strokeWidth, opacity, lineCap, dashArray, lineJoin, miterLimit, dashOffset, clip*/
    535822336) {
      $:
        $$invalidate(15, aesthetics = {
          stroke,
          strokeWidth,
          opacity,
          lineCap,
          dashArray,
          lineJoin,
          miterLimit,
          dashOffset,
          clip
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    func,
    x3,
    resolution,
    stroke,
    strokeWidth,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip
  ];
}
var FuncLine = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance10, create_fragment10, safe_not_equal, {
      func: 17,
      x: 18,
      resolution: 19,
      stroke: 20,
      strokeWidth: 21,
      opacity: 22,
      lineCap: 23,
      lineJoin: 24,
      miterLimit: 25,
      dashArray: 26,
      dashOffset: 27,
      outputSettings: 0,
      clip: 28,
      blockReindexing: 1,
      onClick: 2,
      onMousedown: 3,
      onMouseup: 4,
      onMouseover: 5,
      onMouseout: 6,
      onMousedrag: 7,
      onTouchdown: 8,
      onTouchup: 9,
      onTouchover: 10,
      onTouchout: 11,
      onTouchdrag: 12,
      onSelect: 13,
      onDeselect: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FuncLine",
      options: options2,
      id: create_fragment10.name
    });
  }
  get func() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set func(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resolution() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resolution(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<FuncLine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<FuncLine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FuncLine_default = FuncLine;

// node_modules/@snlab/florence/src/components/marks/label/Label.svelte
function create_fragment11(ctx2) {
  let mark;
  let current;
  mark = new Mark_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createMark: createLabel,
      parseAesthetics: parseAestheticsLabel,
      className: "label",
      element: "text",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(mark.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(mark, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const mark_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        mark_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        mark_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        mark_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        mark_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        mark_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        mark_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        mark_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        mark_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        mark_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        mark_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        mark_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        mark_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        mark_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        mark_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        mark_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        mark_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        mark_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      mark.$set(mark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(mark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(mark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(mark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { rotate = void 0 } = $$props;
  let { anchorPoint = void 0 } = $$props;
  let { text: text3 = void 0 } = $$props;
  let { fontSize = void 0 } = $$props;
  let { fontFamily = void 0 } = $$props;
  let { fontWeight = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "rotate",
    "anchorPoint",
    "text",
    "fontSize",
    "fontFamily",
    "fontWeight",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "outputSettings",
    "clip",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Label> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("rotate" in $$props2)
      $$invalidate(20, rotate = $$props2.rotate);
    if ("anchorPoint" in $$props2)
      $$invalidate(21, anchorPoint = $$props2.anchorPoint);
    if ("text" in $$props2)
      $$invalidate(22, text3 = $$props2.text);
    if ("fontSize" in $$props2)
      $$invalidate(23, fontSize = $$props2.fontSize);
    if ("fontFamily" in $$props2)
      $$invalidate(24, fontFamily = $$props2.fontFamily);
    if ("fontWeight" in $$props2)
      $$invalidate(25, fontWeight = $$props2.fontWeight);
    if ("fill" in $$props2)
      $$invalidate(26, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(27, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(28, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(29, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(30, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(31, opacity = $$props2.opacity);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(32, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createLabel,
    parseAestheticsLabel,
    Mark: Mark_default,
    x: x3,
    y: y3,
    geometry,
    rotate,
    anchorPoint,
    text: text3,
    fontSize,
    fontFamily,
    fontWeight,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    outputSettings,
    clip,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("rotate" in $$props2)
      $$invalidate(20, rotate = $$props2.rotate);
    if ("anchorPoint" in $$props2)
      $$invalidate(21, anchorPoint = $$props2.anchorPoint);
    if ("text" in $$props2)
      $$invalidate(22, text3 = $$props2.text);
    if ("fontSize" in $$props2)
      $$invalidate(23, fontSize = $$props2.fontSize);
    if ("fontFamily" in $$props2)
      $$invalidate(24, fontFamily = $$props2.fontFamily);
    if ("fontWeight" in $$props2)
      $$invalidate(25, fontWeight = $$props2.fontWeight);
    if ("fill" in $$props2)
      $$invalidate(26, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(27, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(28, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(29, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(30, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(31, opacity = $$props2.opacity);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(32, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, geometry, rotate, anchorPoint, text, fontSize*/
    16646144) {
      $:
        $$invalidate(16, positioning = {
          x: x3,
          y: y3,
          geometry,
          rotate,
          anchorPoint,
          text: text3,
          fontSize
        });
    }
    if ($$self.$$.dirty[0] & /*anchorPoint, text, fontSize, fontFamily, fontWeight, fill, stroke, strokeWidth, strokeOpacity, fillOpacity*/
    2145386496 | $$self.$$.dirty[1] & /*opacity, clip*/
    3) {
      $:
        $$invalidate(15, aesthetics = {
          anchorPoint,
          text: text3,
          fontSize,
          fontFamily,
          fontWeight,
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          clip
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    rotate,
    anchorPoint,
    text3,
    fontSize,
    fontFamily,
    fontWeight,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    clip
  ];
}
var Label = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        geometry: 19,
        rotate: 20,
        anchorPoint: 21,
        text: 22,
        fontSize: 23,
        fontFamily: 24,
        fontWeight: 25,
        fill: 26,
        stroke: 27,
        strokeWidth: 28,
        strokeOpacity: 29,
        fillOpacity: 30,
        opacity: 31,
        outputSettings: 0,
        clip: 32,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options: options2,
      id: create_fragment11.name
    });
  }
  get x() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotate() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotate(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorPoint() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorPoint(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSize() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSize(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontFamily() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontFamily(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontWeight() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontWeight(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/@snlab/florence/src/components/marks/line/Line.svelte
function create_fragment12(ctx2) {
  let mark;
  let current;
  mark = new Mark_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createMark: createLine,
      parseAesthetics: parseAestheticsLine,
      className: "line",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(mark.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(mark, target, anchor);
      current = true;
    },
    p: function update(ctx3, [dirty]) {
      const mark_changes = {};
      if (dirty & /*positioning*/
      65536)
        mark_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty & /*aesthetics*/
      32768)
        mark_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty & /*outputSettings*/
      1)
        mark_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty & /*blockReindexing*/
      2)
        mark_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty & /*onClick*/
      4)
        mark_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty & /*onMousedown*/
      8)
        mark_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty & /*onMouseup*/
      16)
        mark_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty & /*onMouseover*/
      32)
        mark_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty & /*onMouseout*/
      64)
        mark_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty & /*onMousedrag*/
      128)
        mark_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty & /*onTouchdown*/
      256)
        mark_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty & /*onTouchup*/
      512)
        mark_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty & /*onTouchover*/
      1024)
        mark_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty & /*onTouchout*/
      2048)
        mark_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty & /*onTouchdrag*/
      4096)
        mark_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty & /*onSelect*/
      8192)
        mark_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty & /*onDeselect*/
      16384)
        mark_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      mark.$set(mark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(mark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(mark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(mark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Line", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { curve = void 0 } = $$props;
  let { _resampleIntervals = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "curve",
    "_resampleIntervals",
    "stroke",
    "strokeWidth",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Line> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("curve" in $$props2)
      $$invalidate(20, curve = $$props2.curve);
    if ("_resampleIntervals" in $$props2)
      $$invalidate(21, _resampleIntervals = $$props2._resampleIntervals);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("opacity" in $$props2)
      $$invalidate(24, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(25, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(26, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(27, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(28, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(29, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(30, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createLine,
    parseAestheticsLine,
    Mark: Mark_default,
    x: x3,
    y: y3,
    geometry,
    curve,
    _resampleIntervals,
    stroke,
    strokeWidth,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("curve" in $$props2)
      $$invalidate(20, curve = $$props2.curve);
    if ("_resampleIntervals" in $$props2)
      $$invalidate(21, _resampleIntervals = $$props2._resampleIntervals);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("opacity" in $$props2)
      $$invalidate(24, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(25, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(26, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(27, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(28, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(29, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(30, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*x, y, geometry, curve, _resampleIntervals*/
    4063232) {
      $:
        $$invalidate(16, positioning = {
          x: x3,
          y: y3,
          geometry,
          curve,
          _resampleIntervals
        });
    }
    if ($$self.$$.dirty & /*stroke, strokeWidth, opacity, lineCap, dashArray, lineJoin, miterLimit, dashOffset, clip*/
    2143289344) {
      $:
        $$invalidate(15, aesthetics = {
          stroke,
          strokeWidth,
          opacity,
          lineCap,
          dashArray,
          lineJoin,
          miterLimit,
          dashOffset,
          clip
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    curve,
    _resampleIntervals,
    stroke,
    strokeWidth,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip
  ];
}
var Line = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance12, create_fragment12, safe_not_equal, {
      x: 17,
      y: 18,
      geometry: 19,
      curve: 20,
      _resampleIntervals: 21,
      stroke: 22,
      strokeWidth: 23,
      opacity: 24,
      lineCap: 25,
      lineJoin: 26,
      miterLimit: 27,
      dashArray: 28,
      dashOffset: 29,
      outputSettings: 0,
      clip: 30,
      blockReindexing: 1,
      onClick: 2,
      onMousedown: 3,
      onMouseup: 4,
      onMouseover: 5,
      onMouseout: 6,
      onMousedrag: 7,
      onTouchdown: 8,
      onTouchup: 9,
      onTouchover: 10,
      onTouchout: 11,
      onTouchdrag: 12,
      onSelect: 13,
      onDeselect: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Line",
      options: options2,
      id: create_fragment12.name
    });
  }
  get x() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get curve() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set curve(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get _resampleIntervals() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set _resampleIntervals(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<Line>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<Line>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Line_default = Line;

// node_modules/@snlab/florence/src/components/marks/point/Point.svelte
function create_fragment13(ctx2) {
  let mark;
  let current;
  mark = new Mark_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createMark: createPoint,
      parseAesthetics: parseAestheticsPoint,
      className: "point",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(mark.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(mark, target, anchor);
      current = true;
    },
    p: function update(ctx3, [dirty]) {
      const mark_changes = {};
      if (dirty & /*positioning*/
      65536)
        mark_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty & /*aesthetics*/
      32768)
        mark_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty & /*outputSettings*/
      1)
        mark_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty & /*blockReindexing*/
      2)
        mark_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty & /*onClick*/
      4)
        mark_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty & /*onMousedown*/
      8)
        mark_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty & /*onMouseup*/
      16)
        mark_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty & /*onMouseover*/
      32)
        mark_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty & /*onMouseout*/
      64)
        mark_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty & /*onMousedrag*/
      128)
        mark_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty & /*onTouchdown*/
      256)
        mark_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty & /*onTouchup*/
      512)
        mark_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty & /*onTouchover*/
      1024)
        mark_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty & /*onTouchout*/
      2048)
        mark_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty & /*onTouchdrag*/
      4096)
        mark_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty & /*onSelect*/
      8192)
        mark_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty & /*onDeselect*/
      16384)
        mark_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      mark.$set(mark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(mark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(mark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(mark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Point", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { radius = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "radius",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Point> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("radius" in $$props2)
      $$invalidate(20, radius = $$props2.radius);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(24, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(27, lineCap = $$props2.lineCap);
    if ("dashArray" in $$props2)
      $$invalidate(28, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(29, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(30, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createPoint,
    parseAestheticsPoint,
    Mark: Mark_default,
    x: x3,
    y: y3,
    geometry,
    radius,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("radius" in $$props2)
      $$invalidate(20, radius = $$props2.radius);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(24, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(27, lineCap = $$props2.lineCap);
    if ("dashArray" in $$props2)
      $$invalidate(28, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(29, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(30, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*x, y, geometry, radius*/
    1966080) {
      $:
        $$invalidate(16, positioning = { x: x3, y: y3, geometry, radius });
    }
    if ($$self.$$.dirty & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap, dashArray, dashOffset, clip*/
    2145386496) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          dashArray,
          dashOffset,
          clip
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    radius,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    dashArray,
    dashOffset,
    clip
  ];
}
var Point = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance13, create_fragment13, safe_not_equal, {
      x: 17,
      y: 18,
      geometry: 19,
      radius: 20,
      fill: 21,
      stroke: 22,
      strokeWidth: 23,
      strokeOpacity: 24,
      fillOpacity: 25,
      opacity: 26,
      lineCap: 27,
      dashArray: 28,
      dashOffset: 29,
      outputSettings: 0,
      clip: 30,
      blockReindexing: 1,
      onClick: 2,
      onMousedown: 3,
      onMouseup: 4,
      onMouseover: 5,
      onMouseout: 6,
      onMousedrag: 7,
      onTouchdown: 8,
      onTouchup: 9,
      onTouchover: 10,
      onTouchout: 11,
      onTouchdrag: 12,
      onSelect: 13,
      onDeselect: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Point",
      options: options2,
      id: create_fragment13.name
    });
  }
  get x() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<Point>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<Point>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Point_default = Point;

// node_modules/@snlab/florence/src/components/marks/polygon/Polygon.svelte
function create_fragment14(ctx2) {
  let mark;
  let current;
  mark = new Mark_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createMark: createPolygon,
      parseAesthetics: parseAestheticsPolygon,
      className: "polygon",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(mark.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(mark, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const mark_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        mark_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        mark_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        mark_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        mark_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        mark_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        mark_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        mark_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        mark_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        mark_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        mark_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        mark_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        mark_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        mark_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        mark_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        mark_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        mark_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        mark_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      mark.$set(mark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(mark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(mark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(mark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Polygon", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Polygon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("fill" in $$props2)
      $$invalidate(20, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(21, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(22, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(23, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(24, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(25, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(26, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(27, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(28, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(29, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(30, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(31, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createPolygon,
    parseAestheticsPolygon,
    Mark: Mark_default,
    x: x3,
    y: y3,
    geometry,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("fill" in $$props2)
      $$invalidate(20, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(21, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(22, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(23, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(24, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(25, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(26, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(27, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(28, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(29, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(30, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(31, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, geometry*/
    917504) {
      $:
        $$invalidate(16, positioning = { x: x3, y: y3, geometry });
    }
    if ($$self.$$.dirty[0] & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap, lineJoin, miterLimit, dashArray, dashOffset*/
    2146435072 | $$self.$$.dirty[1] & /*clip*/
    1) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          lineJoin,
          miterLimit,
          dashArray,
          dashOffset,
          clip
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip
  ];
}
var Polygon = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance14,
      create_fragment14,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        geometry: 19,
        fill: 20,
        stroke: 21,
        strokeWidth: 22,
        strokeOpacity: 23,
        fillOpacity: 24,
        opacity: 25,
        lineCap: 26,
        lineJoin: 27,
        miterLimit: 28,
        dashArray: 29,
        dashOffset: 30,
        outputSettings: 0,
        clip: 31,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Polygon",
      options: options2,
      id: create_fragment14.name
    });
  }
  get x() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<Polygon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<Polygon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Polygon_default = Polygon;

// node_modules/@snlab/florence/src/components/marks/symbol/Symbol.svelte
function create_fragment15(ctx2) {
  let mark;
  let current;
  mark = new Mark_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createMark: createSymbol,
      parseAesthetics: parseAestheticsSymbol,
      className: "symbol",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(mark.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(mark, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const mark_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        mark_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        mark_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        mark_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        mark_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        mark_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        mark_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        mark_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        mark_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        mark_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        mark_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        mark_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        mark_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        mark_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        mark_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        mark_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        mark_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        mark_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      mark.$set(mark_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(mark.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(mark.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(mark, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Symbol", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { shape = void 0 } = $$props;
  let { radius = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "shape",
    "radius",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Symbol> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("shape" in $$props2)
      $$invalidate(20, shape = $$props2.shape);
    if ("radius" in $$props2)
      $$invalidate(21, radius = $$props2.radius);
    if ("fill" in $$props2)
      $$invalidate(22, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(23, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(24, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(25, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(26, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(27, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(28, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(29, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(30, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(31, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(32, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(33, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createSymbol,
    parseAestheticsSymbol,
    Mark: Mark_default,
    x: x3,
    y: y3,
    geometry,
    shape,
    radius,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("shape" in $$props2)
      $$invalidate(20, shape = $$props2.shape);
    if ("radius" in $$props2)
      $$invalidate(21, radius = $$props2.radius);
    if ("fill" in $$props2)
      $$invalidate(22, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(23, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(24, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(25, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(26, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(27, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(28, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(29, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(30, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(31, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(32, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(33, clip = $$props2.clip);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, geometry, shape, radius*/
    4063232) {
      $:
        $$invalidate(16, positioning = { x: x3, y: y3, geometry, shape, radius });
    }
    if ($$self.$$.dirty[0] & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap, lineJoin, miterLimit*/
    2143289344 | $$self.$$.dirty[1] & /*dashArray, dashOffset, clip*/
    7) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          lineJoin,
          miterLimit,
          dashArray,
          dashOffset,
          clip
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    shape,
    radius,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip
  ];
}
var Symbol3 = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        geometry: 19,
        shape: 20,
        radius: 21,
        fill: 22,
        stroke: 23,
        strokeWidth: 24,
        strokeOpacity: 25,
        fillOpacity: 26,
        opacity: 27,
        lineCap: 28,
        lineJoin: 29,
        miterLimit: 30,
        dashArray: 31,
        dashOffset: 32,
        outputSettings: 0,
        clip: 33,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Symbol",
      options: options2,
      id: create_fragment15.name
    });
  }
  get x() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shape() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shape(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<Symbol>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<Symbol>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Symbol_default = Symbol3;

// node_modules/@snlab/florence/src/components/marks/base/Layer.svelte
var file5 = "node_modules/@snlab/florence/src/components/marks/base/Layer.svelte";
function get_each_context(ctx2, list, i2) {
  const child_ctx = ctx2.slice();
  child_ctx[49] = list[i2];
  child_ctx[51] = i2;
  return child_ctx;
}
function get_each_context_1(ctx2, list, i2) {
  const child_ctx = ctx2.slice();
  child_ctx[49] = list[i2];
  return child_ctx;
}
function get_each_context_2(ctx2, list, i2) {
  const child_ctx = ctx2.slice();
  child_ctx[49] = list[i2];
  child_ctx[51] = i2;
  return child_ctx;
}
function get_each_context_3(ctx2, list, i2) {
  const child_ctx = ctx2.slice();
  child_ctx[49] = list[i2];
  return child_ctx;
}
function create_if_block_14(ctx2) {
  let g2;
  let if_block0_anchor;
  let if_block1_anchor;
  let if_block2_anchor;
  let g_clip_path_value;
  let g_data_testid_value;
  let if_block0 = (
    /*element*/
    ctx2[2] === "path" && /*aesthetics*/
    ctx2[0].keys === void 0 && create_if_block_5(ctx2)
  );
  let if_block1 = (
    /*element*/
    ctx2[2] === "path" && /*aesthetics*/
    ctx2[0].keys !== void 0 && create_if_block_4(ctx2)
  );
  let if_block2 = (
    /*element*/
    ctx2[2] === "text" && /*aesthetics*/
    ctx2[0].keys === void 0 && create_if_block_33(ctx2)
  );
  let if_block3 = (
    /*element*/
    ctx2[2] === "text" && /*aesthetics*/
    ctx2[0].keys !== void 0 && create_if_block_23(ctx2)
  );
  const block = {
    c: function create() {
      g2 = svg_element("g");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      if (if_block3)
        if_block3.c();
      attr_dev(
        g2,
        "class",
        /*className*/
        ctx2[1]
      );
      attr_dev(g2, "clip-path", g_clip_path_value = getClipPathURL(
        /*aesthetics*/
        ctx2[0],
        /*$section*/
        ctx2[3]
      ));
      attr_dev(g2, "data-testid", g_data_testid_value = testId(
        /*className*/
        ctx2[1]
      ));
      add_location(g2, file5, 234, 2, 6744);
    },
    m: function mount(target, anchor) {
      insert_dev(target, g2, anchor);
      if (if_block0)
        if_block0.m(g2, null);
      append_dev(g2, if_block0_anchor);
      if (if_block1)
        if_block1.m(g2, null);
      append_dev(g2, if_block1_anchor);
      if (if_block2)
        if_block2.m(g2, null);
      append_dev(g2, if_block2_anchor);
      if (if_block3)
        if_block3.m(g2, null);
    },
    p: function update(ctx3, dirty) {
      if (
        /*element*/
        ctx3[2] === "path" && /*aesthetics*/
        ctx3[0].keys === void 0
      ) {
        if (if_block0) {
          if_block0.p(ctx3, dirty);
        } else {
          if_block0 = create_if_block_5(ctx3);
          if_block0.c();
          if_block0.m(g2, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*element*/
        ctx3[2] === "path" && /*aesthetics*/
        ctx3[0].keys !== void 0
      ) {
        if (if_block1) {
          if_block1.p(ctx3, dirty);
        } else {
          if_block1 = create_if_block_4(ctx3);
          if_block1.c();
          if_block1.m(g2, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*element*/
        ctx3[2] === "text" && /*aesthetics*/
        ctx3[0].keys === void 0
      ) {
        if (if_block2) {
          if_block2.p(ctx3, dirty);
        } else {
          if_block2 = create_if_block_33(ctx3);
          if_block2.c();
          if_block2.m(g2, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*element*/
        ctx3[2] === "text" && /*aesthetics*/
        ctx3[0].keys !== void 0
      ) {
        if (if_block3) {
          if_block3.p(ctx3, dirty);
        } else {
          if_block3 = create_if_block_23(ctx3);
          if_block3.c();
          if_block3.m(g2, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (dirty[0] & /*className*/
      2) {
        attr_dev(
          g2,
          "class",
          /*className*/
          ctx3[1]
        );
      }
      if (dirty[0] & /*aesthetics, $section*/
      9 && g_clip_path_value !== (g_clip_path_value = getClipPathURL(
        /*aesthetics*/
        ctx3[0],
        /*$section*/
        ctx3[3]
      ))) {
        attr_dev(g2, "clip-path", g_clip_path_value);
      }
      if (dirty[0] & /*className*/
      2 && g_data_testid_value !== (g_data_testid_value = testId(
        /*className*/
        ctx3[1]
      ))) {
        attr_dev(g2, "data-testid", g_data_testid_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(g2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(233:0) {#if renderer === 'svg'}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_5(ctx2) {
  let each_1_anchor;
  let each_value_3 = ensure_array_like_dev(
    /*svgData*/
    ctx2[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks[i2] = create_each_block_3(get_each_context_3(ctx2, each_value_3, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx3, dirty) {
      if (dirty[0] & /*svgData, className*/
      18) {
        each_value_3 = ensure_array_like_dev(
          /*svgData*/
          ctx3[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3(ctx3, each_value_3, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(241:4) {#if element === 'path' && aesthetics.keys === undefined}",
    ctx: ctx2
  });
  return block;
}
function create_each_block_3(ctx2) {
  let path3;
  let path_data_testid_value;
  let path_levels = [
    /*mark*/
    ctx2[49],
    {
      "data-testid": path_data_testid_value = testId(`${/*className*/
      ctx2[1]}-mark`)
    }
  ];
  let path_data = {};
  for (let i2 = 0; i2 < path_levels.length; i2 += 1) {
    path_data = assign(path_data, path_levels[i2]);
  }
  const block = {
    c: function create() {
      path3 = svg_element("path");
      set_svg_attributes(path3, path_data);
      add_location(path3, file5, 242, 8, 6964);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path3, anchor);
    },
    p: function update(ctx3, dirty) {
      set_svg_attributes(path3, path_data = get_spread_update(path_levels, [
        dirty[0] & /*svgData*/
        16 && /*mark*/
        ctx3[49],
        dirty[0] & /*className*/
        2 && path_data_testid_value !== (path_data_testid_value = testId(`${/*className*/
        ctx3[1]}-mark`)) && { "data-testid": path_data_testid_value }
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(242:6) {#each svgData as mark}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_4(ctx2) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value_2 = ensure_array_like_dev(
    /*svgData*/
    ctx2[4]
  );
  const get_key = (ctx3) => (
    /*aesthetics*/
    ctx3[0].keys[
      /*i*/
      ctx3[51]
    ]
  );
  validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key);
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    let child_ctx = get_each_context_2(ctx2, each_value_2, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_2(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx3, dirty) {
      if (dirty[0] & /*svgData, className, aesthetics*/
      19) {
        each_value_2 = ensure_array_like_dev(
          /*svgData*/
          ctx3[4]
        );
        validate_each_keys(ctx3, each_value_2, get_each_context_2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx3, each_value_2, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(250:4) {#if element === 'path' && aesthetics.keys !== undefined}",
    ctx: ctx2
  });
  return block;
}
function create_each_block_2(key_1, ctx2) {
  let path3;
  let path_data_testid_value;
  let path_levels = [
    /*mark*/
    ctx2[49],
    {
      "data-testid": path_data_testid_value = testId(`${/*className*/
      ctx2[1]}-mark`)
    }
  ];
  let path_data = {};
  for (let i2 = 0; i2 < path_levels.length; i2 += 1) {
    path_data = assign(path_data, path_levels[i2]);
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      path3 = svg_element("path");
      set_svg_attributes(path3, path_data);
      add_location(path3, file5, 251, 8, 7203);
      this.first = path3;
    },
    m: function mount(target, anchor) {
      insert_dev(target, path3, anchor);
    },
    p: function update(new_ctx, dirty) {
      ctx2 = new_ctx;
      set_svg_attributes(path3, path_data = get_spread_update(path_levels, [
        dirty[0] & /*svgData*/
        16 && /*mark*/
        ctx2[49],
        dirty[0] & /*className*/
        2 && path_data_testid_value !== (path_data_testid_value = testId(`${/*className*/
        ctx2[1]}-mark`)) && { "data-testid": path_data_testid_value }
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(251:6) {#each svgData as mark, i (aesthetics.keys[i])}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_33(ctx2) {
  let each_1_anchor;
  let each_value_1 = ensure_array_like_dev(
    /*svgData*/
    ctx2[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx2, each_value_1, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx3, dirty) {
      if (dirty[0] & /*svgData, className*/
      18) {
        each_value_1 = ensure_array_like_dev(
          /*svgData*/
          ctx3[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx3, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(259:4) {#if element === 'text' && aesthetics.keys === undefined}",
    ctx: ctx2
  });
  return block;
}
function create_each_block_1(ctx2) {
  let text_1;
  let t_value = (
    /*mark*/
    ctx2[49].text + ""
  );
  let t2;
  let text_1_data_testid_value;
  let text_1_levels = [
    /*mark*/
    ctx2[49],
    { text: void 0 },
    {
      "data-testid": text_1_data_testid_value = testId(`${/*className*/
      ctx2[1]}-mark`)
    }
  ];
  let text_data = {};
  for (let i2 = 0; i2 < text_1_levels.length; i2 += 1) {
    text_data = assign(text_data, text_1_levels[i2]);
  }
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      t2 = text(t_value);
      set_svg_attributes(text_1, text_data);
      add_location(text_1, file5, 260, 8, 7418);
    },
    m: function mount(target, anchor) {
      insert_dev(target, text_1, anchor);
      append_dev(text_1, t2);
    },
    p: function update(ctx3, dirty) {
      if (dirty[0] & /*svgData*/
      16 && t_value !== (t_value = /*mark*/
      ctx3[49].text + ""))
        set_data_maybe_contenteditable_dev(t2, t_value, text_data["contenteditable"]);
      set_svg_attributes(text_1, text_data = get_spread_update(text_1_levels, [
        dirty[0] & /*svgData*/
        16 && /*mark*/
        ctx3[49],
        { text: void 0 },
        dirty[0] & /*className*/
        2 && text_1_data_testid_value !== (text_1_data_testid_value = testId(`${/*className*/
        ctx3[1]}-mark`)) && { "data-testid": text_1_data_testid_value }
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(text_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(260:6) {#each svgData as mark}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_23(ctx2) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*svgData*/
    ctx2[4]
  );
  const get_key = (ctx3) => (
    /*aesthetics*/
    ctx3[0].keys[
      /*i*/
      ctx3[51]
    ]
  );
  validate_each_keys(ctx2, each_value, get_each_context, get_key);
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context(ctx2, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx3, dirty) {
      if (dirty[0] & /*svgData, className, aesthetics*/
      19) {
        each_value = ensure_array_like_dev(
          /*svgData*/
          ctx3[4]
        );
        validate_each_keys(ctx3, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx3, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block, each_1_anchor, get_each_context);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(271:4) {#if element === 'text' && aesthetics.keys !== undefined}",
    ctx: ctx2
  });
  return block;
}
function create_each_block(key_1, ctx2) {
  let text_1;
  let t_value = (
    /*mark*/
    ctx2[49].text + ""
  );
  let t2;
  let text_1_data_testid_value;
  let text_1_levels = [
    /*mark*/
    ctx2[49],
    { text: void 0 },
    {
      "data-testid": text_1_data_testid_value = testId(`${/*className*/
      ctx2[1]}-mark`)
    }
  ];
  let text_data = {};
  for (let i2 = 0; i2 < text_1_levels.length; i2 += 1) {
    text_data = assign(text_data, text_1_levels[i2]);
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      text_1 = svg_element("text");
      t2 = text(t_value);
      set_svg_attributes(text_1, text_data);
      add_location(text_1, file5, 272, 8, 7721);
      this.first = text_1;
    },
    m: function mount(target, anchor) {
      insert_dev(target, text_1, anchor);
      append_dev(text_1, t2);
    },
    p: function update(new_ctx, dirty) {
      ctx2 = new_ctx;
      if (dirty[0] & /*svgData*/
      16 && t_value !== (t_value = /*mark*/
      ctx2[49].text + ""))
        set_data_maybe_contenteditable_dev(t2, t_value, text_data["contenteditable"]);
      set_svg_attributes(text_1, text_data = get_spread_update(text_1_levels, [
        dirty[0] & /*svgData*/
        16 && /*mark*/
        ctx2[49],
        { text: void 0 },
        dirty[0] & /*className*/
        2 && text_1_data_testid_value !== (text_1_data_testid_value = testId(`${/*className*/
        ctx2[1]}-mark`)) && { "data-testid": text_1_data_testid_value }
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(text_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(272:6) {#each svgData as mark, i (aesthetics.keys[i])}",
    ctx: ctx2
  });
  return block;
}
function create_if_block4(ctx2) {
  let t2;
  const block = {
    c: function create() {
      t2 = text(
        /*id*/
        ctx2[9]
      );
    },
    m: function mount(target, anchor) {
      insert_dev(target, t2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(287:0) {#if renderer === 'canvas'}",
    ctx: ctx2
  });
  return block;
}
function create_fragment16(ctx2) {
  let t2;
  let if_block1_anchor;
  let if_block0 = (
    /*renderer*/
    ctx2[5] === "svg" && create_if_block_14(ctx2)
  );
  let if_block1 = (
    /*renderer*/
    ctx2[5] === "canvas" && create_if_block4(ctx2)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx3, dirty) {
      if (
        /*renderer*/
        ctx3[5] === "svg"
      )
        if_block0.p(ctx3, dirty);
      if (
        /*renderer*/
        ctx3[5] === "canvas"
      )
        if_block1.p(ctx3, dirty);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
var layerId = 0;
var getId6 = () => "l" + layerId++;
function instance16($$self, $$props, $$invalidate) {
  let primaryInput2;
  let isInteractiveMouse;
  let isInteractiveTouch;
  let isSelectable;
  let $interactionManager;
  let $globalBlockReindexing;
  let $section;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Layer", slots, []);
  let { positioning } = $$props;
  let { aesthetics } = $$props;
  let { createLayer } = $$props;
  let { parseAesthetics: parseAesthetics2 } = $$props;
  let { className } = $$props;
  let { element: element2 = "path" } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const { renderer, marksAndLayers, dirty, globalBlockReindexing } = getContext("graphic");
  validate_store(globalBlockReindexing, "globalBlockReindexing");
  component_subscribe($$self, globalBlockReindexing, (value) => $$invalidate(39, $globalBlockReindexing = value));
  const section = getContext("section");
  validate_store(section, "section");
  component_subscribe($$self, section, (value) => $$invalidate(3, $section = value));
  const interactionManager = getContext("interactionManager");
  validate_store(interactionManager, "interactionManager");
  component_subscribe($$self, interactionManager, (value) => $$invalidate(33, $interactionManager = value));
  const id = getId6();
  const createSVGContext = element2 === "path" ? svgStyled.pathLayer : svgStyled.textLayer;
  let mounted;
  onMount(() => {
    mounted = true;
    if (renderer === "canvas") {
      dirty.set(true);
    }
    updateInteractionManagerIfNecessary();
  });
  const isMounted = () => mounted;
  let layer = create();
  marksAndLayers[id] = layer;
  function create() {
    let _layer = createLayer(merge(positioning, aesthetics), $section, outputSettings);
    _layer.id = id;
    return _layer;
  }
  let svgContext;
  let svgData;
  if (renderer === "svg") {
    svgContext = createSVGContext();
    layer.render(svgContext);
    svgData = svgContext.result();
  }
  let updatePositioning = false;
  let updateAesthetics = false;
  function scheduleUpdatePositioning() {
    if (isMounted()) {
      $$invalidate(30, updatePositioning = true);
    }
  }
  function scheduleUpdateAesthetics() {
    if (isMounted()) {
      $$invalidate(31, updateAesthetics = true);
    }
  }
  function updateInteractionManagerIfNecessary() {
    if (blockReindexing === void 0) {
      if ($globalBlockReindexing)
        return;
    } else {
      if (blockReindexing === true)
        return;
    }
    if (isInteractiveMouse || isInteractiveTouch) {
      removeLayerFromSpatialIndexIfNecessary();
      if (isInteractiveMouse) {
        const markInterface = $interactionManager.mouse().marks();
        markInterface.loadLayer(layer);
        if (onClick)
          markInterface.addLayerInteraction("click", layer, onClick);
        if (onMousedown)
          markInterface.addLayerInteraction("mousedown", layer, onMousedown);
        if (onMouseup)
          markInterface.addLayerInteraction("mouseup", layer, onMouseup);
        if (onMouseout)
          markInterface.addLayerInteraction("mouseout", layer, onMouseout);
        if (onMouseover)
          markInterface.addLayerInteraction("mouseover", layer, onMouseover);
        if (onMousedrag)
          markInterface.addLayerInteraction("mousedrag", layer, onMousedrag);
      }
      if (isInteractiveTouch) {
        const markInterface = $interactionManager.touch().marks();
        markInterface.loadLayer(layer);
        if (onTouchdown)
          markInterface.addLayerInteraction("touchdown", layer, onTouchdown);
        if (onTouchup)
          markInterface.addLayerInteraction("touchup", layer, onTouchup);
        if (onTouchover)
          markInterface.addLayerInteraction("touchover", layer, onTouchover);
        if (onTouchout)
          markInterface.addLayerInteraction("touchout", layer, onTouchout);
        if (onTouchdrag)
          markInterface.addLayerInteraction("touchdrag", layer, onTouchdrag);
      }
    }
    removeLayerFromSelectIfNecessary();
    if (isSelectable) {
      const selectManager = $interactionManager.select();
      selectManager.loadLayer(layer, { onSelect, onDeselect });
    }
  }
  function removeLayerFromSpatialIndexIfNecessary() {
    if (primaryInput2 === "mouse") {
      const markMouseInterface = $interactionManager.mouse().marks();
      if (markMouseInterface.layerIsLoaded(layer)) {
        markMouseInterface.removeAllLayerInteractions(layer);
        markMouseInterface.removeLayer(layer);
      }
    }
    if (primaryInput2 === "touch") {
      const markTouchInterface = $interactionManager.touch().marks();
      if (markTouchInterface.layerIsLoaded(layer)) {
        markTouchInterface.removeAllLayerInteractions(layer);
        markTouchInterface.removeLayer(layer);
      }
    }
  }
  function removeLayerFromSelectIfNecessary() {
    const selectManager = $interactionManager.select();
    if (selectManager.layerIsLoaded(layer)) {
      selectManager.removeLayer(layer);
    }
  }
  onDestroy(() => {
    if (renderer === "canvas") {
      delete marksAndLayers[id];
      dirty.set(true);
    }
  });
  $$self.$$.on_mount.push(function() {
    if (positioning === void 0 && !("positioning" in $$props || $$self.$$.bound[$$self.$$.props["positioning"]])) {
      console.warn("<Layer> was created without expected prop 'positioning'");
    }
    if (aesthetics === void 0 && !("aesthetics" in $$props || $$self.$$.bound[$$self.$$.props["aesthetics"]])) {
      console.warn("<Layer> was created without expected prop 'aesthetics'");
    }
    if (createLayer === void 0 && !("createLayer" in $$props || $$self.$$.bound[$$self.$$.props["createLayer"]])) {
      console.warn("<Layer> was created without expected prop 'createLayer'");
    }
    if (parseAesthetics2 === void 0 && !("parseAesthetics" in $$props || $$self.$$.bound[$$self.$$.props["parseAesthetics"]])) {
      console.warn("<Layer> was created without expected prop 'parseAesthetics'");
    }
    if (className === void 0 && !("className" in $$props || $$self.$$.bound[$$self.$$.props["className"]])) {
      console.warn("<Layer> was created without expected prop 'className'");
    }
  });
  const writable_props = [
    "positioning",
    "aesthetics",
    "createLayer",
    "parseAesthetics",
    "className",
    "element",
    "outputSettings",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Layer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("positioning" in $$props2)
      $$invalidate(10, positioning = $$props2.positioning);
    if ("aesthetics" in $$props2)
      $$invalidate(0, aesthetics = $$props2.aesthetics);
    if ("createLayer" in $$props2)
      $$invalidate(11, createLayer = $$props2.createLayer);
    if ("parseAesthetics" in $$props2)
      $$invalidate(12, parseAesthetics2 = $$props2.parseAesthetics);
    if ("className" in $$props2)
      $$invalidate(1, className = $$props2.className);
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("outputSettings" in $$props2)
      $$invalidate(13, outputSettings = $$props2.outputSettings);
    if ("blockReindexing" in $$props2)
      $$invalidate(14, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(15, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(16, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(17, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(18, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(19, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(20, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(21, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(22, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(23, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(24, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(25, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(26, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(27, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    layerId,
    getId: getId6,
    getContext,
    onMount,
    onDestroy,
    svgStyled,
    getClipPathURL,
    any: any_default,
    merge,
    testId,
    positioning,
    aesthetics,
    createLayer,
    parseAesthetics: parseAesthetics2,
    className,
    element: element2,
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    renderer,
    marksAndLayers,
    dirty,
    globalBlockReindexing,
    section,
    interactionManager,
    id,
    createSVGContext,
    mounted,
    isMounted,
    layer,
    create,
    svgContext,
    svgData,
    updatePositioning,
    updateAesthetics,
    scheduleUpdatePositioning,
    scheduleUpdateAesthetics,
    updateInteractionManagerIfNecessary,
    removeLayerFromSpatialIndexIfNecessary,
    removeLayerFromSelectIfNecessary,
    primaryInput: primaryInput2,
    isSelectable,
    isInteractiveTouch,
    isInteractiveMouse,
    $interactionManager,
    $globalBlockReindexing,
    $section
  });
  $$self.$inject_state = ($$props2) => {
    if ("positioning" in $$props2)
      $$invalidate(10, positioning = $$props2.positioning);
    if ("aesthetics" in $$props2)
      $$invalidate(0, aesthetics = $$props2.aesthetics);
    if ("createLayer" in $$props2)
      $$invalidate(11, createLayer = $$props2.createLayer);
    if ("parseAesthetics" in $$props2)
      $$invalidate(12, parseAesthetics2 = $$props2.parseAesthetics);
    if ("className" in $$props2)
      $$invalidate(1, className = $$props2.className);
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("outputSettings" in $$props2)
      $$invalidate(13, outputSettings = $$props2.outputSettings);
    if ("blockReindexing" in $$props2)
      $$invalidate(14, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(15, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(16, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(17, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(18, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(19, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(20, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(21, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(22, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(23, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(24, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(25, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(26, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(27, onDeselect = $$props2.onDeselect);
    if ("mounted" in $$props2)
      mounted = $$props2.mounted;
    if ("layer" in $$props2)
      $$invalidate(28, layer = $$props2.layer);
    if ("svgContext" in $$props2)
      $$invalidate(29, svgContext = $$props2.svgContext);
    if ("svgData" in $$props2)
      $$invalidate(4, svgData = $$props2.svgData);
    if ("updatePositioning" in $$props2)
      $$invalidate(30, updatePositioning = $$props2.updatePositioning);
    if ("updateAesthetics" in $$props2)
      $$invalidate(31, updateAesthetics = $$props2.updateAesthetics);
    if ("primaryInput" in $$props2)
      $$invalidate(32, primaryInput2 = $$props2.primaryInput);
    if ("isSelectable" in $$props2)
      isSelectable = $$props2.isSelectable;
    if ("isInteractiveTouch" in $$props2)
      isInteractiveTouch = $$props2.isInteractiveTouch;
    if ("isInteractiveMouse" in $$props2)
      isInteractiveMouse = $$props2.isInteractiveMouse;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*positioning*/
    1024) {
      $: {
        if (positioning) {
          scheduleUpdatePositioning();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*aesthetics*/
    1) {
      $: {
        if (aesthetics) {
          scheduleUpdateAesthetics();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*$section, outputSettings*/
    8200) {
      $: {
        if ($section || outputSettings) {
          scheduleUpdatePositioning();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*updatePositioning, layer, svgContext, parseAesthetics, aesthetics*/
    1879052289 | $$self.$$.dirty[1] & /*updateAesthetics*/
    1) {
      $: {
        if (updatePositioning) {
          $$invalidate(28, layer = create());
          if (renderer === "svg") {
            $$invalidate(29, svgContext = createSVGContext());
            layer.render(svgContext);
            $$invalidate(4, svgData = svgContext.result());
          }
          if (renderer === "canvas") {
            marksAndLayers[id] = layer;
            dirty.set(true);
          }
          updateInteractionManagerIfNecessary();
        }
        if (!updatePositioning && updateAesthetics) {
          const parsedAesthetics = parseAesthetics2(aesthetics);
          const strokeWidthChanged = layer.props.strokeWidth !== parsedAesthetics.strokeWidth;
          const clipChanged = layer.props.clip !== parsedAesthetics.clip;
          layer.updateAesthetics(parsedAesthetics);
          if (strokeWidthChanged || clipChanged) {
            updateInteractionManagerIfNecessary();
          }
          if (renderer === "svg") {
            $$invalidate(29, svgContext = createSVGContext());
            layer.render(svgContext);
            $$invalidate(4, svgData = svgContext.result());
          }
          if (renderer === "canvas") {
            dirty.set(true);
          }
        }
        $$invalidate(30, updatePositioning = false);
        $$invalidate(31, updateAesthetics = false);
      }
    }
    if ($$self.$$.dirty[1] & /*$interactionManager*/
    4) {
      $:
        $$invalidate(32, primaryInput2 = $interactionManager.getPrimaryInput());
    }
    if ($$self.$$.dirty[0] & /*onClick, onMousedown, onMouseup, onMouseover, onMouseout, onMousedrag*/
    2064384 | $$self.$$.dirty[1] & /*primaryInput*/
    2) {
      $:
        isInteractiveMouse = primaryInput2 === "mouse" && any_default(onClick, onMousedown, onMouseup, onMouseover, onMouseout, onMousedrag);
    }
    if ($$self.$$.dirty[0] & /*onTouchdown, onTouchup, onTouchover, onTouchout, onTouchdrag*/
    65011712 | $$self.$$.dirty[1] & /*primaryInput*/
    2) {
      $:
        isInteractiveTouch = primaryInput2 === "touch" && any_default(onTouchdown, onTouchup, onTouchover, onTouchout, onTouchdrag);
    }
    if ($$self.$$.dirty[0] & /*onSelect, onDeselect*/
    201326592) {
      $:
        isSelectable = any_default(onSelect, onDeselect);
    }
  };
  return [
    aesthetics,
    className,
    element2,
    $section,
    svgData,
    renderer,
    globalBlockReindexing,
    section,
    interactionManager,
    id,
    positioning,
    createLayer,
    parseAesthetics2,
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    layer,
    svgContext,
    updatePositioning,
    updateAesthetics,
    primaryInput2,
    $interactionManager
  ];
}
var Layer2 = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        positioning: 10,
        aesthetics: 0,
        createLayer: 11,
        parseAesthetics: 12,
        className: 1,
        element: 2,
        outputSettings: 13,
        blockReindexing: 14,
        onClick: 15,
        onMousedown: 16,
        onMouseup: 17,
        onMouseover: 18,
        onMouseout: 19,
        onMousedrag: 20,
        onTouchdown: 21,
        onTouchup: 22,
        onTouchover: 23,
        onTouchout: 24,
        onTouchdrag: 25,
        onSelect: 26,
        onDeselect: 27
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Layer",
      options: options2,
      id: create_fragment16.name
    });
  }
  get positioning() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positioning(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aesthetics() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aesthetics(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get createLayer() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createLayer(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parseAesthetics() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parseAesthetics(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get className() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set className(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<Layer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<Layer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Layer_default = Layer2;

// node_modules/@snlab/florence/src/components/marks/point/PointLayer.svelte
function create_fragment17(ctx2) {
  let layer;
  let current;
  layer = new Layer_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createLayer: createPointLayer,
      parseAesthetics: parseAestheticsPointLayer,
      className: "point-layer",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(layer, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const layer_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        layer_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        layer_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        layer_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        layer_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        layer_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        layer_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        layer_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        layer_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        layer_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        layer_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        layer_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        layer_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        layer_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        layer_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        layer_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        layer_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        layer_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      layer.$set(layer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PointLayer", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { radius = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { keys = void 0 } = $$props;
  let { asOnePath = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "radius",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "keys",
    "asOnePath",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PointLayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("radius" in $$props2)
      $$invalidate(20, radius = $$props2.radius);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(24, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(27, lineCap = $$props2.lineCap);
    if ("dashArray" in $$props2)
      $$invalidate(28, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(29, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(30, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(31, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(32, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createPointLayer,
    parseAestheticsPointLayer,
    Layer: Layer_default,
    x: x3,
    y: y3,
    geometry,
    radius,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    keys,
    asOnePath,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("radius" in $$props2)
      $$invalidate(20, radius = $$props2.radius);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(24, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(27, lineCap = $$props2.lineCap);
    if ("dashArray" in $$props2)
      $$invalidate(28, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(29, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(30, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(31, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(32, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, geometry, radius*/
    1966080) {
      $:
        $$invalidate(16, positioning = { x: x3, y: y3, geometry, radius });
    }
    if ($$self.$$.dirty[0] & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap, dashArray, dashOffset, clip*/
    2145386496 | $$self.$$.dirty[1] & /*keys, asOnePath*/
    3) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          dashArray,
          dashOffset,
          clip,
          keys,
          asOnePath
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    radius,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    dashArray,
    dashOffset,
    clip,
    keys,
    asOnePath
  ];
}
var PointLayer = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        geometry: 19,
        radius: 20,
        fill: 21,
        stroke: 22,
        strokeWidth: 23,
        strokeOpacity: 24,
        fillOpacity: 25,
        opacity: 26,
        lineCap: 27,
        dashArray: 28,
        dashOffset: 29,
        outputSettings: 0,
        clip: 30,
        keys: 31,
        asOnePath: 32,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PointLayer",
      options: options2,
      id: create_fragment17.name
    });
  }
  get x() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keys() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asOnePath() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asOnePath(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<PointLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<PointLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PointLayer_default = PointLayer;

// node_modules/@snlab/florence/src/components/marks/rectangle/RectangleLayer.svelte
function create_fragment18(ctx2) {
  let layer;
  let current;
  layer = new Layer_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createLayer: createRectangleLayer,
      parseAesthetics: parseAestheticsRectangleLayer,
      className: "rectangle-layer",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(layer, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const layer_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        layer_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        layer_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        layer_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        layer_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        layer_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        layer_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        layer_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        layer_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        layer_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        layer_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        layer_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        layer_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        layer_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        layer_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        layer_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        layer_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        layer_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      layer.$set(layer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RectangleLayer", slots, []);
  let { x1 = void 0 } = $$props;
  let { x2: x23 = void 0 } = $$props;
  let { y1 = void 0 } = $$props;
  let { y2: y23 = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { keys = void 0 } = $$props;
  let { asOnePath = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x1",
    "x2",
    "y1",
    "y2",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "keys",
    "asOnePath",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RectangleLayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(17, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(18, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(19, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(20, y23 = $$props2.y2);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(24, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(27, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(28, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(29, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(30, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(31, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(32, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(33, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(34, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createRectangleLayer,
    parseAestheticsRectangleLayer,
    Layer: Layer_default,
    x1,
    x2: x23,
    y1,
    y2: y23,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    keys,
    asOnePath,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(17, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(18, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(19, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(20, y23 = $$props2.y2);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(24, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(25, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(26, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(27, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(28, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(29, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(30, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(31, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(32, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(33, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(34, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x1, x2, y1, y2*/
    1966080) {
      $:
        $$invalidate(16, positioning = { x1, x2: x23, y1, y2: y23 });
    }
    if ($$self.$$.dirty[0] & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap, lineJoin, miterLimit, dashArray*/
    2145386496 | $$self.$$.dirty[1] & /*dashOffset, clip, keys, asOnePath*/
    15) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          lineJoin,
          miterLimit,
          dashArray,
          dashOffset,
          clip,
          keys,
          asOnePath
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x1,
    x23,
    y1,
    y23,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip,
    keys,
    asOnePath
  ];
}
var RectangleLayer = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance18,
      create_fragment18,
      safe_not_equal,
      {
        x1: 17,
        x2: 18,
        y1: 19,
        y2: 20,
        fill: 21,
        stroke: 22,
        strokeWidth: 23,
        strokeOpacity: 24,
        fillOpacity: 25,
        opacity: 26,
        lineCap: 27,
        lineJoin: 28,
        miterLimit: 29,
        dashArray: 30,
        dashOffset: 31,
        outputSettings: 0,
        clip: 32,
        keys: 33,
        asOnePath: 34,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RectangleLayer",
      options: options2,
      id: create_fragment18.name
    });
  }
  get x1() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x1(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x2() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x2(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y1() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y1(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y2() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y2(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keys() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asOnePath() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asOnePath(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<RectangleLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<RectangleLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RectangleLayer_default = RectangleLayer;

// node_modules/@snlab/florence/src/components/marks/polygon/PolygonLayer.svelte
function create_fragment19(ctx2) {
  let layer;
  let current;
  layer = new Layer_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createLayer: createPolygonLayer,
      parseAesthetics: parseAestheticsPolygonLayer,
      className: "polygon-layer",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(layer, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const layer_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        layer_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        layer_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        layer_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        layer_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        layer_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        layer_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        layer_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        layer_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        layer_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        layer_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        layer_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        layer_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        layer_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        layer_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        layer_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        layer_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        layer_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      layer.$set(layer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PolygonLayer", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { keys = void 0 } = $$props;
  let { asOnePath = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "keys",
    "asOnePath",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PolygonLayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("fill" in $$props2)
      $$invalidate(20, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(21, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(22, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(23, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(24, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(25, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(26, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(27, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(28, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(29, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(30, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(31, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(32, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(33, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createPolygonLayer,
    parseAestheticsPolygonLayer,
    Layer: Layer_default,
    x: x3,
    y: y3,
    geometry,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    keys,
    asOnePath,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("fill" in $$props2)
      $$invalidate(20, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(21, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(22, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(23, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(24, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(25, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(26, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(27, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(28, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(29, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(30, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(31, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(32, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(33, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, geometry*/
    917504) {
      $:
        $$invalidate(16, positioning = { x: x3, y: y3, geometry });
    }
    if ($$self.$$.dirty[0] & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap, lineJoin, miterLimit, dashArray, dashOffset*/
    2146435072 | $$self.$$.dirty[1] & /*clip, keys, asOnePath*/
    7) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          lineJoin,
          miterLimit,
          dashArray,
          dashOffset,
          clip,
          keys,
          asOnePath
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip,
    keys,
    asOnePath
  ];
}
var PolygonLayer = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance19,
      create_fragment19,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        geometry: 19,
        fill: 20,
        stroke: 21,
        strokeWidth: 22,
        strokeOpacity: 23,
        fillOpacity: 24,
        opacity: 25,
        lineCap: 26,
        lineJoin: 27,
        miterLimit: 28,
        dashArray: 29,
        dashOffset: 30,
        outputSettings: 0,
        clip: 31,
        keys: 32,
        asOnePath: 33,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PolygonLayer",
      options: options2,
      id: create_fragment19.name
    });
  }
  get x() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keys() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asOnePath() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asOnePath(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<PolygonLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<PolygonLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PolygonLayer_default = PolygonLayer;

// node_modules/@snlab/florence/src/components/marks/line/LineLayer.svelte
function create_fragment20(ctx2) {
  let layer;
  let current;
  layer = new Layer_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createLayer: createLineLayer,
      parseAesthetics: parseAestheticsLineLayer,
      className: "line-layer",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(layer, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const layer_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        layer_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        layer_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        layer_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        layer_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        layer_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        layer_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        layer_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        layer_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        layer_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        layer_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        layer_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        layer_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        layer_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        layer_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        layer_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        layer_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        layer_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      layer.$set(layer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineLayer", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { curve = void 0 } = $$props;
  let { _resampleIntervals = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { keys = void 0 } = $$props;
  let { asOnePath = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "curve",
    "_resampleIntervals",
    "stroke",
    "strokeWidth",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "keys",
    "asOnePath",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LineLayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("curve" in $$props2)
      $$invalidate(20, curve = $$props2.curve);
    if ("_resampleIntervals" in $$props2)
      $$invalidate(21, _resampleIntervals = $$props2._resampleIntervals);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("opacity" in $$props2)
      $$invalidate(24, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(25, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(26, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(27, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(28, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(29, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(30, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(31, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(32, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createLineLayer,
    parseAestheticsLineLayer,
    Layer: Layer_default,
    x: x3,
    y: y3,
    geometry,
    curve,
    _resampleIntervals,
    stroke,
    strokeWidth,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    keys,
    asOnePath,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("curve" in $$props2)
      $$invalidate(20, curve = $$props2.curve);
    if ("_resampleIntervals" in $$props2)
      $$invalidate(21, _resampleIntervals = $$props2._resampleIntervals);
    if ("stroke" in $$props2)
      $$invalidate(22, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(23, strokeWidth = $$props2.strokeWidth);
    if ("opacity" in $$props2)
      $$invalidate(24, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(25, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(26, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(27, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(28, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(29, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(30, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(31, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(32, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, geometry, curve, _resampleIntervals*/
    4063232) {
      $:
        $$invalidate(16, positioning = {
          x: x3,
          y: y3,
          geometry,
          curve,
          _resampleIntervals
        });
    }
    if ($$self.$$.dirty[0] & /*stroke, strokeWidth, opacity, lineCap, dashArray, lineJoin, miterLimit, dashOffset, clip*/
    2143289344 | $$self.$$.dirty[1] & /*keys, asOnePath*/
    3) {
      $:
        $$invalidate(15, aesthetics = {
          stroke,
          strokeWidth,
          opacity,
          lineCap,
          dashArray,
          lineJoin,
          miterLimit,
          dashOffset,
          clip,
          keys,
          asOnePath
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    curve,
    _resampleIntervals,
    stroke,
    strokeWidth,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip,
    keys,
    asOnePath
  ];
}
var LineLayer = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance20,
      create_fragment20,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        geometry: 19,
        curve: 20,
        _resampleIntervals: 21,
        stroke: 22,
        strokeWidth: 23,
        opacity: 24,
        lineCap: 25,
        lineJoin: 26,
        miterLimit: 27,
        dashArray: 28,
        dashOffset: 29,
        outputSettings: 0,
        clip: 30,
        keys: 31,
        asOnePath: 32,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineLayer",
      options: options2,
      id: create_fragment20.name
    });
  }
  get x() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get curve() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set curve(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get _resampleIntervals() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set _resampleIntervals(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keys() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asOnePath() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asOnePath(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<LineLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<LineLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineLayer_default = LineLayer;

// node_modules/@snlab/florence/src/components/marks/label/LabelLayer.svelte
function create_fragment21(ctx2) {
  let layer;
  let current;
  layer = new Layer_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createLayer: createLabelLayer,
      parseAesthetics: parseAestheticsLabelLayer,
      className: "label-layer",
      element: "text",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(layer, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const layer_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        layer_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        layer_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        layer_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        layer_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        layer_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        layer_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        layer_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        layer_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        layer_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        layer_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        layer_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        layer_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        layer_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        layer_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        layer_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        layer_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        layer_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      layer.$set(layer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LabelLayer", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { rotate = void 0 } = $$props;
  let { anchorPoint = void 0 } = $$props;
  let { text: text3 = void 0 } = $$props;
  let { fontSize = void 0 } = $$props;
  let { fontFamily = void 0 } = $$props;
  let { fontWeight = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { keys = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "rotate",
    "anchorPoint",
    "text",
    "fontSize",
    "fontFamily",
    "fontWeight",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "outputSettings",
    "clip",
    "keys",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LabelLayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("rotate" in $$props2)
      $$invalidate(20, rotate = $$props2.rotate);
    if ("anchorPoint" in $$props2)
      $$invalidate(21, anchorPoint = $$props2.anchorPoint);
    if ("text" in $$props2)
      $$invalidate(22, text3 = $$props2.text);
    if ("fontSize" in $$props2)
      $$invalidate(23, fontSize = $$props2.fontSize);
    if ("fontFamily" in $$props2)
      $$invalidate(24, fontFamily = $$props2.fontFamily);
    if ("fontWeight" in $$props2)
      $$invalidate(25, fontWeight = $$props2.fontWeight);
    if ("fill" in $$props2)
      $$invalidate(26, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(27, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(28, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(29, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(30, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(31, opacity = $$props2.opacity);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(32, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(33, keys = $$props2.keys);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createLabelLayer,
    parseAestheticsLabelLayer,
    Layer: Layer_default,
    x: x3,
    y: y3,
    geometry,
    rotate,
    anchorPoint,
    text: text3,
    fontSize,
    fontFamily,
    fontWeight,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    outputSettings,
    clip,
    keys,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("rotate" in $$props2)
      $$invalidate(20, rotate = $$props2.rotate);
    if ("anchorPoint" in $$props2)
      $$invalidate(21, anchorPoint = $$props2.anchorPoint);
    if ("text" in $$props2)
      $$invalidate(22, text3 = $$props2.text);
    if ("fontSize" in $$props2)
      $$invalidate(23, fontSize = $$props2.fontSize);
    if ("fontFamily" in $$props2)
      $$invalidate(24, fontFamily = $$props2.fontFamily);
    if ("fontWeight" in $$props2)
      $$invalidate(25, fontWeight = $$props2.fontWeight);
    if ("fill" in $$props2)
      $$invalidate(26, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(27, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(28, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(29, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(30, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(31, opacity = $$props2.opacity);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(32, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(33, keys = $$props2.keys);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, geometry, rotate, anchorPoint, text, fontSize*/
    16646144) {
      $:
        $$invalidate(16, positioning = {
          x: x3,
          y: y3,
          geometry,
          rotate,
          anchorPoint,
          text: text3,
          fontSize
        });
    }
    if ($$self.$$.dirty[0] & /*anchorPoint, text, fontSize, fontFamily, fontWeight, fill, stroke, strokeWidth, strokeOpacity, fillOpacity*/
    2145386496 | $$self.$$.dirty[1] & /*opacity, clip, keys*/
    7) {
      $:
        $$invalidate(15, aesthetics = {
          anchorPoint,
          text: text3,
          fontSize,
          fontFamily,
          fontWeight,
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          clip,
          keys
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    rotate,
    anchorPoint,
    text3,
    fontSize,
    fontFamily,
    fontWeight,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    clip,
    keys
  ];
}
var LabelLayer = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance21,
      create_fragment21,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        geometry: 19,
        rotate: 20,
        anchorPoint: 21,
        text: 22,
        fontSize: 23,
        fontFamily: 24,
        fontWeight: 25,
        fill: 26,
        stroke: 27,
        strokeWidth: 28,
        strokeOpacity: 29,
        fillOpacity: 30,
        opacity: 31,
        outputSettings: 0,
        clip: 32,
        keys: 33,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LabelLayer",
      options: options2,
      id: create_fragment21.name
    });
  }
  get x() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotate() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotate(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorPoint() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorPoint(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSize() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSize(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontFamily() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontFamily(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontWeight() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontWeight(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keys() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<LabelLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<LabelLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LabelLayer_default = LabelLayer;

// node_modules/@snlab/florence/src/components/marks/symbol/SymbolLayer.svelte
function create_fragment22(ctx2) {
  let layer;
  let current;
  layer = new Layer_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createLayer: createSymbolLayer,
      parseAesthetics: parseAestheticsSymbolLayer,
      className: "symbol-layer",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(layer, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const layer_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        layer_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        layer_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        layer_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        layer_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        layer_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        layer_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        layer_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        layer_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        layer_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        layer_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        layer_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        layer_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        layer_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        layer_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        layer_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        layer_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        layer_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      layer.$set(layer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SymbolLayer", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { geometry = void 0 } = $$props;
  let { shape = void 0 } = $$props;
  let { radius = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { keys = void 0 } = $$props;
  let { asOnePath = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "geometry",
    "shape",
    "radius",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "keys",
    "asOnePath",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SymbolLayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("shape" in $$props2)
      $$invalidate(20, shape = $$props2.shape);
    if ("radius" in $$props2)
      $$invalidate(21, radius = $$props2.radius);
    if ("fill" in $$props2)
      $$invalidate(22, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(23, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(24, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(25, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(26, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(27, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(28, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(29, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(30, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(31, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(32, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(33, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(34, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(35, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createSymbolLayer,
    parseAestheticsSymbolLayer,
    Layer: Layer_default,
    x: x3,
    y: y3,
    geometry,
    shape,
    radius,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    keys,
    asOnePath,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("geometry" in $$props2)
      $$invalidate(19, geometry = $$props2.geometry);
    if ("shape" in $$props2)
      $$invalidate(20, shape = $$props2.shape);
    if ("radius" in $$props2)
      $$invalidate(21, radius = $$props2.radius);
    if ("fill" in $$props2)
      $$invalidate(22, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(23, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(24, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(25, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(26, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(27, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(28, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(29, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(30, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(31, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(32, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(33, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(34, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(35, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, geometry, shape, radius*/
    4063232) {
      $:
        $$invalidate(16, positioning = { x: x3, y: y3, geometry, shape, radius });
    }
    if ($$self.$$.dirty[0] & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap, lineJoin, miterLimit*/
    2143289344 | $$self.$$.dirty[1] & /*dashArray, dashOffset, clip, keys, asOnePath*/
    31) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          lineJoin,
          miterLimit,
          dashArray,
          dashOffset,
          clip,
          keys,
          asOnePath
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    geometry,
    shape,
    radius,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip,
    keys,
    asOnePath
  ];
}
var SymbolLayer = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance22,
      create_fragment22,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        geometry: 19,
        shape: 20,
        radius: 21,
        fill: 22,
        stroke: 23,
        strokeWidth: 24,
        strokeOpacity: 25,
        fillOpacity: 26,
        opacity: 27,
        lineCap: 28,
        lineJoin: 29,
        miterLimit: 30,
        dashArray: 31,
        dashOffset: 32,
        outputSettings: 0,
        clip: 33,
        keys: 34,
        asOnePath: 35,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SymbolLayer",
      options: options2,
      id: create_fragment22.name
    });
  }
  get x() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shape() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shape(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keys() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asOnePath() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asOnePath(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<SymbolLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<SymbolLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SymbolLayer_default = SymbolLayer;

// node_modules/@snlab/florence/src/components/marks/area/AreaLayer.svelte
function create_fragment23(ctx2) {
  let layer;
  let current;
  layer = new Layer_default({
    props: {
      positioning: (
        /*positioning*/
        ctx2[16]
      ),
      aesthetics: (
        /*aesthetics*/
        ctx2[15]
      ),
      createLayer: createAreaLayer,
      parseAesthetics: parseAestheticsAreaLayer,
      className: "area-layer",
      outputSettings: (
        /*outputSettings*/
        ctx2[0]
      ),
      blockReindexing: (
        /*blockReindexing*/
        ctx2[1]
      ),
      onClick: (
        /*onClick*/
        ctx2[2]
      ),
      onMousedown: (
        /*onMousedown*/
        ctx2[3]
      ),
      onMouseup: (
        /*onMouseup*/
        ctx2[4]
      ),
      onMouseover: (
        /*onMouseover*/
        ctx2[5]
      ),
      onMouseout: (
        /*onMouseout*/
        ctx2[6]
      ),
      onMousedrag: (
        /*onMousedrag*/
        ctx2[7]
      ),
      onTouchdown: (
        /*onTouchdown*/
        ctx2[8]
      ),
      onTouchup: (
        /*onTouchup*/
        ctx2[9]
      ),
      onTouchover: (
        /*onTouchover*/
        ctx2[10]
      ),
      onTouchout: (
        /*onTouchout*/
        ctx2[11]
      ),
      onTouchdrag: (
        /*onTouchdrag*/
        ctx2[12]
      ),
      onSelect: (
        /*onSelect*/
        ctx2[13]
      ),
      onDeselect: (
        /*onDeselect*/
        ctx2[14]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(layer, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const layer_changes = {};
      if (dirty[0] & /*positioning*/
      65536)
        layer_changes.positioning = /*positioning*/
        ctx3[16];
      if (dirty[0] & /*aesthetics*/
      32768)
        layer_changes.aesthetics = /*aesthetics*/
        ctx3[15];
      if (dirty[0] & /*outputSettings*/
      1)
        layer_changes.outputSettings = /*outputSettings*/
        ctx3[0];
      if (dirty[0] & /*blockReindexing*/
      2)
        layer_changes.blockReindexing = /*blockReindexing*/
        ctx3[1];
      if (dirty[0] & /*onClick*/
      4)
        layer_changes.onClick = /*onClick*/
        ctx3[2];
      if (dirty[0] & /*onMousedown*/
      8)
        layer_changes.onMousedown = /*onMousedown*/
        ctx3[3];
      if (dirty[0] & /*onMouseup*/
      16)
        layer_changes.onMouseup = /*onMouseup*/
        ctx3[4];
      if (dirty[0] & /*onMouseover*/
      32)
        layer_changes.onMouseover = /*onMouseover*/
        ctx3[5];
      if (dirty[0] & /*onMouseout*/
      64)
        layer_changes.onMouseout = /*onMouseout*/
        ctx3[6];
      if (dirty[0] & /*onMousedrag*/
      128)
        layer_changes.onMousedrag = /*onMousedrag*/
        ctx3[7];
      if (dirty[0] & /*onTouchdown*/
      256)
        layer_changes.onTouchdown = /*onTouchdown*/
        ctx3[8];
      if (dirty[0] & /*onTouchup*/
      512)
        layer_changes.onTouchup = /*onTouchup*/
        ctx3[9];
      if (dirty[0] & /*onTouchover*/
      1024)
        layer_changes.onTouchover = /*onTouchover*/
        ctx3[10];
      if (dirty[0] & /*onTouchout*/
      2048)
        layer_changes.onTouchout = /*onTouchout*/
        ctx3[11];
      if (dirty[0] & /*onTouchdrag*/
      4096)
        layer_changes.onTouchdrag = /*onTouchdrag*/
        ctx3[12];
      if (dirty[0] & /*onSelect*/
      8192)
        layer_changes.onSelect = /*onSelect*/
        ctx3[13];
      if (dirty[0] & /*onDeselect*/
      16384)
        layer_changes.onDeselect = /*onDeselect*/
        ctx3[14];
      layer.$set(layer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(layer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let positioning;
  let aesthetics;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AreaLayer", slots, []);
  let { x: x3 = void 0 } = $$props;
  let { y: y3 = void 0 } = $$props;
  let { x1 = void 0 } = $$props;
  let { x2: x23 = void 0 } = $$props;
  let { y1 = void 0 } = $$props;
  let { y2: y23 = void 0 } = $$props;
  let { curve = void 0 } = $$props;
  let { fill = void 0 } = $$props;
  let { stroke = void 0 } = $$props;
  let { strokeWidth = void 0 } = $$props;
  let { strokeOpacity = void 0 } = $$props;
  let { fillOpacity = void 0 } = $$props;
  let { opacity = void 0 } = $$props;
  let { lineCap = void 0 } = $$props;
  let { lineJoin = void 0 } = $$props;
  let { miterLimit = void 0 } = $$props;
  let { dashArray = void 0 } = $$props;
  let { dashOffset = void 0 } = $$props;
  let { outputSettings = void 0 } = $$props;
  let { clip = void 0 } = $$props;
  let { keys = void 0 } = $$props;
  let { asOnePath = void 0 } = $$props;
  let { blockReindexing = void 0 } = $$props;
  let { onClick = void 0 } = $$props;
  let { onMousedown = void 0 } = $$props;
  let { onMouseup = void 0 } = $$props;
  let { onMouseover = void 0 } = $$props;
  let { onMouseout = void 0 } = $$props;
  let { onMousedrag = void 0 } = $$props;
  let { onTouchdown = void 0 } = $$props;
  let { onTouchup = void 0 } = $$props;
  let { onTouchover = void 0 } = $$props;
  let { onTouchout = void 0 } = $$props;
  let { onTouchdrag = void 0 } = $$props;
  let { onSelect = void 0 } = $$props;
  let { onDeselect = void 0 } = $$props;
  const writable_props = [
    "x",
    "y",
    "x1",
    "x2",
    "y1",
    "y2",
    "curve",
    "fill",
    "stroke",
    "strokeWidth",
    "strokeOpacity",
    "fillOpacity",
    "opacity",
    "lineCap",
    "lineJoin",
    "miterLimit",
    "dashArray",
    "dashOffset",
    "outputSettings",
    "clip",
    "keys",
    "asOnePath",
    "blockReindexing",
    "onClick",
    "onMousedown",
    "onMouseup",
    "onMouseover",
    "onMouseout",
    "onMousedrag",
    "onTouchdown",
    "onTouchup",
    "onTouchover",
    "onTouchout",
    "onTouchdrag",
    "onSelect",
    "onDeselect"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AreaLayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("x1" in $$props2)
      $$invalidate(19, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(20, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(21, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(22, y23 = $$props2.y2);
    if ("curve" in $$props2)
      $$invalidate(23, curve = $$props2.curve);
    if ("fill" in $$props2)
      $$invalidate(24, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(25, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(26, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(27, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(28, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(29, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(30, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(31, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(32, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(33, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(34, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(35, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(36, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(37, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
  };
  $$self.$capture_state = () => ({
    createAreaLayer,
    parseAestheticsAreaLayer,
    Layer: Layer_default,
    x: x3,
    y: y3,
    x1,
    x2: x23,
    y1,
    y2: y23,
    curve,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    outputSettings,
    clip,
    keys,
    asOnePath,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning
  });
  $$self.$inject_state = ($$props2) => {
    if ("x" in $$props2)
      $$invalidate(17, x3 = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(18, y3 = $$props2.y);
    if ("x1" in $$props2)
      $$invalidate(19, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(20, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(21, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(22, y23 = $$props2.y2);
    if ("curve" in $$props2)
      $$invalidate(23, curve = $$props2.curve);
    if ("fill" in $$props2)
      $$invalidate(24, fill = $$props2.fill);
    if ("stroke" in $$props2)
      $$invalidate(25, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(26, strokeWidth = $$props2.strokeWidth);
    if ("strokeOpacity" in $$props2)
      $$invalidate(27, strokeOpacity = $$props2.strokeOpacity);
    if ("fillOpacity" in $$props2)
      $$invalidate(28, fillOpacity = $$props2.fillOpacity);
    if ("opacity" in $$props2)
      $$invalidate(29, opacity = $$props2.opacity);
    if ("lineCap" in $$props2)
      $$invalidate(30, lineCap = $$props2.lineCap);
    if ("lineJoin" in $$props2)
      $$invalidate(31, lineJoin = $$props2.lineJoin);
    if ("miterLimit" in $$props2)
      $$invalidate(32, miterLimit = $$props2.miterLimit);
    if ("dashArray" in $$props2)
      $$invalidate(33, dashArray = $$props2.dashArray);
    if ("dashOffset" in $$props2)
      $$invalidate(34, dashOffset = $$props2.dashOffset);
    if ("outputSettings" in $$props2)
      $$invalidate(0, outputSettings = $$props2.outputSettings);
    if ("clip" in $$props2)
      $$invalidate(35, clip = $$props2.clip);
    if ("keys" in $$props2)
      $$invalidate(36, keys = $$props2.keys);
    if ("asOnePath" in $$props2)
      $$invalidate(37, asOnePath = $$props2.asOnePath);
    if ("blockReindexing" in $$props2)
      $$invalidate(1, blockReindexing = $$props2.blockReindexing);
    if ("onClick" in $$props2)
      $$invalidate(2, onClick = $$props2.onClick);
    if ("onMousedown" in $$props2)
      $$invalidate(3, onMousedown = $$props2.onMousedown);
    if ("onMouseup" in $$props2)
      $$invalidate(4, onMouseup = $$props2.onMouseup);
    if ("onMouseover" in $$props2)
      $$invalidate(5, onMouseover = $$props2.onMouseover);
    if ("onMouseout" in $$props2)
      $$invalidate(6, onMouseout = $$props2.onMouseout);
    if ("onMousedrag" in $$props2)
      $$invalidate(7, onMousedrag = $$props2.onMousedrag);
    if ("onTouchdown" in $$props2)
      $$invalidate(8, onTouchdown = $$props2.onTouchdown);
    if ("onTouchup" in $$props2)
      $$invalidate(9, onTouchup = $$props2.onTouchup);
    if ("onTouchover" in $$props2)
      $$invalidate(10, onTouchover = $$props2.onTouchover);
    if ("onTouchout" in $$props2)
      $$invalidate(11, onTouchout = $$props2.onTouchout);
    if ("onTouchdrag" in $$props2)
      $$invalidate(12, onTouchdrag = $$props2.onTouchdrag);
    if ("onSelect" in $$props2)
      $$invalidate(13, onSelect = $$props2.onSelect);
    if ("onDeselect" in $$props2)
      $$invalidate(14, onDeselect = $$props2.onDeselect);
    if ("aesthetics" in $$props2)
      $$invalidate(15, aesthetics = $$props2.aesthetics);
    if ("positioning" in $$props2)
      $$invalidate(16, positioning = $$props2.positioning);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*x, y, x1, x2, y1, y2, curve*/
    16646144) {
      $:
        $$invalidate(16, positioning = { x: x3, y: y3, x1, x2: x23, y1, y2: y23, curve });
    }
    if ($$self.$$.dirty[0] & /*fill, stroke, strokeWidth, strokeOpacity, fillOpacity, opacity, lineCap*/
    2130706432 | $$self.$$.dirty[1] & /*lineJoin, miterLimit, dashArray, dashOffset, clip, keys, asOnePath*/
    127) {
      $:
        $$invalidate(15, aesthetics = {
          fill,
          stroke,
          strokeWidth,
          strokeOpacity,
          fillOpacity,
          opacity,
          lineCap,
          lineJoin,
          miterLimit,
          dashArray,
          dashOffset,
          clip,
          keys,
          asOnePath
        });
    }
  };
  return [
    outputSettings,
    blockReindexing,
    onClick,
    onMousedown,
    onMouseup,
    onMouseover,
    onMouseout,
    onMousedrag,
    onTouchdown,
    onTouchup,
    onTouchover,
    onTouchout,
    onTouchdrag,
    onSelect,
    onDeselect,
    aesthetics,
    positioning,
    x3,
    y3,
    x1,
    x23,
    y1,
    y23,
    curve,
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    fillOpacity,
    opacity,
    lineCap,
    lineJoin,
    miterLimit,
    dashArray,
    dashOffset,
    clip,
    keys,
    asOnePath
  ];
}
var AreaLayer = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance23,
      create_fragment23,
      safe_not_equal,
      {
        x: 17,
        y: 18,
        x1: 19,
        x2: 20,
        y1: 21,
        y2: 22,
        curve: 23,
        fill: 24,
        stroke: 25,
        strokeWidth: 26,
        strokeOpacity: 27,
        fillOpacity: 28,
        opacity: 29,
        lineCap: 30,
        lineJoin: 31,
        miterLimit: 32,
        dashArray: 33,
        dashOffset: 34,
        outputSettings: 0,
        clip: 35,
        keys: 36,
        asOnePath: 37,
        blockReindexing: 1,
        onClick: 2,
        onMousedown: 3,
        onMouseup: 4,
        onMouseover: 5,
        onMouseout: 6,
        onMousedrag: 7,
        onTouchdown: 8,
        onTouchup: 9,
        onTouchover: 10,
        onTouchout: 11,
        onTouchdrag: 12,
        onSelect: 13,
        onDeselect: 14
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AreaLayer",
      options: options2,
      id: create_fragment23.name
    });
  }
  get x() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x1() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x1(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x2() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x2(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y1() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y1(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y2() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y2(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get curve() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set curve(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeOpacity() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeOpacity(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillOpacity() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillOpacity(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineCap() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineCap(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineJoin() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineJoin(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get miterLimit() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set miterLimit(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashArray() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashArray(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dashOffset() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dashOffset(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get outputSettings() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set outputSettings(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keys() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asOnePath() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asOnePath(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blockReindexing() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blockReindexing(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onClick() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onClick(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedown() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedown(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseup() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseup(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseover() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseover(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMouseout() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMouseout(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMousedrag() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMousedrag(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdown() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdown(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchup() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchup(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchover() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchover(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchout() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchout(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onTouchdrag() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onTouchdrag(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSelect() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSelect(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDeselect() {
    throw new Error("<AreaLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDeselect(value) {
    throw new Error("<AreaLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AreaLayer_default = AreaLayer;

// node_modules/@snlab/florence/src/components/guides/axes/just.js
function parseHJust(hjust, xOffset, bbox) {
  const { minX: x1, maxX: x23 } = bbox;
  if (hjust === "left") {
    return x1 - xOffset;
  }
  if (hjust === "right") {
    return x23 + xOffset;
  }
  if (["center", "centre"].includes(hjust)) {
    return (x23 - x1) / 2 + x1 + xOffset;
  }
  if (hjust.constructor === Number) {
    return (x23 - x1) * hjust + x1;
  }
}
function parseVJust(vjust, yOffset, bbox) {
  const { minY: y1, maxY: y23 } = bbox;
  if (vjust === "top") {
    return y1 - yOffset;
  }
  if (vjust === "bottom") {
    return y23 + yOffset;
  }
  if (["center", "centre"].includes(vjust)) {
    return (y23 - y1) / 2 + y1 + yOffset;
  }
  if (vjust.constructor === Number) {
    return (y23 - y1) * vjust + y1;
  }
}

// node_modules/@snlab/florence/src/components/guides/axes/baseLine.js
function getBaseLineCoordinatesXAxis(yAbs, { paddedBbox }) {
  const { minX, maxX } = paddedBbox;
  return {
    x: ({ pxAt }) => [minX, maxX].map(pxAt),
    y: ({ pyAt }) => [yAbs, yAbs].map(pyAt)
  };
}
function getBaseLineCoordinatesYAxis(xAbs, { paddedBbox }) {
  const { minY, maxY } = paddedBbox;
  return {
    x: ({ pxAt }) => [xAbs, xAbs].map(pxAt),
    y: ({ pyAt }) => [minY, maxY].map(pyAt)
  };
}

// node_modules/@snlab/florence/src/components/guides/axes/ticks.js
function getTickPositions(tickValuesArray, directScale, tickCount, tickExtra, zoomIdentity) {
  let ticks;
  if (Array.isArray(tickValuesArray) && tickValuesArray.length > 0) {
    ticks = tickValuesArray;
  } else if (isContinuous(directScale)) {
    ticks = getContinuousTicks(directScale, tickCount, zoomIdentity);
  } else if ("domain" in directScale) {
    ticks = directScale.domain();
  } else {
    throw new Error(`Couldn't construct axis. Please provide 'tickValues' or a scale with
      either a 'ticks' or a 'domain' method.`);
  }
  if (tickExtra && "domain" in directScale && ticks[0] !== directScale.domain()[0]) {
    ticks.unshift(directScale.domain()[0]);
  }
  return ticks;
}
function isContinuous(scale2) {
  return "ticks" in scale2;
}
function getContinuousTicks(scale2, tickCount, zoomIdentity) {
  if (zoomIdentity) {
    const rescaledDomain = rescale(scale2, zoomIdentity);
    return scale2.copy().domain(rescaledDomain).ticks(tickCount);
  }
  return scale2.ticks(tickCount);
}
function rescale(scale2, { k: k3, t: t2 }) {
  const rescaledRange = scale2.range().map((r2) => (r2 - t2) / k3);
  const rescaledDomain = rescaledRange.map(scale2.invert);
  return rescaledDomain;
}
function getTickCoordinatesXAxis(ticks, yAbs, tickSize, flip) {
  const yOffset = flip ? -tickSize : tickSize;
  return {
    x: ({ scaleX, bwx }) => {
      const bandOffset = bwx ? bwx() / 2 : 0;
      return ticks.map((t2) => scaleX(t2) + bandOffset).map((t2) => [t2, t2]);
    },
    y: ({ py, pyAt }) => {
      const y3 = pyAt(yAbs);
      return ticks.map((_2) => [y3, y3 + py(yOffset)]);
    }
  };
}
function getTickCoordinatesYAxis(ticks, xAbs, tickSize, flip) {
  const xOffset = flip ? tickSize : -tickSize;
  return {
    x: ({ px, pxAt }) => {
      const x3 = pxAt(xAbs);
      return ticks.map((_2) => [x3, x3 + px(xOffset)]);
    },
    y: ({ scaleY, bwy }) => {
      const bandOffset = bwy ? bwy() / 2 : 0;
      return ticks.map((t2) => scaleY(t2) + bandOffset).map((t2) => [t2, t2]);
    }
  };
}
function getFormat(labelFormat, scale2, numberOfTicks) {
  if (labelFormat)
    return labelFormat;
  if ("tickFormat" in scale2)
    return scale2.tickFormat(numberOfTicks);
  return (x3) => x3;
}

// node_modules/@snlab/florence/src/components/guides/axes/tickLabels.js
function getTickLabelCoordinatesXAxis(tickCoordinates, labelOffset, flip) {
  const dl = flip ? -labelOffset : labelOffset;
  return {
    x: (s3) => tickCoordinates.x(s3).map((x3) => x3[0]),
    y: (s3) => tickCoordinates.y(s3).map((y3) => y3[1] + s3.py(dl))
  };
}
function getTickLabelCoordinatesYAxis(tickCoordinates, labelOffset, flip) {
  const dl = flip ? labelOffset : -labelOffset;
  return {
    x: (s3) => tickCoordinates.x(s3).map((x3) => x3[1] + s3.px(dl)),
    y: (s3) => tickCoordinates.y(s3).map((y3) => y3[0])
  };
}
function getTextWidth(text3, fontSize, fontFamily) {
  let canvas2;
  if (typeof document === "undefined") {
    const length = text3.length;
    return length * 0.8 * fontSize;
  } else {
    canvas2 = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    const context = canvas2.getContext("2d");
    context.font = fontSize + " " + fontFamily;
    const metrics = context.measureText(text3);
    return metrics.width;
  }
}

// node_modules/@snlab/florence/src/components/guides/axes/title.js
function getTitleCoordinatesXAxis(hjust, xOffset, vjust, yOffset, section, flip, axisHeight, fontSize, yAbsoluteAxis) {
  const heightOffset = getHeightOffset(yOffset, flip, axisHeight, fontSize);
  const xAbs = parseHJust(hjust, xOffset, section.paddedBbox);
  const yAbs = vjust === "axis" ? yAbsoluteAxis + heightOffset : parseVJust(vjust, yOffset, section.paddedBbox) + heightOffset;
  return {
    x: ({ pxAt }) => pxAt(xAbs),
    y: ({ pyAt }) => pyAt(yAbs)
  };
}
function getHeightOffset(offset, flip, axisHeight, fontSize) {
  if (offset === "axis") {
    return flip ? -(axisHeight + 1) - fontSize : axisHeight + 1;
  }
  if (offset.constructor !== Number) {
    throw new Error("yOffset must be a Number or 'axis'");
  }
  return offset;
}
function getTitleCoordinatesYAxis(hjust, xOffset, vjust, yOffset, section, flip, axisWidth, fontSize, xAbsoluteAxis) {
  const widthOffset = getWidthOffset(xOffset, flip, axisWidth, fontSize);
  const xAbs = hjust === "axis" ? xAbsoluteAxis + widthOffset : parseHJust(hjust, xOffset, section.paddedBbox);
  const yAbs = parseVJust(vjust, yOffset, section.paddedBbox);
  return {
    x: ({ pxAt }) => pxAt(xAbs),
    y: ({ pyAt }) => pyAt(yAbs)
  };
}
function getWidthOffset(offset, flip, axisWidth, fontSize) {
  if (offset === "axis") {
    return flip ? axisWidth + 5 : -axisWidth - 5;
  }
  if (offset.constructor !== Number) {
    throw new Error("xOffset must be a Number or 'axis'");
  }
  return offset;
}

// node_modules/@snlab/florence/src/components/guides/axes/XAxis.svelte
var { Error: Error_1 } = globals;
function create_if_block_24(ctx2) {
  let line;
  let current;
  const line_spread_levels = [
    /*baseLineCoordinates*/
    ctx2[28],
    { strokeWidth: (
      /*baseLineWidth*/
      ctx2[3]
    ) },
    { opacity: (
      /*baseLineOpacity*/
      ctx2[2]
    ) },
    { stroke: (
      /*baseLineColor*/
      ctx2[1]
    ) },
    { clip: (
      /*clip*/
      ctx2[22]
    ) }
  ];
  let line_props = {};
  for (let i2 = 0; i2 < line_spread_levels.length; i2 += 1) {
    line_props = assign(line_props, line_spread_levels[i2]);
  }
  line = new Line_default({ props: line_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(line.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(line, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const line_changes = dirty[0] & /*baseLineCoordinates, baseLineWidth, baseLineOpacity, baseLineColor, clip*/
      272629774 ? get_spread_update(line_spread_levels, [
        dirty[0] & /*baseLineCoordinates*/
        268435456 && get_spread_object(
          /*baseLineCoordinates*/
          ctx3[28]
        ),
        dirty[0] & /*baseLineWidth*/
        8 && { strokeWidth: (
          /*baseLineWidth*/
          ctx3[3]
        ) },
        dirty[0] & /*baseLineOpacity*/
        4 && { opacity: (
          /*baseLineOpacity*/
          ctx3[2]
        ) },
        dirty[0] & /*baseLineColor*/
        2 && { stroke: (
          /*baseLineColor*/
          ctx3[1]
        ) },
        dirty[0] & /*clip*/
        4194304 && { clip: (
          /*clip*/
          ctx3[22]
        ) }
      ]) : {};
      line.$set(line_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(line.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(line.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(line, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(115:0) {#if baseLine}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_15(ctx2) {
  let linelayer;
  let t2;
  let labellayer;
  let current;
  const linelayer_spread_levels = [
    /*tickCoordinates*/
    ctx2[23],
    { strokeWidth: (
      /*tickWidth*/
      ctx2[5]
    ) },
    { opacity: (
      /*tickOpacity*/
      ctx2[7]
    ) },
    { stroke: (
      /*tickColor*/
      ctx2[6]
    ) },
    { clip: (
      /*clip*/
      ctx2[22]
    ) }
  ];
  let linelayer_props = {};
  for (let i2 = 0; i2 < linelayer_spread_levels.length; i2 += 1) {
    linelayer_props = assign(linelayer_props, linelayer_spread_levels[i2]);
  }
  linelayer = new LineLayer_default({ props: linelayer_props, $$inline: true });
  const labellayer_spread_levels = [
    /*tickLabelCoordinates*/
    ctx2[26],
    { text: (
      /*tickLabelText*/
      ctx2[27]
    ) },
    {
      anchorPoint: (
        /*labelAnchorPoint*/
        ctx2[25]
      )
    },
    { rotate: (
      /*labelRotate*/
      ctx2[8]
    ) },
    { fontFamily: (
      /*labelFont*/
      ctx2[9]
    ) },
    { fontSize: (
      /*labelFontSize*/
      ctx2[10]
    ) },
    { fontWeight: (
      /*labelFontWeight*/
      ctx2[11]
    ) },
    { opacity: (
      /*labelOpacity*/
      ctx2[12]
    ) },
    { fill: (
      /*labelColor*/
      ctx2[13]
    ) },
    { clip: (
      /*clip*/
      ctx2[22]
    ) }
  ];
  let labellayer_props = {};
  for (let i2 = 0; i2 < labellayer_spread_levels.length; i2 += 1) {
    labellayer_props = assign(labellayer_props, labellayer_spread_levels[i2]);
  }
  labellayer = new LabelLayer_default({ props: labellayer_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(linelayer.$$.fragment);
      t2 = space();
      create_component(labellayer.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(linelayer, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(labellayer, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const linelayer_changes = dirty[0] & /*tickCoordinates, tickWidth, tickOpacity, tickColor, clip*/
      12583136 ? get_spread_update(linelayer_spread_levels, [
        dirty[0] & /*tickCoordinates*/
        8388608 && get_spread_object(
          /*tickCoordinates*/
          ctx3[23]
        ),
        dirty[0] & /*tickWidth*/
        32 && { strokeWidth: (
          /*tickWidth*/
          ctx3[5]
        ) },
        dirty[0] & /*tickOpacity*/
        128 && { opacity: (
          /*tickOpacity*/
          ctx3[7]
        ) },
        dirty[0] & /*tickColor*/
        64 && { stroke: (
          /*tickColor*/
          ctx3[6]
        ) },
        dirty[0] & /*clip*/
        4194304 && { clip: (
          /*clip*/
          ctx3[22]
        ) }
      ]) : {};
      linelayer.$set(linelayer_changes);
      const labellayer_changes = dirty[0] & /*tickLabelCoordinates, tickLabelText, labelAnchorPoint, labelRotate, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip*/
      239091456 ? get_spread_update(labellayer_spread_levels, [
        dirty[0] & /*tickLabelCoordinates*/
        67108864 && get_spread_object(
          /*tickLabelCoordinates*/
          ctx3[26]
        ),
        dirty[0] & /*tickLabelText*/
        134217728 && { text: (
          /*tickLabelText*/
          ctx3[27]
        ) },
        dirty[0] & /*labelAnchorPoint*/
        33554432 && {
          anchorPoint: (
            /*labelAnchorPoint*/
            ctx3[25]
          )
        },
        dirty[0] & /*labelRotate*/
        256 && { rotate: (
          /*labelRotate*/
          ctx3[8]
        ) },
        dirty[0] & /*labelFont*/
        512 && { fontFamily: (
          /*labelFont*/
          ctx3[9]
        ) },
        dirty[0] & /*labelFontSize*/
        1024 && { fontSize: (
          /*labelFontSize*/
          ctx3[10]
        ) },
        dirty[0] & /*labelFontWeight*/
        2048 && { fontWeight: (
          /*labelFontWeight*/
          ctx3[11]
        ) },
        dirty[0] & /*labelOpacity*/
        4096 && { opacity: (
          /*labelOpacity*/
          ctx3[12]
        ) },
        dirty[0] & /*labelColor*/
        8192 && { fill: (
          /*labelColor*/
          ctx3[13]
        ) },
        dirty[0] & /*clip*/
        4194304 && { clip: (
          /*clip*/
          ctx3[22]
        ) }
      ]) : {};
      labellayer.$set(labellayer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(linelayer.$$.fragment, local);
      transition_in(labellayer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linelayer.$$.fragment, local);
      transition_out(labellayer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
      destroy_component(linelayer, detaching);
      destroy_component(labellayer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(125:0) {#if ticks}",
    ctx: ctx2
  });
  return block;
}
function create_if_block5(ctx2) {
  let label;
  let current;
  const label_spread_levels = [
    /*titleCoordinates*/
    ctx2[24],
    { text: (
      /*title*/
      ctx2[14]
    ) },
    {
      anchorPoint: (
        /*titleAnchorPoint*/
        ctx2[21]
      )
    },
    { rotate: (
      /*titleRotate*/
      ctx2[20]
    ) },
    { fontFamily: (
      /*titleFont*/
      ctx2[16]
    ) },
    { fontSize: (
      /*titleFontSize*/
      ctx2[17]
    ) },
    { fontWeight: (
      /*titleFontWeight*/
      ctx2[18]
    ) },
    { opacity: (
      /*titleOpacity*/
      ctx2[19]
    ) },
    { fill: (
      /*titleColor*/
      ctx2[15]
    ) },
    { clip: (
      /*clip*/
      ctx2[22]
    ) }
  ];
  let label_props = {};
  for (let i2 = 0; i2 < label_spread_levels.length; i2 += 1) {
    label_props = assign(label_props, label_spread_levels[i2]);
  }
  label = new Label_default({ props: label_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(label.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(label, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const label_changes = dirty[0] & /*titleCoordinates, title, titleAnchorPoint, titleRotate, titleFont, titleFontSize, titleFontWeight, titleOpacity, titleColor, clip*/
      25149440 ? get_spread_update(label_spread_levels, [
        dirty[0] & /*titleCoordinates*/
        16777216 && get_spread_object(
          /*titleCoordinates*/
          ctx3[24]
        ),
        dirty[0] & /*title*/
        16384 && { text: (
          /*title*/
          ctx3[14]
        ) },
        dirty[0] & /*titleAnchorPoint*/
        2097152 && {
          anchorPoint: (
            /*titleAnchorPoint*/
            ctx3[21]
          )
        },
        dirty[0] & /*titleRotate*/
        1048576 && { rotate: (
          /*titleRotate*/
          ctx3[20]
        ) },
        dirty[0] & /*titleFont*/
        65536 && { fontFamily: (
          /*titleFont*/
          ctx3[16]
        ) },
        dirty[0] & /*titleFontSize*/
        131072 && { fontSize: (
          /*titleFontSize*/
          ctx3[17]
        ) },
        dirty[0] & /*titleFontWeight*/
        262144 && { fontWeight: (
          /*titleFontWeight*/
          ctx3[18]
        ) },
        dirty[0] & /*titleOpacity*/
        524288 && { opacity: (
          /*titleOpacity*/
          ctx3[19]
        ) },
        dirty[0] & /*titleColor*/
        32768 && { fill: (
          /*titleColor*/
          ctx3[15]
        ) },
        dirty[0] & /*clip*/
        4194304 && { clip: (
          /*clip*/
          ctx3[22]
        ) }
      ]) : {};
      label.$set(label_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(label, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(148:0) {#if title.length > 0}",
    ctx: ctx2
  });
  return block;
}
function create_fragment24(ctx2) {
  let t02;
  let t12;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*baseLine*/
    ctx2[0] && create_if_block_24(ctx2)
  );
  let if_block1 = (
    /*ticks*/
    ctx2[4] && create_if_block_15(ctx2)
  );
  let if_block2 = (
    /*title*/
    ctx2[14].length > 0 && create_if_block5(ctx2)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t02 = space();
      if (if_block1)
        if_block1.c();
      t12 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t02, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t12, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (
        /*baseLine*/
        ctx3[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx3, dirty);
          if (dirty[0] & /*baseLine*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_24(ctx3);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t02.parentNode, t02);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*ticks*/
        ctx3[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx3, dirty);
          if (dirty[0] & /*ticks*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_15(ctx3);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t12.parentNode, t12);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*title*/
        ctx3[14].length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx3, dirty);
          if (dirty[0] & /*title*/
          16384) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block5(ctx3);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(if_block2_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let yAbs;
  let baseLineCoordinates;
  let tickPositions;
  let tickCoordinates;
  let format2;
  let tickLabelText;
  let tickLabelCoordinates;
  let labelAnchorPoint;
  let axisHeight;
  let titleCoordinates;
  let $section;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XAxis", slots, []);
  let { flip = false } = $$props;
  let { baseLine = true } = $$props;
  let { baseLineColor = "black" } = $$props;
  let { baseLineOpacity = 1 } = $$props;
  let { baseLineWidth = 1 } = $$props;
  let { vjust = "bottom" } = $$props;
  let { yOffset = 0 } = $$props;
  let { ticks = true } = $$props;
  let { tickCount = 10 } = $$props;
  let { tickExtra = false } = $$props;
  let { tickValues = void 0 } = $$props;
  let { tickSize = 5 } = $$props;
  let { tickWidth = 0.5 } = $$props;
  let { tickColor = "black" } = $$props;
  let { tickOpacity = 1 } = $$props;
  let { labelFormat = void 0 } = $$props;
  let { labelOffset = 6 } = $$props;
  let { labelRotate = 0 } = $$props;
  let { labelFont = "Helvetica" } = $$props;
  let { labelFontSize = 10 } = $$props;
  let { labelFontWeight = "normal" } = $$props;
  let { labelOpacity = 1 } = $$props;
  let { labelColor = "black" } = $$props;
  let { titleHjust = "center" } = $$props;
  let { titleXOffset = 0 } = $$props;
  let { titleVjust = "axis" } = $$props;
  let { titleYOffset = "axis" } = $$props;
  let { title = "" } = $$props;
  let { titleColor = "black" } = $$props;
  let { titleFont = "Helvetica" } = $$props;
  let { titleFontSize = 12 } = $$props;
  let { titleFontWeight = "normal" } = $$props;
  let { titleOpacity = 1 } = $$props;
  let { titleRotate = 0 } = $$props;
  let { titleAnchorPoint = "t" } = $$props;
  let { clip = "outer" } = $$props;
  const section = getContext("section");
  validate_store(section, "section");
  component_subscribe($$self, section, (value) => $$invalidate(47, $section = value));
  const writable_props = [
    "flip",
    "baseLine",
    "baseLineColor",
    "baseLineOpacity",
    "baseLineWidth",
    "vjust",
    "yOffset",
    "ticks",
    "tickCount",
    "tickExtra",
    "tickValues",
    "tickSize",
    "tickWidth",
    "tickColor",
    "tickOpacity",
    "labelFormat",
    "labelOffset",
    "labelRotate",
    "labelFont",
    "labelFontSize",
    "labelFontWeight",
    "labelOpacity",
    "labelColor",
    "titleHjust",
    "titleXOffset",
    "titleVjust",
    "titleYOffset",
    "title",
    "titleColor",
    "titleFont",
    "titleFontSize",
    "titleFontWeight",
    "titleOpacity",
    "titleRotate",
    "titleAnchorPoint",
    "clip"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XAxis> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("flip" in $$props2)
      $$invalidate(30, flip = $$props2.flip);
    if ("baseLine" in $$props2)
      $$invalidate(0, baseLine = $$props2.baseLine);
    if ("baseLineColor" in $$props2)
      $$invalidate(1, baseLineColor = $$props2.baseLineColor);
    if ("baseLineOpacity" in $$props2)
      $$invalidate(2, baseLineOpacity = $$props2.baseLineOpacity);
    if ("baseLineWidth" in $$props2)
      $$invalidate(3, baseLineWidth = $$props2.baseLineWidth);
    if ("vjust" in $$props2)
      $$invalidate(31, vjust = $$props2.vjust);
    if ("yOffset" in $$props2)
      $$invalidate(32, yOffset = $$props2.yOffset);
    if ("ticks" in $$props2)
      $$invalidate(4, ticks = $$props2.ticks);
    if ("tickCount" in $$props2)
      $$invalidate(33, tickCount = $$props2.tickCount);
    if ("tickExtra" in $$props2)
      $$invalidate(34, tickExtra = $$props2.tickExtra);
    if ("tickValues" in $$props2)
      $$invalidate(35, tickValues = $$props2.tickValues);
    if ("tickSize" in $$props2)
      $$invalidate(36, tickSize = $$props2.tickSize);
    if ("tickWidth" in $$props2)
      $$invalidate(5, tickWidth = $$props2.tickWidth);
    if ("tickColor" in $$props2)
      $$invalidate(6, tickColor = $$props2.tickColor);
    if ("tickOpacity" in $$props2)
      $$invalidate(7, tickOpacity = $$props2.tickOpacity);
    if ("labelFormat" in $$props2)
      $$invalidate(37, labelFormat = $$props2.labelFormat);
    if ("labelOffset" in $$props2)
      $$invalidate(38, labelOffset = $$props2.labelOffset);
    if ("labelRotate" in $$props2)
      $$invalidate(8, labelRotate = $$props2.labelRotate);
    if ("labelFont" in $$props2)
      $$invalidate(9, labelFont = $$props2.labelFont);
    if ("labelFontSize" in $$props2)
      $$invalidate(10, labelFontSize = $$props2.labelFontSize);
    if ("labelFontWeight" in $$props2)
      $$invalidate(11, labelFontWeight = $$props2.labelFontWeight);
    if ("labelOpacity" in $$props2)
      $$invalidate(12, labelOpacity = $$props2.labelOpacity);
    if ("labelColor" in $$props2)
      $$invalidate(13, labelColor = $$props2.labelColor);
    if ("titleHjust" in $$props2)
      $$invalidate(39, titleHjust = $$props2.titleHjust);
    if ("titleXOffset" in $$props2)
      $$invalidate(40, titleXOffset = $$props2.titleXOffset);
    if ("titleVjust" in $$props2)
      $$invalidate(41, titleVjust = $$props2.titleVjust);
    if ("titleYOffset" in $$props2)
      $$invalidate(42, titleYOffset = $$props2.titleYOffset);
    if ("title" in $$props2)
      $$invalidate(14, title = $$props2.title);
    if ("titleColor" in $$props2)
      $$invalidate(15, titleColor = $$props2.titleColor);
    if ("titleFont" in $$props2)
      $$invalidate(16, titleFont = $$props2.titleFont);
    if ("titleFontSize" in $$props2)
      $$invalidate(17, titleFontSize = $$props2.titleFontSize);
    if ("titleFontWeight" in $$props2)
      $$invalidate(18, titleFontWeight = $$props2.titleFontWeight);
    if ("titleOpacity" in $$props2)
      $$invalidate(19, titleOpacity = $$props2.titleOpacity);
    if ("titleRotate" in $$props2)
      $$invalidate(20, titleRotate = $$props2.titleRotate);
    if ("titleAnchorPoint" in $$props2)
      $$invalidate(21, titleAnchorPoint = $$props2.titleAnchorPoint);
    if ("clip" in $$props2)
      $$invalidate(22, clip = $$props2.clip);
  };
  $$self.$capture_state = () => ({
    getContext,
    Line: Line_default,
    LineLayer: LineLayer_default,
    Label: Label_default,
    LabelLayer: LabelLayer_default,
    parseVJust,
    getBaseLineCoordinatesXAxis,
    getTickPositions,
    getTickCoordinatesXAxis,
    getFormat,
    getTickLabelCoordinatesXAxis,
    getTitleCoordinatesXAxis,
    flip,
    baseLine,
    baseLineColor,
    baseLineOpacity,
    baseLineWidth,
    vjust,
    yOffset,
    ticks,
    tickCount,
    tickExtra,
    tickValues,
    tickSize,
    tickWidth,
    tickColor,
    tickOpacity,
    labelFormat,
    labelOffset,
    labelRotate,
    labelFont,
    labelFontSize,
    labelFontWeight,
    labelOpacity,
    labelColor,
    titleHjust,
    titleXOffset,
    titleVjust,
    titleYOffset,
    title,
    titleColor,
    titleFont,
    titleFontSize,
    titleFontWeight,
    titleOpacity,
    titleRotate,
    titleAnchorPoint,
    clip,
    section,
    yAbs,
    axisHeight,
    titleCoordinates,
    labelAnchorPoint,
    tickCoordinates,
    tickLabelCoordinates,
    format: format2,
    tickPositions,
    tickLabelText,
    baseLineCoordinates,
    $section
  });
  $$self.$inject_state = ($$props2) => {
    if ("flip" in $$props2)
      $$invalidate(30, flip = $$props2.flip);
    if ("baseLine" in $$props2)
      $$invalidate(0, baseLine = $$props2.baseLine);
    if ("baseLineColor" in $$props2)
      $$invalidate(1, baseLineColor = $$props2.baseLineColor);
    if ("baseLineOpacity" in $$props2)
      $$invalidate(2, baseLineOpacity = $$props2.baseLineOpacity);
    if ("baseLineWidth" in $$props2)
      $$invalidate(3, baseLineWidth = $$props2.baseLineWidth);
    if ("vjust" in $$props2)
      $$invalidate(31, vjust = $$props2.vjust);
    if ("yOffset" in $$props2)
      $$invalidate(32, yOffset = $$props2.yOffset);
    if ("ticks" in $$props2)
      $$invalidate(4, ticks = $$props2.ticks);
    if ("tickCount" in $$props2)
      $$invalidate(33, tickCount = $$props2.tickCount);
    if ("tickExtra" in $$props2)
      $$invalidate(34, tickExtra = $$props2.tickExtra);
    if ("tickValues" in $$props2)
      $$invalidate(35, tickValues = $$props2.tickValues);
    if ("tickSize" in $$props2)
      $$invalidate(36, tickSize = $$props2.tickSize);
    if ("tickWidth" in $$props2)
      $$invalidate(5, tickWidth = $$props2.tickWidth);
    if ("tickColor" in $$props2)
      $$invalidate(6, tickColor = $$props2.tickColor);
    if ("tickOpacity" in $$props2)
      $$invalidate(7, tickOpacity = $$props2.tickOpacity);
    if ("labelFormat" in $$props2)
      $$invalidate(37, labelFormat = $$props2.labelFormat);
    if ("labelOffset" in $$props2)
      $$invalidate(38, labelOffset = $$props2.labelOffset);
    if ("labelRotate" in $$props2)
      $$invalidate(8, labelRotate = $$props2.labelRotate);
    if ("labelFont" in $$props2)
      $$invalidate(9, labelFont = $$props2.labelFont);
    if ("labelFontSize" in $$props2)
      $$invalidate(10, labelFontSize = $$props2.labelFontSize);
    if ("labelFontWeight" in $$props2)
      $$invalidate(11, labelFontWeight = $$props2.labelFontWeight);
    if ("labelOpacity" in $$props2)
      $$invalidate(12, labelOpacity = $$props2.labelOpacity);
    if ("labelColor" in $$props2)
      $$invalidate(13, labelColor = $$props2.labelColor);
    if ("titleHjust" in $$props2)
      $$invalidate(39, titleHjust = $$props2.titleHjust);
    if ("titleXOffset" in $$props2)
      $$invalidate(40, titleXOffset = $$props2.titleXOffset);
    if ("titleVjust" in $$props2)
      $$invalidate(41, titleVjust = $$props2.titleVjust);
    if ("titleYOffset" in $$props2)
      $$invalidate(42, titleYOffset = $$props2.titleYOffset);
    if ("title" in $$props2)
      $$invalidate(14, title = $$props2.title);
    if ("titleColor" in $$props2)
      $$invalidate(15, titleColor = $$props2.titleColor);
    if ("titleFont" in $$props2)
      $$invalidate(16, titleFont = $$props2.titleFont);
    if ("titleFontSize" in $$props2)
      $$invalidate(17, titleFontSize = $$props2.titleFontSize);
    if ("titleFontWeight" in $$props2)
      $$invalidate(18, titleFontWeight = $$props2.titleFontWeight);
    if ("titleOpacity" in $$props2)
      $$invalidate(19, titleOpacity = $$props2.titleOpacity);
    if ("titleRotate" in $$props2)
      $$invalidate(20, titleRotate = $$props2.titleRotate);
    if ("titleAnchorPoint" in $$props2)
      $$invalidate(21, titleAnchorPoint = $$props2.titleAnchorPoint);
    if ("clip" in $$props2)
      $$invalidate(22, clip = $$props2.clip);
    if ("yAbs" in $$props2)
      $$invalidate(43, yAbs = $$props2.yAbs);
    if ("axisHeight" in $$props2)
      $$invalidate(44, axisHeight = $$props2.axisHeight);
    if ("titleCoordinates" in $$props2)
      $$invalidate(24, titleCoordinates = $$props2.titleCoordinates);
    if ("labelAnchorPoint" in $$props2)
      $$invalidate(25, labelAnchorPoint = $$props2.labelAnchorPoint);
    if ("tickCoordinates" in $$props2)
      $$invalidate(23, tickCoordinates = $$props2.tickCoordinates);
    if ("tickLabelCoordinates" in $$props2)
      $$invalidate(26, tickLabelCoordinates = $$props2.tickLabelCoordinates);
    if ("format" in $$props2)
      $$invalidate(45, format2 = $$props2.format);
    if ("tickPositions" in $$props2)
      $$invalidate(46, tickPositions = $$props2.tickPositions);
    if ("tickLabelText" in $$props2)
      $$invalidate(27, tickLabelText = $$props2.tickLabelText);
    if ("baseLineCoordinates" in $$props2)
      $$invalidate(28, baseLineCoordinates = $$props2.baseLineCoordinates);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*$section*/
    65536) {
      $: {
        if ($section.coordinateSystem) {
          throw new Error("Cannot use axes with alternative coordinate systems (for now)");
        }
      }
    }
    if ($$self.$$.dirty[1] & /*vjust, yOffset, $section*/
    65539) {
      $:
        $$invalidate(43, yAbs = parseVJust(vjust, yOffset, $section.paddedBbox));
    }
    if ($$self.$$.dirty[1] & /*yAbs, $section*/
    69632) {
      $:
        $$invalidate(28, baseLineCoordinates = getBaseLineCoordinatesXAxis(yAbs, $section));
    }
    if ($$self.$$.dirty[1] & /*tickValues, $section, tickCount, tickExtra*/
    65564) {
      $:
        $$invalidate(46, tickPositions = getTickPositions(tickValues, $section.directScales.x, tickCount, tickExtra, $section.zoomIdentity ? {
          t: $section.zoomIdentity.x,
          k: $section.zoomIdentity.kx
        } : void 0));
    }
    if ($$self.$$.dirty[0] & /*flip*/
    1073741824 | $$self.$$.dirty[1] & /*tickPositions, yAbs, tickSize*/
    36896) {
      $:
        $$invalidate(23, tickCoordinates = getTickCoordinatesXAxis(tickPositions, yAbs, tickSize, flip));
    }
    if ($$self.$$.dirty[0] & /*ticks*/
    16 | $$self.$$.dirty[1] & /*labelFormat, $section*/
    65600) {
      $:
        $$invalidate(45, format2 = getFormat(labelFormat, $section.scaleX, ticks.length));
    }
    if ($$self.$$.dirty[1] & /*tickPositions, format*/
    49152) {
      $:
        $$invalidate(27, tickLabelText = tickPositions.map(format2));
    }
    if ($$self.$$.dirty[0] & /*tickCoordinates, flip*/
    1082130432 | $$self.$$.dirty[1] & /*labelOffset*/
    128) {
      $:
        $$invalidate(26, tickLabelCoordinates = getTickLabelCoordinatesXAxis(tickCoordinates, labelOffset, flip));
    }
    if ($$self.$$.dirty[0] & /*flip*/
    1073741824) {
      $:
        $$invalidate(25, labelAnchorPoint = flip ? "b" : "t");
    }
    if ($$self.$$.dirty[0] & /*baseLineWidth, labelFontSize*/
    1032 | $$self.$$.dirty[1] & /*tickSize, labelOffset*/
    160) {
      $:
        $$invalidate(44, axisHeight = baseLineWidth + tickSize + labelOffset + labelFontSize);
    }
    if ($$self.$$.dirty[0] & /*flip, titleFontSize*/
    1073872896 | $$self.$$.dirty[1] & /*titleHjust, titleXOffset, titleVjust, titleYOffset, $section, axisHeight, yAbs*/
    81664) {
      $:
        $$invalidate(24, titleCoordinates = getTitleCoordinatesXAxis(titleHjust, titleXOffset, titleVjust, titleYOffset, $section, flip, axisHeight, titleFontSize, yAbs));
    }
  };
  return [
    baseLine,
    baseLineColor,
    baseLineOpacity,
    baseLineWidth,
    ticks,
    tickWidth,
    tickColor,
    tickOpacity,
    labelRotate,
    labelFont,
    labelFontSize,
    labelFontWeight,
    labelOpacity,
    labelColor,
    title,
    titleColor,
    titleFont,
    titleFontSize,
    titleFontWeight,
    titleOpacity,
    titleRotate,
    titleAnchorPoint,
    clip,
    tickCoordinates,
    titleCoordinates,
    labelAnchorPoint,
    tickLabelCoordinates,
    tickLabelText,
    baseLineCoordinates,
    section,
    flip,
    vjust,
    yOffset,
    tickCount,
    tickExtra,
    tickValues,
    tickSize,
    labelFormat,
    labelOffset,
    titleHjust,
    titleXOffset,
    titleVjust,
    titleYOffset,
    yAbs,
    axisHeight,
    format2,
    tickPositions,
    $section
  ];
}
var XAxis = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance24,
      create_fragment24,
      safe_not_equal,
      {
        flip: 30,
        baseLine: 0,
        baseLineColor: 1,
        baseLineOpacity: 2,
        baseLineWidth: 3,
        vjust: 31,
        yOffset: 32,
        ticks: 4,
        tickCount: 33,
        tickExtra: 34,
        tickValues: 35,
        tickSize: 36,
        tickWidth: 5,
        tickColor: 6,
        tickOpacity: 7,
        labelFormat: 37,
        labelOffset: 38,
        labelRotate: 8,
        labelFont: 9,
        labelFontSize: 10,
        labelFontWeight: 11,
        labelOpacity: 12,
        labelColor: 13,
        titleHjust: 39,
        titleXOffset: 40,
        titleVjust: 41,
        titleYOffset: 42,
        title: 14,
        titleColor: 15,
        titleFont: 16,
        titleFontSize: 17,
        titleFontWeight: 18,
        titleOpacity: 19,
        titleRotate: 20,
        titleAnchorPoint: 21,
        clip: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XAxis",
      options: options2,
      id: create_fragment24.name
    });
  }
  get flip() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get baseLine() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseLine(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get baseLineColor() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseLineColor(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get baseLineOpacity() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseLineOpacity(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get baseLineWidth() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseLineWidth(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vjust() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vjust(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yOffset() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yOffset(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticks() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticks(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickCount() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickCount(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickExtra() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickExtra(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickValues() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickValues(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickSize() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickSize(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickWidth() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickWidth(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickColor() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickColor(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickOpacity() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickOpacity(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFormat() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFormat(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOffset() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOffset(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelRotate() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelRotate(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFont() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFont(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontSize() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontSize(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontWeight() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontWeight(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOpacity() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOpacity(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelColor() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelColor(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleHjust() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleHjust(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleXOffset() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleXOffset(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleVjust() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleVjust(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleYOffset() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleYOffset(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleColor() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleColor(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFont() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFont(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontSize() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontSize(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontWeight() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontWeight(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleOpacity() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleOpacity(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleRotate() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleRotate(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleAnchorPoint() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleAnchorPoint(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error_1("<XAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error_1("<XAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var XAxis_default = XAxis;

// node_modules/@snlab/florence/src/components/guides/axes/YAxis.svelte
var { Error: Error_12 } = globals;
function create_if_block_25(ctx2) {
  let line;
  let current;
  const line_spread_levels = [
    /*baseLineCoordinates*/
    ctx2[28],
    { strokeWidth: (
      /*baseLineWidth*/
      ctx2[3]
    ) },
    { opacity: (
      /*baseLineOpacity*/
      ctx2[2]
    ) },
    { stroke: (
      /*baseLineColor*/
      ctx2[1]
    ) },
    { clip: (
      /*clip*/
      ctx2[22]
    ) }
  ];
  let line_props = {};
  for (let i2 = 0; i2 < line_spread_levels.length; i2 += 1) {
    line_props = assign(line_props, line_spread_levels[i2]);
  }
  line = new Line_default({ props: line_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(line.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(line, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const line_changes = dirty[0] & /*baseLineCoordinates, baseLineWidth, baseLineOpacity, baseLineColor, clip*/
      272629774 ? get_spread_update(line_spread_levels, [
        dirty[0] & /*baseLineCoordinates*/
        268435456 && get_spread_object(
          /*baseLineCoordinates*/
          ctx3[28]
        ),
        dirty[0] & /*baseLineWidth*/
        8 && { strokeWidth: (
          /*baseLineWidth*/
          ctx3[3]
        ) },
        dirty[0] & /*baseLineOpacity*/
        4 && { opacity: (
          /*baseLineOpacity*/
          ctx3[2]
        ) },
        dirty[0] & /*baseLineColor*/
        2 && { stroke: (
          /*baseLineColor*/
          ctx3[1]
        ) },
        dirty[0] & /*clip*/
        4194304 && { clip: (
          /*clip*/
          ctx3[22]
        ) }
      ]) : {};
      line.$set(line_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(line.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(line.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(line, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(117:0) {#if baseLine}",
    ctx: ctx2
  });
  return block;
}
function create_if_block_16(ctx2) {
  let linelayer;
  let t2;
  let labellayer;
  let current;
  const linelayer_spread_levels = [
    /*tickCoordinates*/
    ctx2[24],
    { strokeWidth: (
      /*tickWidth*/
      ctx2[5]
    ) },
    { opacity: (
      /*tickOpacity*/
      ctx2[7]
    ) },
    { stroke: (
      /*tickColor*/
      ctx2[6]
    ) },
    { clip: (
      /*clip*/
      ctx2[22]
    ) }
  ];
  let linelayer_props = {};
  for (let i2 = 0; i2 < linelayer_spread_levels.length; i2 += 1) {
    linelayer_props = assign(linelayer_props, linelayer_spread_levels[i2]);
  }
  linelayer = new LineLayer_default({ props: linelayer_props, $$inline: true });
  const labellayer_spread_levels = [
    /*tickLabelCoordinates*/
    ctx2[27],
    { text: (
      /*tickLabelText*/
      ctx2[23]
    ) },
    {
      anchorPoint: (
        /*labelAnchorPoint*/
        ctx2[26]
      )
    },
    { rotate: (
      /*labelRotate*/
      ctx2[8]
    ) },
    { fontFamily: (
      /*labelFont*/
      ctx2[9]
    ) },
    { fontSize: (
      /*labelFontSize*/
      ctx2[10]
    ) },
    { fontWeight: (
      /*labelFontWeight*/
      ctx2[11]
    ) },
    { opacity: (
      /*labelOpacity*/
      ctx2[12]
    ) },
    { fill: (
      /*labelColor*/
      ctx2[13]
    ) },
    { clip: (
      /*clip*/
      ctx2[22]
    ) }
  ];
  let labellayer_props = {};
  for (let i2 = 0; i2 < labellayer_spread_levels.length; i2 += 1) {
    labellayer_props = assign(labellayer_props, labellayer_spread_levels[i2]);
  }
  labellayer = new LabelLayer_default({ props: labellayer_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(linelayer.$$.fragment);
      t2 = space();
      create_component(labellayer.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(linelayer, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(labellayer, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const linelayer_changes = dirty[0] & /*tickCoordinates, tickWidth, tickOpacity, tickColor, clip*/
      20971744 ? get_spread_update(linelayer_spread_levels, [
        dirty[0] & /*tickCoordinates*/
        16777216 && get_spread_object(
          /*tickCoordinates*/
          ctx3[24]
        ),
        dirty[0] & /*tickWidth*/
        32 && { strokeWidth: (
          /*tickWidth*/
          ctx3[5]
        ) },
        dirty[0] & /*tickOpacity*/
        128 && { opacity: (
          /*tickOpacity*/
          ctx3[7]
        ) },
        dirty[0] & /*tickColor*/
        64 && { stroke: (
          /*tickColor*/
          ctx3[6]
        ) },
        dirty[0] & /*clip*/
        4194304 && { clip: (
          /*clip*/
          ctx3[22]
        ) }
      ]) : {};
      linelayer.$set(linelayer_changes);
      const labellayer_changes = dirty[0] & /*tickLabelCoordinates, tickLabelText, labelAnchorPoint, labelRotate, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip*/
      213925632 ? get_spread_update(labellayer_spread_levels, [
        dirty[0] & /*tickLabelCoordinates*/
        134217728 && get_spread_object(
          /*tickLabelCoordinates*/
          ctx3[27]
        ),
        dirty[0] & /*tickLabelText*/
        8388608 && { text: (
          /*tickLabelText*/
          ctx3[23]
        ) },
        dirty[0] & /*labelAnchorPoint*/
        67108864 && {
          anchorPoint: (
            /*labelAnchorPoint*/
            ctx3[26]
          )
        },
        dirty[0] & /*labelRotate*/
        256 && { rotate: (
          /*labelRotate*/
          ctx3[8]
        ) },
        dirty[0] & /*labelFont*/
        512 && { fontFamily: (
          /*labelFont*/
          ctx3[9]
        ) },
        dirty[0] & /*labelFontSize*/
        1024 && { fontSize: (
          /*labelFontSize*/
          ctx3[10]
        ) },
        dirty[0] & /*labelFontWeight*/
        2048 && { fontWeight: (
          /*labelFontWeight*/
          ctx3[11]
        ) },
        dirty[0] & /*labelOpacity*/
        4096 && { opacity: (
          /*labelOpacity*/
          ctx3[12]
        ) },
        dirty[0] & /*labelColor*/
        8192 && { fill: (
          /*labelColor*/
          ctx3[13]
        ) },
        dirty[0] & /*clip*/
        4194304 && { clip: (
          /*clip*/
          ctx3[22]
        ) }
      ]) : {};
      labellayer.$set(labellayer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(linelayer.$$.fragment, local);
      transition_in(labellayer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linelayer.$$.fragment, local);
      transition_out(labellayer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
      destroy_component(linelayer, detaching);
      destroy_component(labellayer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(127:0) {#if ticks}",
    ctx: ctx2
  });
  return block;
}
function create_if_block6(ctx2) {
  let label;
  let current;
  const label_spread_levels = [
    /*titleCoordinates*/
    ctx2[25],
    { text: (
      /*title*/
      ctx2[14]
    ) },
    {
      anchorPoint: (
        /*titleAnchorPoint*/
        ctx2[21]
      )
    },
    { rotate: (
      /*titleRotate*/
      ctx2[20]
    ) },
    { fontFamily: (
      /*titleFont*/
      ctx2[16]
    ) },
    { fontSize: (
      /*titleFontSize*/
      ctx2[17]
    ) },
    { fontWeight: (
      /*titleFontWeight*/
      ctx2[18]
    ) },
    { opacity: (
      /*titleOpacity*/
      ctx2[19]
    ) },
    { fill: (
      /*titleColor*/
      ctx2[15]
    ) },
    { clip: (
      /*clip*/
      ctx2[22]
    ) }
  ];
  let label_props = {};
  for (let i2 = 0; i2 < label_spread_levels.length; i2 += 1) {
    label_props = assign(label_props, label_spread_levels[i2]);
  }
  label = new Label_default({ props: label_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(label.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(label, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const label_changes = dirty[0] & /*titleCoordinates, title, titleAnchorPoint, titleRotate, titleFont, titleFontSize, titleFontWeight, titleOpacity, titleColor, clip*/
      41926656 ? get_spread_update(label_spread_levels, [
        dirty[0] & /*titleCoordinates*/
        33554432 && get_spread_object(
          /*titleCoordinates*/
          ctx3[25]
        ),
        dirty[0] & /*title*/
        16384 && { text: (
          /*title*/
          ctx3[14]
        ) },
        dirty[0] & /*titleAnchorPoint*/
        2097152 && {
          anchorPoint: (
            /*titleAnchorPoint*/
            ctx3[21]
          )
        },
        dirty[0] & /*titleRotate*/
        1048576 && { rotate: (
          /*titleRotate*/
          ctx3[20]
        ) },
        dirty[0] & /*titleFont*/
        65536 && { fontFamily: (
          /*titleFont*/
          ctx3[16]
        ) },
        dirty[0] & /*titleFontSize*/
        131072 && { fontSize: (
          /*titleFontSize*/
          ctx3[17]
        ) },
        dirty[0] & /*titleFontWeight*/
        262144 && { fontWeight: (
          /*titleFontWeight*/
          ctx3[18]
        ) },
        dirty[0] & /*titleOpacity*/
        524288 && { opacity: (
          /*titleOpacity*/
          ctx3[19]
        ) },
        dirty[0] & /*titleColor*/
        32768 && { fill: (
          /*titleColor*/
          ctx3[15]
        ) },
        dirty[0] & /*clip*/
        4194304 && { clip: (
          /*clip*/
          ctx3[22]
        ) }
      ]) : {};
      label.$set(label_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(label, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(150:0) {#if title.length > 0}",
    ctx: ctx2
  });
  return block;
}
function create_fragment25(ctx2) {
  let t02;
  let t12;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*baseLine*/
    ctx2[0] && create_if_block_25(ctx2)
  );
  let if_block1 = (
    /*ticks*/
    ctx2[4] && create_if_block_16(ctx2)
  );
  let if_block2 = (
    /*title*/
    ctx2[14].length > 0 && create_if_block6(ctx2)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t02 = space();
      if (if_block1)
        if_block1.c();
      t12 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error_12("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t02, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, t12, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (
        /*baseLine*/
        ctx3[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx3, dirty);
          if (dirty[0] & /*baseLine*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_25(ctx3);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t02.parentNode, t02);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*ticks*/
        ctx3[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx3, dirty);
          if (dirty[0] & /*ticks*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_16(ctx3);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t12.parentNode, t12);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*title*/
        ctx3[14].length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx3, dirty);
          if (dirty[0] & /*title*/
          16384) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block6(ctx3);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
        detach_dev(if_block2_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let xAbs;
  let baseLineCoordinates;
  let tickPositions;
  let tickCoordinates;
  let format2;
  let tickLabelText;
  let tickLabelCoordinates;
  let labelAnchorPoint;
  let tickLabelWidth;
  let axisWidth;
  let titleCoordinates;
  let $section;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("YAxis", slots, []);
  let { flip = false } = $$props;
  let { baseLine = true } = $$props;
  let { baseLineColor = "black" } = $$props;
  let { baseLineOpacity = 1 } = $$props;
  let { baseLineWidth = 1 } = $$props;
  let { hjust = "left" } = $$props;
  let { xOffset = 0 } = $$props;
  let { ticks = true } = $$props;
  let { tickCount = 10 } = $$props;
  let { tickExtra = false } = $$props;
  let { tickValues = void 0 } = $$props;
  let { tickSize = 5 } = $$props;
  let { tickWidth = 0.5 } = $$props;
  let { tickColor = "black" } = $$props;
  let { tickOpacity = 1 } = $$props;
  let { labelFormat = void 0 } = $$props;
  let { labelOffset = 4 } = $$props;
  let { labelRotate = 0 } = $$props;
  let { labelFont = "Helvetica" } = $$props;
  let { labelFontSize = 10 } = $$props;
  let { labelFontWeight = "normal" } = $$props;
  let { labelOpacity = 1 } = $$props;
  let { labelColor = "black" } = $$props;
  let { titleHjust = "axis" } = $$props;
  let { titleXOffset = "axis" } = $$props;
  let { titleVjust = "center" } = $$props;
  let { titleYOffset = 0 } = $$props;
  let { title = "" } = $$props;
  let { titleColor = "black" } = $$props;
  let { titleFont = "Helvetica" } = $$props;
  let { titleFontSize = 12 } = $$props;
  let { titleFontWeight = "normal" } = $$props;
  let { titleOpacity = 1 } = $$props;
  let { titleRotate = -Math.PI / 2 } = $$props;
  let { titleAnchorPoint = "center" } = $$props;
  let { clip = "outer" } = $$props;
  const section = getContext("section");
  validate_store(section, "section");
  component_subscribe($$self, section, (value) => $$invalidate(48, $section = value));
  const writable_props = [
    "flip",
    "baseLine",
    "baseLineColor",
    "baseLineOpacity",
    "baseLineWidth",
    "hjust",
    "xOffset",
    "ticks",
    "tickCount",
    "tickExtra",
    "tickValues",
    "tickSize",
    "tickWidth",
    "tickColor",
    "tickOpacity",
    "labelFormat",
    "labelOffset",
    "labelRotate",
    "labelFont",
    "labelFontSize",
    "labelFontWeight",
    "labelOpacity",
    "labelColor",
    "titleHjust",
    "titleXOffset",
    "titleVjust",
    "titleYOffset",
    "title",
    "titleColor",
    "titleFont",
    "titleFontSize",
    "titleFontWeight",
    "titleOpacity",
    "titleRotate",
    "titleAnchorPoint",
    "clip"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<YAxis> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("flip" in $$props2)
      $$invalidate(30, flip = $$props2.flip);
    if ("baseLine" in $$props2)
      $$invalidate(0, baseLine = $$props2.baseLine);
    if ("baseLineColor" in $$props2)
      $$invalidate(1, baseLineColor = $$props2.baseLineColor);
    if ("baseLineOpacity" in $$props2)
      $$invalidate(2, baseLineOpacity = $$props2.baseLineOpacity);
    if ("baseLineWidth" in $$props2)
      $$invalidate(3, baseLineWidth = $$props2.baseLineWidth);
    if ("hjust" in $$props2)
      $$invalidate(31, hjust = $$props2.hjust);
    if ("xOffset" in $$props2)
      $$invalidate(32, xOffset = $$props2.xOffset);
    if ("ticks" in $$props2)
      $$invalidate(4, ticks = $$props2.ticks);
    if ("tickCount" in $$props2)
      $$invalidate(33, tickCount = $$props2.tickCount);
    if ("tickExtra" in $$props2)
      $$invalidate(34, tickExtra = $$props2.tickExtra);
    if ("tickValues" in $$props2)
      $$invalidate(35, tickValues = $$props2.tickValues);
    if ("tickSize" in $$props2)
      $$invalidate(36, tickSize = $$props2.tickSize);
    if ("tickWidth" in $$props2)
      $$invalidate(5, tickWidth = $$props2.tickWidth);
    if ("tickColor" in $$props2)
      $$invalidate(6, tickColor = $$props2.tickColor);
    if ("tickOpacity" in $$props2)
      $$invalidate(7, tickOpacity = $$props2.tickOpacity);
    if ("labelFormat" in $$props2)
      $$invalidate(37, labelFormat = $$props2.labelFormat);
    if ("labelOffset" in $$props2)
      $$invalidate(38, labelOffset = $$props2.labelOffset);
    if ("labelRotate" in $$props2)
      $$invalidate(8, labelRotate = $$props2.labelRotate);
    if ("labelFont" in $$props2)
      $$invalidate(9, labelFont = $$props2.labelFont);
    if ("labelFontSize" in $$props2)
      $$invalidate(10, labelFontSize = $$props2.labelFontSize);
    if ("labelFontWeight" in $$props2)
      $$invalidate(11, labelFontWeight = $$props2.labelFontWeight);
    if ("labelOpacity" in $$props2)
      $$invalidate(12, labelOpacity = $$props2.labelOpacity);
    if ("labelColor" in $$props2)
      $$invalidate(13, labelColor = $$props2.labelColor);
    if ("titleHjust" in $$props2)
      $$invalidate(39, titleHjust = $$props2.titleHjust);
    if ("titleXOffset" in $$props2)
      $$invalidate(40, titleXOffset = $$props2.titleXOffset);
    if ("titleVjust" in $$props2)
      $$invalidate(41, titleVjust = $$props2.titleVjust);
    if ("titleYOffset" in $$props2)
      $$invalidate(42, titleYOffset = $$props2.titleYOffset);
    if ("title" in $$props2)
      $$invalidate(14, title = $$props2.title);
    if ("titleColor" in $$props2)
      $$invalidate(15, titleColor = $$props2.titleColor);
    if ("titleFont" in $$props2)
      $$invalidate(16, titleFont = $$props2.titleFont);
    if ("titleFontSize" in $$props2)
      $$invalidate(17, titleFontSize = $$props2.titleFontSize);
    if ("titleFontWeight" in $$props2)
      $$invalidate(18, titleFontWeight = $$props2.titleFontWeight);
    if ("titleOpacity" in $$props2)
      $$invalidate(19, titleOpacity = $$props2.titleOpacity);
    if ("titleRotate" in $$props2)
      $$invalidate(20, titleRotate = $$props2.titleRotate);
    if ("titleAnchorPoint" in $$props2)
      $$invalidate(21, titleAnchorPoint = $$props2.titleAnchorPoint);
    if ("clip" in $$props2)
      $$invalidate(22, clip = $$props2.clip);
  };
  $$self.$capture_state = () => ({
    getContext,
    Line: Line_default,
    LineLayer: LineLayer_default,
    Label: Label_default,
    LabelLayer: LabelLayer_default,
    parseHJust,
    getBaseLineCoordinatesYAxis,
    getTickPositions,
    getTickCoordinatesYAxis,
    getFormat,
    getTickLabelCoordinatesYAxis,
    getTextWidth,
    getTitleCoordinatesYAxis,
    flip,
    baseLine,
    baseLineColor,
    baseLineOpacity,
    baseLineWidth,
    hjust,
    xOffset,
    ticks,
    tickCount,
    tickExtra,
    tickValues,
    tickSize,
    tickWidth,
    tickColor,
    tickOpacity,
    labelFormat,
    labelOffset,
    labelRotate,
    labelFont,
    labelFontSize,
    labelFontWeight,
    labelOpacity,
    labelColor,
    titleHjust,
    titleXOffset,
    titleVjust,
    titleYOffset,
    title,
    titleColor,
    titleFont,
    titleFontSize,
    titleFontWeight,
    titleOpacity,
    titleRotate,
    titleAnchorPoint,
    clip,
    section,
    xAbs,
    axisWidth,
    titleCoordinates,
    tickLabelWidth,
    tickLabelText,
    labelAnchorPoint,
    tickCoordinates,
    tickLabelCoordinates,
    format: format2,
    tickPositions,
    baseLineCoordinates,
    $section
  });
  $$self.$inject_state = ($$props2) => {
    if ("flip" in $$props2)
      $$invalidate(30, flip = $$props2.flip);
    if ("baseLine" in $$props2)
      $$invalidate(0, baseLine = $$props2.baseLine);
    if ("baseLineColor" in $$props2)
      $$invalidate(1, baseLineColor = $$props2.baseLineColor);
    if ("baseLineOpacity" in $$props2)
      $$invalidate(2, baseLineOpacity = $$props2.baseLineOpacity);
    if ("baseLineWidth" in $$props2)
      $$invalidate(3, baseLineWidth = $$props2.baseLineWidth);
    if ("hjust" in $$props2)
      $$invalidate(31, hjust = $$props2.hjust);
    if ("xOffset" in $$props2)
      $$invalidate(32, xOffset = $$props2.xOffset);
    if ("ticks" in $$props2)
      $$invalidate(4, ticks = $$props2.ticks);
    if ("tickCount" in $$props2)
      $$invalidate(33, tickCount = $$props2.tickCount);
    if ("tickExtra" in $$props2)
      $$invalidate(34, tickExtra = $$props2.tickExtra);
    if ("tickValues" in $$props2)
      $$invalidate(35, tickValues = $$props2.tickValues);
    if ("tickSize" in $$props2)
      $$invalidate(36, tickSize = $$props2.tickSize);
    if ("tickWidth" in $$props2)
      $$invalidate(5, tickWidth = $$props2.tickWidth);
    if ("tickColor" in $$props2)
      $$invalidate(6, tickColor = $$props2.tickColor);
    if ("tickOpacity" in $$props2)
      $$invalidate(7, tickOpacity = $$props2.tickOpacity);
    if ("labelFormat" in $$props2)
      $$invalidate(37, labelFormat = $$props2.labelFormat);
    if ("labelOffset" in $$props2)
      $$invalidate(38, labelOffset = $$props2.labelOffset);
    if ("labelRotate" in $$props2)
      $$invalidate(8, labelRotate = $$props2.labelRotate);
    if ("labelFont" in $$props2)
      $$invalidate(9, labelFont = $$props2.labelFont);
    if ("labelFontSize" in $$props2)
      $$invalidate(10, labelFontSize = $$props2.labelFontSize);
    if ("labelFontWeight" in $$props2)
      $$invalidate(11, labelFontWeight = $$props2.labelFontWeight);
    if ("labelOpacity" in $$props2)
      $$invalidate(12, labelOpacity = $$props2.labelOpacity);
    if ("labelColor" in $$props2)
      $$invalidate(13, labelColor = $$props2.labelColor);
    if ("titleHjust" in $$props2)
      $$invalidate(39, titleHjust = $$props2.titleHjust);
    if ("titleXOffset" in $$props2)
      $$invalidate(40, titleXOffset = $$props2.titleXOffset);
    if ("titleVjust" in $$props2)
      $$invalidate(41, titleVjust = $$props2.titleVjust);
    if ("titleYOffset" in $$props2)
      $$invalidate(42, titleYOffset = $$props2.titleYOffset);
    if ("title" in $$props2)
      $$invalidate(14, title = $$props2.title);
    if ("titleColor" in $$props2)
      $$invalidate(15, titleColor = $$props2.titleColor);
    if ("titleFont" in $$props2)
      $$invalidate(16, titleFont = $$props2.titleFont);
    if ("titleFontSize" in $$props2)
      $$invalidate(17, titleFontSize = $$props2.titleFontSize);
    if ("titleFontWeight" in $$props2)
      $$invalidate(18, titleFontWeight = $$props2.titleFontWeight);
    if ("titleOpacity" in $$props2)
      $$invalidate(19, titleOpacity = $$props2.titleOpacity);
    if ("titleRotate" in $$props2)
      $$invalidate(20, titleRotate = $$props2.titleRotate);
    if ("titleAnchorPoint" in $$props2)
      $$invalidate(21, titleAnchorPoint = $$props2.titleAnchorPoint);
    if ("clip" in $$props2)
      $$invalidate(22, clip = $$props2.clip);
    if ("xAbs" in $$props2)
      $$invalidate(43, xAbs = $$props2.xAbs);
    if ("axisWidth" in $$props2)
      $$invalidate(44, axisWidth = $$props2.axisWidth);
    if ("titleCoordinates" in $$props2)
      $$invalidate(25, titleCoordinates = $$props2.titleCoordinates);
    if ("tickLabelWidth" in $$props2)
      $$invalidate(45, tickLabelWidth = $$props2.tickLabelWidth);
    if ("tickLabelText" in $$props2)
      $$invalidate(23, tickLabelText = $$props2.tickLabelText);
    if ("labelAnchorPoint" in $$props2)
      $$invalidate(26, labelAnchorPoint = $$props2.labelAnchorPoint);
    if ("tickCoordinates" in $$props2)
      $$invalidate(24, tickCoordinates = $$props2.tickCoordinates);
    if ("tickLabelCoordinates" in $$props2)
      $$invalidate(27, tickLabelCoordinates = $$props2.tickLabelCoordinates);
    if ("format" in $$props2)
      $$invalidate(46, format2 = $$props2.format);
    if ("tickPositions" in $$props2)
      $$invalidate(47, tickPositions = $$props2.tickPositions);
    if ("baseLineCoordinates" in $$props2)
      $$invalidate(28, baseLineCoordinates = $$props2.baseLineCoordinates);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*$section*/
    131072) {
      $: {
        if ($section.transformation === "polar") {
          throw new Error("Axes do'nt work with polar coordinates (for now)");
        }
      }
    }
    if ($$self.$$.dirty[1] & /*hjust, xOffset, $section*/
    131075) {
      $:
        $$invalidate(43, xAbs = parseHJust(hjust, xOffset, $section.paddedBbox));
    }
    if ($$self.$$.dirty[1] & /*xAbs, $section*/
    135168) {
      $:
        $$invalidate(28, baseLineCoordinates = getBaseLineCoordinatesYAxis(xAbs, $section));
    }
    if ($$self.$$.dirty[1] & /*tickValues, $section, tickCount, tickExtra*/
    131100) {
      $:
        $$invalidate(47, tickPositions = getTickPositions(tickValues, $section.directScales.y, tickCount, tickExtra, $section.zoomIdentity ? {
          t: $section.zoomIdentity.y,
          k: $section.zoomIdentity.ky
        } : void 0));
    }
    if ($$self.$$.dirty[0] & /*flip*/
    1073741824 | $$self.$$.dirty[1] & /*tickPositions, xAbs, tickSize*/
    69664) {
      $:
        $$invalidate(24, tickCoordinates = getTickCoordinatesYAxis(tickPositions, xAbs, tickSize, flip));
    }
    if ($$self.$$.dirty[0] & /*ticks*/
    16 | $$self.$$.dirty[1] & /*labelFormat, $section*/
    131136) {
      $:
        $$invalidate(46, format2 = getFormat(labelFormat, $section.scaleY, ticks.length));
    }
    if ($$self.$$.dirty[1] & /*tickPositions, format*/
    98304) {
      $:
        $$invalidate(23, tickLabelText = tickPositions.map(format2));
    }
    if ($$self.$$.dirty[0] & /*tickCoordinates, flip*/
    1090519040 | $$self.$$.dirty[1] & /*labelOffset*/
    128) {
      $:
        $$invalidate(27, tickLabelCoordinates = getTickLabelCoordinatesYAxis(tickCoordinates, labelOffset, flip));
    }
    if ($$self.$$.dirty[0] & /*flip*/
    1073741824) {
      $:
        $$invalidate(26, labelAnchorPoint = flip ? "l" : "r");
    }
    if ($$self.$$.dirty[0] & /*tickLabelText, labelFontSize, labelFont*/
    8390144) {
      $:
        $$invalidate(45, tickLabelWidth = getTextWidth(tickLabelText[tickLabelText.length - 1], labelFontSize, labelFont));
    }
    if ($$self.$$.dirty[0] & /*baseLineWidth*/
    8 | $$self.$$.dirty[1] & /*tickSize, labelOffset, tickLabelWidth*/
    16544) {
      $:
        $$invalidate(44, axisWidth = baseLineWidth + tickSize + labelOffset + tickLabelWidth);
    }
    if ($$self.$$.dirty[0] & /*flip, titleFontSize*/
    1073872896 | $$self.$$.dirty[1] & /*titleHjust, titleXOffset, titleVjust, titleYOffset, $section, axisWidth, xAbs*/
    147200) {
      $:
        $$invalidate(25, titleCoordinates = getTitleCoordinatesYAxis(titleHjust, titleXOffset, titleVjust, titleYOffset, $section, flip, axisWidth, titleFontSize, xAbs));
    }
  };
  return [
    baseLine,
    baseLineColor,
    baseLineOpacity,
    baseLineWidth,
    ticks,
    tickWidth,
    tickColor,
    tickOpacity,
    labelRotate,
    labelFont,
    labelFontSize,
    labelFontWeight,
    labelOpacity,
    labelColor,
    title,
    titleColor,
    titleFont,
    titleFontSize,
    titleFontWeight,
    titleOpacity,
    titleRotate,
    titleAnchorPoint,
    clip,
    tickLabelText,
    tickCoordinates,
    titleCoordinates,
    labelAnchorPoint,
    tickLabelCoordinates,
    baseLineCoordinates,
    section,
    flip,
    hjust,
    xOffset,
    tickCount,
    tickExtra,
    tickValues,
    tickSize,
    labelFormat,
    labelOffset,
    titleHjust,
    titleXOffset,
    titleVjust,
    titleYOffset,
    xAbs,
    axisWidth,
    tickLabelWidth,
    format2,
    tickPositions,
    $section
  ];
}
var YAxis = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(
      this,
      options2,
      instance25,
      create_fragment25,
      safe_not_equal,
      {
        flip: 30,
        baseLine: 0,
        baseLineColor: 1,
        baseLineOpacity: 2,
        baseLineWidth: 3,
        hjust: 31,
        xOffset: 32,
        ticks: 4,
        tickCount: 33,
        tickExtra: 34,
        tickValues: 35,
        tickSize: 36,
        tickWidth: 5,
        tickColor: 6,
        tickOpacity: 7,
        labelFormat: 37,
        labelOffset: 38,
        labelRotate: 8,
        labelFont: 9,
        labelFontSize: 10,
        labelFontWeight: 11,
        labelOpacity: 12,
        labelColor: 13,
        titleHjust: 39,
        titleXOffset: 40,
        titleVjust: 41,
        titleYOffset: 42,
        title: 14,
        titleColor: 15,
        titleFont: 16,
        titleFontSize: 17,
        titleFontWeight: 18,
        titleOpacity: 19,
        titleRotate: 20,
        titleAnchorPoint: 21,
        clip: 22
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "YAxis",
      options: options2,
      id: create_fragment25.name
    });
  }
  get flip() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get baseLine() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseLine(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get baseLineColor() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseLineColor(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get baseLineOpacity() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseLineOpacity(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get baseLineWidth() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set baseLineWidth(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hjust() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hjust(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xOffset() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xOffset(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticks() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticks(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickCount() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickCount(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickExtra() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickExtra(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickValues() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickValues(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickSize() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickSize(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickWidth() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickWidth(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickColor() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickColor(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickOpacity() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickOpacity(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFormat() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFormat(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOffset() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOffset(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelRotate() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelRotate(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFont() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFont(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontSize() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontSize(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontWeight() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontWeight(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOpacity() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOpacity(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelColor() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelColor(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleHjust() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleHjust(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleXOffset() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleXOffset(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleVjust() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleVjust(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleYOffset() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleYOffset(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleColor() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleColor(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFont() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFont(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontSize() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontSize(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleFontWeight() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleFontWeight(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleOpacity() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleOpacity(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleRotate() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleRotate(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleAnchorPoint() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleAnchorPoint(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error_12("<YAxis>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error_12("<YAxis>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var YAxis_default = YAxis;

// node_modules/@snlab/florence/src/components/guides/gridLines/getCoordinates.js
function getCoordinatesXRaster(positions) {
  return {
    x: ({ scaleX, bwx }) => {
      const bandOffset = bwx ? bwx() / 2 : 0;
      return positions.map((t2) => scaleX(t2) + bandOffset).map((t2) => [t2, t2]);
    },
    y: ({ pyAt, paddedBbox }) => {
      const y1 = pyAt(paddedBbox.minY);
      const y23 = pyAt(paddedBbox.maxY);
      return Array(positions.length).fill([y1, y23]);
    }
  };
}
function getCoordinatesYRaster(positions) {
  return {
    x: ({ pxAt, paddedBbox }) => {
      const x1 = pxAt(paddedBbox.minX);
      const x23 = pxAt(paddedBbox.maxX);
      return Array(positions.length).fill([x1, x23]);
    },
    y: ({ scaleY, bwy }) => {
      const bandOffset = bwy ? bwy() / 2 : 0;
      return positions.map((t2) => scaleY(t2) + bandOffset).map((t2) => [t2, t2]);
    }
  };
}

// node_modules/@snlab/florence/src/components/guides/gridLines/XGridLines.svelte
var { Error: Error_13 } = globals;
function create_fragment26(ctx2) {
  let linelayer;
  let current;
  const linelayer_spread_levels = [
    /*coordinates*/
    ctx2[3],
    { strokeWidth: (
      /*width*/
      ctx2[0]
    ) },
    { opacity: (
      /*opacity*/
      ctx2[2]
    ) },
    { stroke: (
      /*color*/
      ctx2[1]
    ) }
  ];
  let linelayer_props = {};
  for (let i2 = 0; i2 < linelayer_spread_levels.length; i2 += 1) {
    linelayer_props = assign(linelayer_props, linelayer_spread_levels[i2]);
  }
  linelayer = new LineLayer_default({ props: linelayer_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(linelayer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error_13("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(linelayer, target, anchor);
      current = true;
    },
    p: function update(ctx3, [dirty]) {
      const linelayer_changes = dirty & /*coordinates, width, opacity, color*/
      15 ? get_spread_update(linelayer_spread_levels, [
        dirty & /*coordinates*/
        8 && get_spread_object(
          /*coordinates*/
          ctx3[3]
        ),
        dirty & /*width*/
        1 && { strokeWidth: (
          /*width*/
          ctx3[0]
        ) },
        dirty & /*opacity*/
        4 && { opacity: (
          /*opacity*/
          ctx3[2]
        ) },
        dirty & /*color*/
        2 && { stroke: (
          /*color*/
          ctx3[1]
        ) }
      ]) : {};
      linelayer.$set(linelayer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(linelayer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linelayer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linelayer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let positions;
  let coordinates;
  let $section;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XGridLines", slots, []);
  let { count = 10 } = $$props;
  let { extra = false } = $$props;
  let { values = void 0 } = $$props;
  let { width = 0.25 } = $$props;
  let { color = "black" } = $$props;
  let { opacity = 1 } = $$props;
  const section = getContext("section");
  validate_store(section, "section");
  component_subscribe($$self, section, (value) => $$invalidate(9, $section = value));
  const writable_props = ["count", "extra", "values", "width", "color", "opacity"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XGridLines> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("count" in $$props2)
      $$invalidate(5, count = $$props2.count);
    if ("extra" in $$props2)
      $$invalidate(6, extra = $$props2.extra);
    if ("values" in $$props2)
      $$invalidate(7, values = $$props2.values);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("opacity" in $$props2)
      $$invalidate(2, opacity = $$props2.opacity);
  };
  $$self.$capture_state = () => ({
    getContext,
    LineLayer: LineLayer_default,
    getTickPositions,
    getCoordinatesXRaster,
    count,
    extra,
    values,
    width,
    color,
    opacity,
    section,
    positions,
    coordinates,
    $section
  });
  $$self.$inject_state = ($$props2) => {
    if ("count" in $$props2)
      $$invalidate(5, count = $$props2.count);
    if ("extra" in $$props2)
      $$invalidate(6, extra = $$props2.extra);
    if ("values" in $$props2)
      $$invalidate(7, values = $$props2.values);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("opacity" in $$props2)
      $$invalidate(2, opacity = $$props2.opacity);
    if ("positions" in $$props2)
      $$invalidate(8, positions = $$props2.positions);
    if ("coordinates" in $$props2)
      $$invalidate(3, coordinates = $$props2.coordinates);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$section*/
    512) {
      $: {
        if ($section.coordinateSystem) {
          throw new Error("Cannot use grid lines with alternative coordinate systems (for now)");
        }
      }
    }
    if ($$self.$$.dirty & /*values, $section, count, extra*/
    736) {
      $:
        $$invalidate(8, positions = getTickPositions(values, $section.directScales.x, count, extra, $section.zoomIdentity ? {
          t: $section.zoomIdentity.x,
          k: $section.zoomIdentity.kx
        } : void 0));
    }
    if ($$self.$$.dirty & /*positions*/
    256) {
      $:
        $$invalidate(3, coordinates = getCoordinatesXRaster(positions));
    }
  };
  return [
    width,
    color,
    opacity,
    coordinates,
    section,
    count,
    extra,
    values,
    positions,
    $section
  ];
}
var XGridLines = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance26, create_fragment26, safe_not_equal, {
      count: 5,
      extra: 6,
      values: 7,
      width: 0,
      color: 1,
      opacity: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XGridLines",
      options: options2,
      id: create_fragment26.name
    });
  }
  get count() {
    throw new Error_13("<XGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error_13("<XGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get extra() {
    throw new Error_13("<XGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set extra(value) {
    throw new Error_13("<XGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get values() {
    throw new Error_13("<XGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set values(value) {
    throw new Error_13("<XGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error_13("<XGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error_13("<XGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_13("<XGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_13("<XGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error_13("<XGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error_13("<XGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var XGridLines_default = XGridLines;

// node_modules/@snlab/florence/src/components/guides/gridLines/YGridLines.svelte
var { Error: Error_14 } = globals;
function create_fragment27(ctx2) {
  let linelayer;
  let current;
  const linelayer_spread_levels = [
    /*coordinates*/
    ctx2[3],
    { strokeWidth: (
      /*width*/
      ctx2[0]
    ) },
    { opacity: (
      /*opacity*/
      ctx2[2]
    ) },
    { stroke: (
      /*color*/
      ctx2[1]
    ) }
  ];
  let linelayer_props = {};
  for (let i2 = 0; i2 < linelayer_spread_levels.length; i2 += 1) {
    linelayer_props = assign(linelayer_props, linelayer_spread_levels[i2]);
  }
  linelayer = new LineLayer_default({ props: linelayer_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(linelayer.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error_14("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(linelayer, target, anchor);
      current = true;
    },
    p: function update(ctx3, [dirty]) {
      const linelayer_changes = dirty & /*coordinates, width, opacity, color*/
      15 ? get_spread_update(linelayer_spread_levels, [
        dirty & /*coordinates*/
        8 && get_spread_object(
          /*coordinates*/
          ctx3[3]
        ),
        dirty & /*width*/
        1 && { strokeWidth: (
          /*width*/
          ctx3[0]
        ) },
        dirty & /*opacity*/
        4 && { opacity: (
          /*opacity*/
          ctx3[2]
        ) },
        dirty & /*color*/
        2 && { stroke: (
          /*color*/
          ctx3[1]
        ) }
      ]) : {};
      linelayer.$set(linelayer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(linelayer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(linelayer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(linelayer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let positions;
  let coordinates;
  let $section;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("YGridLines", slots, []);
  let { count = 10 } = $$props;
  let { extra = false } = $$props;
  let { values = void 0 } = $$props;
  let { width = 0.25 } = $$props;
  let { color = "black" } = $$props;
  let { opacity = 1 } = $$props;
  const section = getContext("section");
  validate_store(section, "section");
  component_subscribe($$self, section, (value) => $$invalidate(9, $section = value));
  const writable_props = ["count", "extra", "values", "width", "color", "opacity"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<YGridLines> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("count" in $$props2)
      $$invalidate(5, count = $$props2.count);
    if ("extra" in $$props2)
      $$invalidate(6, extra = $$props2.extra);
    if ("values" in $$props2)
      $$invalidate(7, values = $$props2.values);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("opacity" in $$props2)
      $$invalidate(2, opacity = $$props2.opacity);
  };
  $$self.$capture_state = () => ({
    getContext,
    LineLayer: LineLayer_default,
    getTickPositions,
    getCoordinatesYRaster,
    count,
    extra,
    values,
    width,
    color,
    opacity,
    section,
    positions,
    coordinates,
    $section
  });
  $$self.$inject_state = ($$props2) => {
    if ("count" in $$props2)
      $$invalidate(5, count = $$props2.count);
    if ("extra" in $$props2)
      $$invalidate(6, extra = $$props2.extra);
    if ("values" in $$props2)
      $$invalidate(7, values = $$props2.values);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("opacity" in $$props2)
      $$invalidate(2, opacity = $$props2.opacity);
    if ("positions" in $$props2)
      $$invalidate(8, positions = $$props2.positions);
    if ("coordinates" in $$props2)
      $$invalidate(3, coordinates = $$props2.coordinates);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$section*/
    512) {
      $: {
        if ($section.coordinateSystem) {
          throw new Error("Cannot use grid lines with alternative coordinate systems (for now)");
        }
      }
    }
    if ($$self.$$.dirty & /*values, $section, count, extra*/
    736) {
      $:
        $$invalidate(8, positions = getTickPositions(values, $section.directScales.y, count, extra, $section.zoomIdentity ? {
          t: $section.zoomIdentity.y,
          k: $section.zoomIdentity.ky
        } : void 0));
    }
    if ($$self.$$.dirty & /*positions*/
    256) {
      $:
        $$invalidate(3, coordinates = getCoordinatesYRaster(positions));
    }
  };
  return [
    width,
    color,
    opacity,
    coordinates,
    section,
    count,
    extra,
    values,
    positions,
    $section
  ];
}
var YGridLines = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance27, create_fragment27, safe_not_equal, {
      count: 5,
      extra: 6,
      values: 7,
      width: 0,
      color: 1,
      opacity: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "YGridLines",
      options: options2,
      id: create_fragment27.name
    });
  }
  get count() {
    throw new Error_14("<YGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set count(value) {
    throw new Error_14("<YGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get extra() {
    throw new Error_14("<YGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set extra(value) {
    throw new Error_14("<YGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get values() {
    throw new Error_14("<YGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set values(value) {
    throw new Error_14("<YGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error_14("<YGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error_14("<YGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_14("<YGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_14("<YGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error_14("<YGridLines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error_14("<YGridLines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var YGridLines_default = YGridLines;

// node_modules/@snlab/florence/src/components/guides/legends/legend.js
function parseAesthetic(aesthetic, length) {
  if (aesthetic.constructor === Array) {
    if (aesthetic.length !== length) {
      throw new Error("Aesthetics and labels must all be of same length");
    }
    return aesthetic;
  }
  return Array(length).fill(aesthetic);
}

// node_modules/@snlab/florence/src/components/guides/legends/DiscreteLegend.svelte
var { Error: Error_15 } = globals;
function get_each_context2(ctx2, list, i2) {
  const child_ctx = ctx2.slice();
  child_ctx[25] = list[i2];
  child_ctx[27] = i2;
  return child_ctx;
}
function get_each_context_12(ctx2, list, i2) {
  const child_ctx = ctx2.slice();
  child_ctx[18] = list[i2];
  child_ctx[27] = i2;
  return child_ctx;
}
function create_default_slot_4(ctx2) {
  let rectangle;
  let t2;
  let current;
  rectangle = new Rectangle_default({
    props: {
      fill: (
        /*fill*/
        ctx2[18]
      ),
      fillOpacity: (
        /*opacities*/
        ctx2[19][
          /*i*/
          ctx2[27]
        ]
      ),
      stroke: (
        /*stroke*/
        ctx2[9]
      ),
      strokeWidth: (
        /*strokeWidth*/
        ctx2[10]
      ),
      clip: (
        /*clip*/
        ctx2[16]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rectangle.$$.fragment);
      t2 = space();
    },
    m: function mount(target, anchor) {
      mount_component(rectangle, target, anchor);
      insert_dev(target, t2, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const rectangle_changes = {};
      if (dirty & /*fills*/
      1048576)
        rectangle_changes.fill = /*fill*/
        ctx3[18];
      if (dirty & /*opacities*/
      524288)
        rectangle_changes.fillOpacity = /*opacities*/
        ctx3[19][
          /*i*/
          ctx3[27]
        ];
      if (dirty & /*stroke*/
      512)
        rectangle_changes.stroke = /*stroke*/
        ctx3[9];
      if (dirty & /*strokeWidth*/
      1024)
        rectangle_changes.strokeWidth = /*strokeWidth*/
        ctx3[10];
      if (dirty & /*clip*/
      65536)
        rectangle_changes.clip = /*clip*/
        ctx3[16];
      rectangle.$set(rectangle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rectangle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rectangle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
      destroy_component(rectangle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(62:6) <Section         {...cells[i]}         padding={cellPadding}       >",
    ctx: ctx2
  });
  return block;
}
function create_each_block_12(ctx2) {
  let section;
  let current;
  const section_spread_levels = [
    /*cells*/
    ctx2[24][
      /*i*/
      ctx2[27]
    ],
    { padding: (
      /*cellPadding*/
      ctx2[7]
    ) }
  ];
  let section_props = {
    $$slots: { default: [create_default_slot_4] },
    $$scope: { ctx: ctx2 }
  };
  for (let i2 = 0; i2 < section_spread_levels.length; i2 += 1) {
    section_props = assign(section_props, section_spread_levels[i2]);
  }
  section = new Section_default({ props: section_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(section.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const section_changes = dirty & /*cells, cellPadding*/
      16777344 ? get_spread_update(section_spread_levels, [
        dirty & /*cells*/
        16777216 && get_spread_object(
          /*cells*/
          ctx3[24][
            /*i*/
            ctx3[27]
          ]
        ),
        dirty & /*cellPadding*/
        128 && { padding: (
          /*cellPadding*/
          ctx3[7]
        ) }
      ]) : {};
      if (dirty & /*$$scope, fills, opacities, stroke, strokeWidth, clip*/
      10028544) {
        section_changes.$$scope = { dirty, ctx: ctx3 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(60:4) {#each fills as fill, i}",
    ctx: ctx2
  });
  return block;
}
function create_default_slot_3(ctx2) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*fills*/
    ctx2[20]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_12(get_each_context_12(ctx2, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (dirty & /*cells, cellPadding, fills, opacities, stroke, strokeWidth, clip*/
      18417280) {
        each_value_1 = ensure_array_like_dev(
          /*fills*/
          ctx3[20]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_12(ctx3, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_12(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(51:2) <Grid      x2={xDivider}      y1={yDivider}     numberOfCells={fills.length}     columns={1}     {padding}     let:cells   >",
    ctx: ctx2
  });
  return block;
}
function create_default_slot_2(ctx2) {
  let label_1;
  let t2;
  let current;
  label_1 = new Label_default({
    props: {
      x: 0,
      y: 0.5,
      text: (
        /*label*/
        ctx2[25]
      ),
      anchorPoint: "l",
      fontFamily: (
        /*labelFont*/
        ctx2[11]
      ),
      fontSize: (
        /*labelFontSize*/
        ctx2[12]
      ),
      fontWeight: (
        /*labelFontWeight*/
        ctx2[13]
      ),
      opacity: (
        /*labelOpacity*/
        ctx2[14]
      ),
      fill: (
        /*labelColor*/
        ctx2[15]
      ),
      clip: (
        /*clip*/
        ctx2[16]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(label_1.$$.fragment);
      t2 = space();
    },
    m: function mount(target, anchor) {
      mount_component(label_1, target, anchor);
      insert_dev(target, t2, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const label_1_changes = {};
      if (dirty & /*labels*/
      256)
        label_1_changes.text = /*label*/
        ctx3[25];
      if (dirty & /*labelFont*/
      2048)
        label_1_changes.fontFamily = /*labelFont*/
        ctx3[11];
      if (dirty & /*labelFontSize*/
      4096)
        label_1_changes.fontSize = /*labelFontSize*/
        ctx3[12];
      if (dirty & /*labelFontWeight*/
      8192)
        label_1_changes.fontWeight = /*labelFontWeight*/
        ctx3[13];
      if (dirty & /*labelOpacity*/
      16384)
        label_1_changes.opacity = /*labelOpacity*/
        ctx3[14];
      if (dirty & /*labelColor*/
      32768)
        label_1_changes.fill = /*labelColor*/
        ctx3[15];
      if (dirty & /*clip*/
      65536)
        label_1_changes.clip = /*clip*/
        ctx3[16];
      label_1.$set(label_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
      destroy_component(label_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(93:6) <Section {...cells[i]} padding={cellPadding}>",
    ctx: ctx2
  });
  return block;
}
function create_each_block2(ctx2) {
  let section;
  let current;
  const section_spread_levels = [
    /*cells*/
    ctx2[24][
      /*i*/
      ctx2[27]
    ],
    { padding: (
      /*cellPadding*/
      ctx2[7]
    ) }
  ];
  let section_props = {
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx: ctx2 }
  };
  for (let i2 = 0; i2 < section_spread_levels.length; i2 += 1) {
    section_props = assign(section_props, section_spread_levels[i2]);
  }
  section = new Section_default({ props: section_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(section.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const section_changes = dirty & /*cells, cellPadding*/
      16777344 ? get_spread_update(section_spread_levels, [
        dirty & /*cells*/
        16777216 && get_spread_object(
          /*cells*/
          ctx3[24][
            /*i*/
            ctx3[27]
          ]
        ),
        dirty & /*cellPadding*/
        128 && { padding: (
          /*cellPadding*/
          ctx3[7]
        ) }
      ]) : {};
      if (dirty & /*$$scope, labels, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip*/
      8517888) {
        section_changes.$$scope = { dirty, ctx: ctx3 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(91:4) {#each labels as label, i}",
    ctx: ctx2
  });
  return block;
}
function create_default_slot_12(ctx2) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*labels*/
    ctx2[8]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block2(get_each_context2(ctx2, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (dirty & /*cells, cellPadding, labels, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip*/
      16906624) {
        each_value = ensure_array_like_dev(
          /*labels*/
          ctx3[8]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context2(ctx3, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(82:2) <Grid      x1={xDivider}     y1={yDivider}     numberOfCells={labels.length}     columns={1}     {padding}     let:cells   >",
    ctx: ctx2
  });
  return block;
}
function create_default_slot5(ctx2) {
  let t02;
  let grid0;
  let t12;
  let grid1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx2[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx2,
    /*$$scope*/
    ctx2[23],
    null
  );
  grid0 = new Grid_default({
    props: {
      x2: (
        /*xDivider*/
        ctx2[4]
      ),
      y1: (
        /*yDivider*/
        ctx2[5]
      ),
      numberOfCells: (
        /*fills*/
        ctx2[20].length
      ),
      columns: 1,
      padding: (
        /*padding*/
        ctx2[6]
      ),
      $$slots: {
        default: [
          create_default_slot_3,
          ({ cells }) => ({ 24: cells }),
          ({ cells }) => cells ? 16777216 : 0
        ]
      },
      $$scope: { ctx: ctx2 }
    },
    $$inline: true
  });
  grid1 = new Grid_default({
    props: {
      x1: (
        /*xDivider*/
        ctx2[4]
      ),
      y1: (
        /*yDivider*/
        ctx2[5]
      ),
      numberOfCells: (
        /*labels*/
        ctx2[8].length
      ),
      columns: 1,
      padding: (
        /*padding*/
        ctx2[6]
      ),
      $$slots: {
        default: [
          create_default_slot_12,
          ({ cells }) => ({ 24: cells }),
          ({ cells }) => cells ? 16777216 : 0
        ]
      },
      $$scope: { ctx: ctx2 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
      t02 = space();
      create_component(grid0.$$.fragment);
      t12 = space();
      create_component(grid1.$$.fragment);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_dev(target, t02, anchor);
      mount_component(grid0, target, anchor);
      insert_dev(target, t12, anchor);
      mount_component(grid1, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx3,
            /*$$scope*/
            ctx3[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx3[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx3[23],
              dirty,
              null
            ),
            null
          );
        }
      }
      const grid0_changes = {};
      if (dirty & /*xDivider*/
      16)
        grid0_changes.x2 = /*xDivider*/
        ctx3[4];
      if (dirty & /*yDivider*/
      32)
        grid0_changes.y1 = /*yDivider*/
        ctx3[5];
      if (dirty & /*fills*/
      1048576)
        grid0_changes.numberOfCells = /*fills*/
        ctx3[20].length;
      if (dirty & /*padding*/
      64)
        grid0_changes.padding = /*padding*/
        ctx3[6];
      if (dirty & /*$$scope, fills, cells, cellPadding, opacities, stroke, strokeWidth, clip*/
      26805888) {
        grid0_changes.$$scope = { dirty, ctx: ctx3 };
      }
      grid0.$set(grid0_changes);
      const grid1_changes = {};
      if (dirty & /*xDivider*/
      16)
        grid1_changes.x1 = /*xDivider*/
        ctx3[4];
      if (dirty & /*yDivider*/
      32)
        grid1_changes.y1 = /*yDivider*/
        ctx3[5];
      if (dirty & /*labels*/
      256)
        grid1_changes.numberOfCells = /*labels*/
        ctx3[8].length;
      if (dirty & /*padding*/
      64)
        grid1_changes.padding = /*padding*/
        ctx3[6];
      if (dirty & /*$$scope, labels, cells, cellPadding, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip*/
      25295232) {
        grid1_changes.$$scope = { dirty, ctx: ctx3 };
      }
      grid1.$set(grid1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(grid0.$$.fragment, local);
      transition_in(grid1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(grid0.$$.fragment, local);
      transition_out(grid1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
      }
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(grid0, detaching);
      destroy_component(grid1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(45:0) <Section {x1} {x2} {y1} {y2} {backgroundColor}>",
    ctx: ctx2
  });
  return block;
}
function create_fragment28(ctx2) {
  let section;
  let current;
  section = new Section_default({
    props: {
      x1: (
        /*x1*/
        ctx2[0]
      ),
      x2: (
        /*x2*/
        ctx2[1]
      ),
      y1: (
        /*y1*/
        ctx2[2]
      ),
      y2: (
        /*y2*/
        ctx2[3]
      ),
      backgroundColor: (
        /*backgroundColor*/
        ctx2[17]
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx: ctx2 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(section.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error_15("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx3, [dirty]) {
      const section_changes = {};
      if (dirty & /*x1*/
      1)
        section_changes.x1 = /*x1*/
        ctx3[0];
      if (dirty & /*x2*/
      2)
        section_changes.x2 = /*x2*/
        ctx3[1];
      if (dirty & /*y1*/
      4)
        section_changes.y1 = /*y1*/
        ctx3[2];
      if (dirty & /*y2*/
      8)
        section_changes.y2 = /*y2*/
        ctx3[3];
      if (dirty & /*backgroundColor*/
      131072)
        section_changes.backgroundColor = /*backgroundColor*/
        ctx3[17];
      if (dirty & /*$$scope, xDivider, yDivider, labels, padding, cellPadding, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip, fills, opacities, stroke, strokeWidth*/
      10092528) {
        section_changes.$$scope = { dirty, ctx: ctx3 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let fills;
  let opacities;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DiscreteLegend", slots, ["default"]);
  let { x1 } = $$props;
  let { x2: x23 } = $$props;
  let { y1 } = $$props;
  let { y2: y23 } = $$props;
  let { xDivider = 0.3 } = $$props;
  let { yDivider = 0.2 } = $$props;
  let { padding = 1 } = $$props;
  let { cellPadding = 2 } = $$props;
  let { labels } = $$props;
  let { fill } = $$props;
  let { opacity = 1 } = $$props;
  let { stroke = "none" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { labelFont = "Helvetica" } = $$props;
  let { labelFontSize = 10 } = $$props;
  let { labelFontWeight = "normal" } = $$props;
  let { labelOpacity = 1 } = $$props;
  let { labelColor = "black" } = $$props;
  let { clip = "outer" } = $$props;
  let { backgroundColor = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (x1 === void 0 && !("x1" in $$props || $$self.$$.bound[$$self.$$.props["x1"]])) {
      console.warn("<DiscreteLegend> was created without expected prop 'x1'");
    }
    if (x23 === void 0 && !("x2" in $$props || $$self.$$.bound[$$self.$$.props["x2"]])) {
      console.warn("<DiscreteLegend> was created without expected prop 'x2'");
    }
    if (y1 === void 0 && !("y1" in $$props || $$self.$$.bound[$$self.$$.props["y1"]])) {
      console.warn("<DiscreteLegend> was created without expected prop 'y1'");
    }
    if (y23 === void 0 && !("y2" in $$props || $$self.$$.bound[$$self.$$.props["y2"]])) {
      console.warn("<DiscreteLegend> was created without expected prop 'y2'");
    }
    if (labels === void 0 && !("labels" in $$props || $$self.$$.bound[$$self.$$.props["labels"]])) {
      console.warn("<DiscreteLegend> was created without expected prop 'labels'");
    }
    if (fill === void 0 && !("fill" in $$props || $$self.$$.bound[$$self.$$.props["fill"]])) {
      console.warn("<DiscreteLegend> was created without expected prop 'fill'");
    }
  });
  const writable_props = [
    "x1",
    "x2",
    "y1",
    "y2",
    "xDivider",
    "yDivider",
    "padding",
    "cellPadding",
    "labels",
    "fill",
    "opacity",
    "stroke",
    "strokeWidth",
    "labelFont",
    "labelFontSize",
    "labelFontWeight",
    "labelOpacity",
    "labelColor",
    "clip",
    "backgroundColor"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DiscreteLegend> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(0, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(1, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(2, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(3, y23 = $$props2.y2);
    if ("xDivider" in $$props2)
      $$invalidate(4, xDivider = $$props2.xDivider);
    if ("yDivider" in $$props2)
      $$invalidate(5, yDivider = $$props2.yDivider);
    if ("padding" in $$props2)
      $$invalidate(6, padding = $$props2.padding);
    if ("cellPadding" in $$props2)
      $$invalidate(7, cellPadding = $$props2.cellPadding);
    if ("labels" in $$props2)
      $$invalidate(8, labels = $$props2.labels);
    if ("fill" in $$props2)
      $$invalidate(18, fill = $$props2.fill);
    if ("opacity" in $$props2)
      $$invalidate(21, opacity = $$props2.opacity);
    if ("stroke" in $$props2)
      $$invalidate(9, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(10, strokeWidth = $$props2.strokeWidth);
    if ("labelFont" in $$props2)
      $$invalidate(11, labelFont = $$props2.labelFont);
    if ("labelFontSize" in $$props2)
      $$invalidate(12, labelFontSize = $$props2.labelFontSize);
    if ("labelFontWeight" in $$props2)
      $$invalidate(13, labelFontWeight = $$props2.labelFontWeight);
    if ("labelOpacity" in $$props2)
      $$invalidate(14, labelOpacity = $$props2.labelOpacity);
    if ("labelColor" in $$props2)
      $$invalidate(15, labelColor = $$props2.labelColor);
    if ("clip" in $$props2)
      $$invalidate(16, clip = $$props2.clip);
    if ("backgroundColor" in $$props2)
      $$invalidate(17, backgroundColor = $$props2.backgroundColor);
    if ("$$scope" in $$props2)
      $$invalidate(23, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Section: Section_default,
    Grid: Grid_default,
    Rectangle: Rectangle_default,
    Label: Label_default,
    parseAesthetic,
    x1,
    x2: x23,
    y1,
    y2: y23,
    xDivider,
    yDivider,
    padding,
    cellPadding,
    labels,
    fill,
    opacity,
    stroke,
    strokeWidth,
    labelFont,
    labelFontSize,
    labelFontWeight,
    labelOpacity,
    labelColor,
    clip,
    backgroundColor,
    opacities,
    fills
  });
  $$self.$inject_state = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(0, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(1, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(2, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(3, y23 = $$props2.y2);
    if ("xDivider" in $$props2)
      $$invalidate(4, xDivider = $$props2.xDivider);
    if ("yDivider" in $$props2)
      $$invalidate(5, yDivider = $$props2.yDivider);
    if ("padding" in $$props2)
      $$invalidate(6, padding = $$props2.padding);
    if ("cellPadding" in $$props2)
      $$invalidate(7, cellPadding = $$props2.cellPadding);
    if ("labels" in $$props2)
      $$invalidate(8, labels = $$props2.labels);
    if ("fill" in $$props2)
      $$invalidate(18, fill = $$props2.fill);
    if ("opacity" in $$props2)
      $$invalidate(21, opacity = $$props2.opacity);
    if ("stroke" in $$props2)
      $$invalidate(9, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(10, strokeWidth = $$props2.strokeWidth);
    if ("labelFont" in $$props2)
      $$invalidate(11, labelFont = $$props2.labelFont);
    if ("labelFontSize" in $$props2)
      $$invalidate(12, labelFontSize = $$props2.labelFontSize);
    if ("labelFontWeight" in $$props2)
      $$invalidate(13, labelFontWeight = $$props2.labelFontWeight);
    if ("labelOpacity" in $$props2)
      $$invalidate(14, labelOpacity = $$props2.labelOpacity);
    if ("labelColor" in $$props2)
      $$invalidate(15, labelColor = $$props2.labelColor);
    if ("clip" in $$props2)
      $$invalidate(16, clip = $$props2.clip);
    if ("backgroundColor" in $$props2)
      $$invalidate(17, backgroundColor = $$props2.backgroundColor);
    if ("opacities" in $$props2)
      $$invalidate(19, opacities = $$props2.opacities);
    if ("fills" in $$props2)
      $$invalidate(20, fills = $$props2.fills);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*fill, labels*/
    262400) {
      $:
        $$invalidate(20, fills = parseAesthetic(fill, labels.length));
    }
    if ($$self.$$.dirty & /*opacity, labels*/
    2097408) {
      $:
        $$invalidate(19, opacities = parseAesthetic(opacity, labels.length));
    }
    if ($$self.$$.dirty & /*fills, opacities*/
    1572864) {
      $: {
        if (fills.length !== opacities.length) {
          throw new Error("Aesthetics and labels must all be of same length");
        }
      }
    }
  };
  return [
    x1,
    x23,
    y1,
    y23,
    xDivider,
    yDivider,
    padding,
    cellPadding,
    labels,
    stroke,
    strokeWidth,
    labelFont,
    labelFontSize,
    labelFontWeight,
    labelOpacity,
    labelColor,
    clip,
    backgroundColor,
    fill,
    opacities,
    fills,
    opacity,
    slots,
    $$scope
  ];
}
var DiscreteLegend = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance28, create_fragment28, safe_not_equal, {
      x1: 0,
      x2: 1,
      y1: 2,
      y2: 3,
      xDivider: 4,
      yDivider: 5,
      padding: 6,
      cellPadding: 7,
      labels: 8,
      fill: 18,
      opacity: 21,
      stroke: 9,
      strokeWidth: 10,
      labelFont: 11,
      labelFontSize: 12,
      labelFontWeight: 13,
      labelOpacity: 14,
      labelColor: 15,
      clip: 16,
      backgroundColor: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DiscreteLegend",
      options: options2,
      id: create_fragment28.name
    });
  }
  get x1() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x1(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x2() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x2(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y1() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y1(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y2() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y2(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xDivider() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xDivider(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yDivider() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yDivider(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cellPadding() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cellPadding(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labels() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labels(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFont() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFont(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontSize() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontSize(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontWeight() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontWeight(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOpacity() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOpacity(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelColor() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelColor(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error_15("<DiscreteLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error_15("<DiscreteLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DiscreteLegend_default = DiscreteLegend;

// node_modules/@snlab/florence/src/components/guides/legends/gradientLegend.js
function generateStopOffsets(numberOfColors) {
  if (numberOfColors < 2)
    throw new Error("At least 2 colors needed for gradient");
  const increment = 100 / (numberOfColors - 1);
  const offsets = [];
  for (let i2 = 0; i2 < numberOfColors; i2++) {
    offsets.push(`${Math.floor(i2 * increment)}%`);
  }
  return offsets;
}
function getRectangleCoordinates(xDivider, yDivider, numberOfLabels) {
  const ySpace = (1 - yDivider) / (numberOfLabels * 2);
  return {
    x1: 0,
    x2: xDivider,
    y1: yDivider + ySpace,
    y2: 1 - ySpace
  };
}

// node_modules/@snlab/florence/src/components/guides/legends/Gradient.svelte
var file6 = "node_modules/@snlab/florence/src/components/guides/legends/Gradient.svelte";
function get_each_context3(ctx2, list, i2) {
  const child_ctx = ctx2.slice();
  child_ctx[4] = list[i2];
  child_ctx[6] = i2;
  return child_ctx;
}
function create_each_block3(ctx2) {
  let stop;
  let stop_offset_value;
  let stop_style_value;
  const block = {
    c: function create() {
      stop = svg_element("stop");
      attr_dev(stop, "offset", stop_offset_value = /*stopOffsets*/
      ctx2[3][
        /*i*/
        ctx2[6]
      ]);
      attr_dev(stop, "style", stop_style_value = `
            stop-color: ${/*fills*/
      ctx2[1][
        /*i*/
        ctx2[6]
      ]};
            stop-opacity: ${/*opacities*/
      ctx2[2][
        /*i*/
        ctx2[6]
      ]}
          `);
      add_location(stop, file6, 16, 8, 315);
    },
    m: function mount(target, anchor) {
      insert_dev(target, stop, anchor);
    },
    p: function update(ctx3, dirty) {
      if (dirty & /*stopOffsets*/
      8 && stop_offset_value !== (stop_offset_value = /*stopOffsets*/
      ctx3[3][
        /*i*/
        ctx3[6]
      ])) {
        attr_dev(stop, "offset", stop_offset_value);
      }
      if (dirty & /*fills, opacities*/
      6 && stop_style_value !== (stop_style_value = `
            stop-color: ${/*fills*/
      ctx3[1][
        /*i*/
        ctx3[6]
      ]};
            stop-opacity: ${/*opacities*/
      ctx3[2][
        /*i*/
        ctx3[6]
      ]}
          `)) {
        attr_dev(stop, "style", stop_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(stop);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(15:6) {#each fills as _, i}",
    ctx: ctx2
  });
  return block;
}
function create_fragment29(ctx2) {
  let defs;
  let linearGradient;
  let each_value = ensure_array_like_dev(
    /*fills*/
    ctx2[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block3(get_each_context3(ctx2, each_value, i2));
  }
  const block = {
    c: function create() {
      defs = svg_element("defs");
      linearGradient = svg_element("linearGradient");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr_dev(
        linearGradient,
        "id",
        /*gradientId*/
        ctx2[0]
      );
      attr_dev(linearGradient, "gradientTransform", "rotate(90)");
      add_location(linearGradient, file6, 12, 4, 213);
      add_location(defs, file6, 10, 0, 201);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, defs, anchor);
      append_dev(defs, linearGradient);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(linearGradient, null);
        }
      }
    },
    p: function update(ctx3, [dirty]) {
      if (dirty & /*stopOffsets, fills, opacities*/
      14) {
        each_value = ensure_array_like_dev(
          /*fills*/
          ctx3[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context3(ctx3, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(linearGradient, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*gradientId*/
      1) {
        attr_dev(
          linearGradient,
          "id",
          /*gradientId*/
          ctx3[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(defs);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let stopOffsets;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Gradient", slots, []);
  let { gradientId } = $$props;
  let { fills } = $$props;
  let { opacities } = $$props;
  $$self.$$.on_mount.push(function() {
    if (gradientId === void 0 && !("gradientId" in $$props || $$self.$$.bound[$$self.$$.props["gradientId"]])) {
      console.warn("<Gradient> was created without expected prop 'gradientId'");
    }
    if (fills === void 0 && !("fills" in $$props || $$self.$$.bound[$$self.$$.props["fills"]])) {
      console.warn("<Gradient> was created without expected prop 'fills'");
    }
    if (opacities === void 0 && !("opacities" in $$props || $$self.$$.bound[$$self.$$.props["opacities"]])) {
      console.warn("<Gradient> was created without expected prop 'opacities'");
    }
  });
  const writable_props = ["gradientId", "fills", "opacities"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Gradient> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("gradientId" in $$props2)
      $$invalidate(0, gradientId = $$props2.gradientId);
    if ("fills" in $$props2)
      $$invalidate(1, fills = $$props2.fills);
    if ("opacities" in $$props2)
      $$invalidate(2, opacities = $$props2.opacities);
  };
  $$self.$capture_state = () => ({
    generateStopOffsets,
    gradientId,
    fills,
    opacities,
    stopOffsets
  });
  $$self.$inject_state = ($$props2) => {
    if ("gradientId" in $$props2)
      $$invalidate(0, gradientId = $$props2.gradientId);
    if ("fills" in $$props2)
      $$invalidate(1, fills = $$props2.fills);
    if ("opacities" in $$props2)
      $$invalidate(2, opacities = $$props2.opacities);
    if ("stopOffsets" in $$props2)
      $$invalidate(3, stopOffsets = $$props2.stopOffsets);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*fills*/
    2) {
      $:
        $$invalidate(3, stopOffsets = generateStopOffsets(fills.length));
    }
  };
  return [gradientId, fills, opacities, stopOffsets];
}
var Gradient = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance29, create_fragment29, safe_not_equal, { gradientId: 0, fills: 1, opacities: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Gradient",
      options: options2,
      id: create_fragment29.name
    });
  }
  get gradientId() {
    throw new Error("<Gradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gradientId(value) {
    throw new Error("<Gradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fills() {
    throw new Error("<Gradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fills(value) {
    throw new Error("<Gradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacities() {
    throw new Error("<Gradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacities(value) {
    throw new Error("<Gradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Gradient_default = Gradient;

// node_modules/@snlab/florence/src/components/guides/legends/GradientLegend.svelte
var { Error: Error_16 } = globals;
function get_each_context4(ctx2, list, i2) {
  const child_ctx = ctx2.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function create_default_slot_32(ctx2) {
  let rectangle;
  let current;
  rectangle = new Rectangle_default({
    props: {
      fill: `url(#${/*gradientId*/
      ctx2[20]})`,
      stroke: (
        /*stroke*/
        ctx2[8]
      ),
      strokeWidth: (
        /*strokeWidth*/
        ctx2[9]
      ),
      clip: (
        /*clip*/
        ctx2[15]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rectangle.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(rectangle, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const rectangle_changes = {};
      if (dirty & /*stroke*/
      256)
        rectangle_changes.stroke = /*stroke*/
        ctx3[8];
      if (dirty & /*strokeWidth*/
      512)
        rectangle_changes.strokeWidth = /*strokeWidth*/
        ctx3[9];
      if (dirty & /*clip*/
      32768)
        rectangle_changes.clip = /*clip*/
        ctx3[15];
      rectangle.$set(rectangle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rectangle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rectangle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rectangle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: "(75:2) <Section {...rectangleCoordinates} {padding}>",
    ctx: ctx2
  });
  return block;
}
function create_default_slot_22(ctx2) {
  let label_1;
  let t2;
  let current;
  label_1 = new Label_default({
    props: {
      x: 0,
      y: 0.5,
      text: (
        /*label*/
        ctx2[27]
      ),
      anchorPoint: "l",
      fontFamily: (
        /*labelFont*/
        ctx2[10]
      ),
      fontSize: (
        /*labelFontSize*/
        ctx2[11]
      ),
      fontWeight: (
        /*labelFontWeight*/
        ctx2[12]
      ),
      opacity: (
        /*labelOpacity*/
        ctx2[13]
      ),
      fill: (
        /*labelColor*/
        ctx2[14]
      ),
      clip: (
        /*clip*/
        ctx2[15]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(label_1.$$.fragment);
      t2 = space();
    },
    m: function mount(target, anchor) {
      mount_component(label_1, target, anchor);
      insert_dev(target, t2, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const label_1_changes = {};
      if (dirty & /*labels*/
      128)
        label_1_changes.text = /*label*/
        ctx3[27];
      if (dirty & /*labelFont*/
      1024)
        label_1_changes.fontFamily = /*labelFont*/
        ctx3[10];
      if (dirty & /*labelFontSize*/
      2048)
        label_1_changes.fontSize = /*labelFontSize*/
        ctx3[11];
      if (dirty & /*labelFontWeight*/
      4096)
        label_1_changes.fontWeight = /*labelFontWeight*/
        ctx3[12];
      if (dirty & /*labelOpacity*/
      8192)
        label_1_changes.opacity = /*labelOpacity*/
        ctx3[13];
      if (dirty & /*labelColor*/
      16384)
        label_1_changes.fill = /*labelColor*/
        ctx3[14];
      if (dirty & /*clip*/
      32768)
        label_1_changes.clip = /*clip*/
        ctx3[15];
      label_1.$set(label_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
      destroy_component(label_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(91:6) <Section {...cells[i]}>",
    ctx: ctx2
  });
  return block;
}
function create_each_block4(ctx2) {
  let section;
  let current;
  const section_spread_levels = [
    /*cells*/
    ctx2[26][
      /*i*/
      ctx2[29]
    ]
  ];
  let section_props = {
    $$slots: { default: [create_default_slot_22] },
    $$scope: { ctx: ctx2 }
  };
  for (let i2 = 0; i2 < section_spread_levels.length; i2 += 1) {
    section_props = assign(section_props, section_spread_levels[i2]);
  }
  section = new Section_default({ props: section_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(section.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      const section_changes = dirty & /*cells*/
      67108864 ? get_spread_update(section_spread_levels, [get_spread_object(
        /*cells*/
        ctx3[26][
          /*i*/
          ctx3[29]
        ]
      )]) : {};
      if (dirty & /*$$scope, labels, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip*/
      16841856) {
        section_changes.$$scope = { dirty, ctx: ctx3 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(89:4) {#each labels as label, i}",
    ctx: ctx2
  });
  return block;
}
function create_default_slot_13(ctx2) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*labels*/
    ctx2[7]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block4(get_each_context4(ctx2, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (dirty & /*cells, labels, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip*/
      67173504) {
        each_value = ensure_array_like_dev(
          /*labels*/
          ctx3[7]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context4(ctx3, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(80:2) <Grid     x1={xDivider}     y1={yDivider}     {padding}     numberOfCells={labels.length}     columns={1}     let:cells   >",
    ctx: ctx2
  });
  return block;
}
function create_default_slot6(ctx2) {
  let t02;
  let section;
  let t12;
  let grid;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx2[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx2,
    /*$$scope*/
    ctx2[24],
    null
  );
  const section_spread_levels = [
    /*rectangleCoordinates*/
    ctx2[19],
    { padding: (
      /*padding*/
      ctx2[6]
    ) }
  ];
  let section_props = {
    $$slots: { default: [create_default_slot_32] },
    $$scope: { ctx: ctx2 }
  };
  for (let i2 = 0; i2 < section_spread_levels.length; i2 += 1) {
    section_props = assign(section_props, section_spread_levels[i2]);
  }
  section = new Section_default({ props: section_props, $$inline: true });
  grid = new Grid_default({
    props: {
      x1: (
        /*xDivider*/
        ctx2[4]
      ),
      y1: (
        /*yDivider*/
        ctx2[5]
      ),
      padding: (
        /*padding*/
        ctx2[6]
      ),
      numberOfCells: (
        /*labels*/
        ctx2[7].length
      ),
      columns: 1,
      $$slots: {
        default: [
          create_default_slot_13,
          ({ cells }) => ({ 26: cells }),
          ({ cells }) => cells ? 67108864 : 0
        ]
      },
      $$scope: { ctx: ctx2 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
      t02 = space();
      create_component(section.$$.fragment);
      t12 = space();
      create_component(grid.$$.fragment);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_dev(target, t02, anchor);
      mount_component(section, target, anchor);
      insert_dev(target, t12, anchor);
      mount_component(grid, target, anchor);
      current = true;
    },
    p: function update(ctx3, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx3,
            /*$$scope*/
            ctx3[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx3[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx3[24],
              dirty,
              null
            ),
            null
          );
        }
      }
      const section_changes = dirty & /*rectangleCoordinates, padding*/
      524352 ? get_spread_update(section_spread_levels, [
        dirty & /*rectangleCoordinates*/
        524288 && get_spread_object(
          /*rectangleCoordinates*/
          ctx3[19]
        ),
        dirty & /*padding*/
        64 && { padding: (
          /*padding*/
          ctx3[6]
        ) }
      ]) : {};
      if (dirty & /*$$scope, stroke, strokeWidth, clip*/
      16810752) {
        section_changes.$$scope = { dirty, ctx: ctx3 };
      }
      section.$set(section_changes);
      const grid_changes = {};
      if (dirty & /*xDivider*/
      16)
        grid_changes.x1 = /*xDivider*/
        ctx3[4];
      if (dirty & /*yDivider*/
      32)
        grid_changes.y1 = /*yDivider*/
        ctx3[5];
      if (dirty & /*padding*/
      64)
        grid_changes.padding = /*padding*/
        ctx3[6];
      if (dirty & /*labels*/
      128)
        grid_changes.numberOfCells = /*labels*/
        ctx3[7].length;
      if (dirty & /*$$scope, labels, cells, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip*/
      83950720) {
        grid_changes.$$scope = { dirty, ctx: ctx3 };
      }
      grid.$set(grid_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(section.$$.fragment, local);
      transition_in(grid.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(section.$$.fragment, local);
      transition_out(grid.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t02);
        detach_dev(t12);
      }
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(section, detaching);
      destroy_component(grid, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(70:0) <Section {x1} {x2} {y1} {y2} {backgroundColor}>",
    ctx: ctx2
  });
  return block;
}
function create_fragment30(ctx2) {
  let gradient;
  let t2;
  let section;
  let current;
  gradient = new Gradient_default({
    props: {
      gradientId: (
        /*gradientId*/
        ctx2[20]
      ),
      fills: (
        /*fills*/
        ctx2[18]
      ),
      opacities: (
        /*opacities*/
        ctx2[17]
      )
    },
    $$inline: true
  });
  section = new Section_default({
    props: {
      x1: (
        /*x1*/
        ctx2[0]
      ),
      x2: (
        /*x2*/
        ctx2[1]
      ),
      y1: (
        /*y1*/
        ctx2[2]
      ),
      y2: (
        /*y2*/
        ctx2[3]
      ),
      backgroundColor: (
        /*backgroundColor*/
        ctx2[16]
      ),
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx: ctx2 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(gradient.$$.fragment);
      t2 = space();
      create_component(section.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error_16("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(gradient, target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(section, target, anchor);
      current = true;
    },
    p: function update(ctx3, [dirty]) {
      const gradient_changes = {};
      if (dirty & /*fills*/
      262144)
        gradient_changes.fills = /*fills*/
        ctx3[18];
      if (dirty & /*opacities*/
      131072)
        gradient_changes.opacities = /*opacities*/
        ctx3[17];
      gradient.$set(gradient_changes);
      const section_changes = {};
      if (dirty & /*x1*/
      1)
        section_changes.x1 = /*x1*/
        ctx3[0];
      if (dirty & /*x2*/
      2)
        section_changes.x2 = /*x2*/
        ctx3[1];
      if (dirty & /*y1*/
      4)
        section_changes.y1 = /*y1*/
        ctx3[2];
      if (dirty & /*y2*/
      8)
        section_changes.y2 = /*y2*/
        ctx3[3];
      if (dirty & /*backgroundColor*/
      65536)
        section_changes.backgroundColor = /*backgroundColor*/
        ctx3[16];
      if (dirty & /*$$scope, xDivider, yDivider, padding, labels, labelFont, labelFontSize, labelFontWeight, labelOpacity, labelColor, clip, rectangleCoordinates, stroke, strokeWidth*/
      17367024) {
        section_changes.$$scope = { dirty, ctx: ctx3 };
      }
      section.$set(section_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(gradient.$$.fragment, local);
      transition_in(section.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(gradient.$$.fragment, local);
      transition_out(section.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t2);
      }
      destroy_component(gradient, detaching);
      destroy_component(section, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx: ctx2
  });
  return block;
}
var idCounter5 = 0;
function getId7() {
  return "gradient" + idCounter5++;
}
function instance30($$self, $$props, $$invalidate) {
  let rectangleCoordinates;
  let fills;
  let opacities;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GradientLegend", slots, ["default"]);
  let { x1 } = $$props;
  let { x2: x23 } = $$props;
  let { y1 } = $$props;
  let { y2: y23 } = $$props;
  let { xDivider = 0.3 } = $$props;
  let { yDivider = 0.2 } = $$props;
  let { padding = 1 } = $$props;
  let { labels } = $$props;
  let { fill } = $$props;
  let { opacity = 1 } = $$props;
  let { stroke = "none" } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { labelFont = "Helvetica" } = $$props;
  let { labelFontSize = 10 } = $$props;
  let { labelFontWeight = "normal" } = $$props;
  let { labelOpacity = 1 } = $$props;
  let { labelColor = "black" } = $$props;
  let { clip = "outer" } = $$props;
  let { backgroundColor = void 0 } = $$props;
  const { renderer } = getContext("graphic");
  if (renderer !== "svg") {
    throw new Error("GradientLegend only works with svg (for now)");
  }
  const gradientId = getId7();
  $$self.$$.on_mount.push(function() {
    if (x1 === void 0 && !("x1" in $$props || $$self.$$.bound[$$self.$$.props["x1"]])) {
      console.warn("<GradientLegend> was created without expected prop 'x1'");
    }
    if (x23 === void 0 && !("x2" in $$props || $$self.$$.bound[$$self.$$.props["x2"]])) {
      console.warn("<GradientLegend> was created without expected prop 'x2'");
    }
    if (y1 === void 0 && !("y1" in $$props || $$self.$$.bound[$$self.$$.props["y1"]])) {
      console.warn("<GradientLegend> was created without expected prop 'y1'");
    }
    if (y23 === void 0 && !("y2" in $$props || $$self.$$.bound[$$self.$$.props["y2"]])) {
      console.warn("<GradientLegend> was created without expected prop 'y2'");
    }
    if (labels === void 0 && !("labels" in $$props || $$self.$$.bound[$$self.$$.props["labels"]])) {
      console.warn("<GradientLegend> was created without expected prop 'labels'");
    }
    if (fill === void 0 && !("fill" in $$props || $$self.$$.bound[$$self.$$.props["fill"]])) {
      console.warn("<GradientLegend> was created without expected prop 'fill'");
    }
  });
  const writable_props = [
    "x1",
    "x2",
    "y1",
    "y2",
    "xDivider",
    "yDivider",
    "padding",
    "labels",
    "fill",
    "opacity",
    "stroke",
    "strokeWidth",
    "labelFont",
    "labelFontSize",
    "labelFontWeight",
    "labelOpacity",
    "labelColor",
    "clip",
    "backgroundColor"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GradientLegend> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(0, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(1, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(2, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(3, y23 = $$props2.y2);
    if ("xDivider" in $$props2)
      $$invalidate(4, xDivider = $$props2.xDivider);
    if ("yDivider" in $$props2)
      $$invalidate(5, yDivider = $$props2.yDivider);
    if ("padding" in $$props2)
      $$invalidate(6, padding = $$props2.padding);
    if ("labels" in $$props2)
      $$invalidate(7, labels = $$props2.labels);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("opacity" in $$props2)
      $$invalidate(22, opacity = $$props2.opacity);
    if ("stroke" in $$props2)
      $$invalidate(8, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(9, strokeWidth = $$props2.strokeWidth);
    if ("labelFont" in $$props2)
      $$invalidate(10, labelFont = $$props2.labelFont);
    if ("labelFontSize" in $$props2)
      $$invalidate(11, labelFontSize = $$props2.labelFontSize);
    if ("labelFontWeight" in $$props2)
      $$invalidate(12, labelFontWeight = $$props2.labelFontWeight);
    if ("labelOpacity" in $$props2)
      $$invalidate(13, labelOpacity = $$props2.labelOpacity);
    if ("labelColor" in $$props2)
      $$invalidate(14, labelColor = $$props2.labelColor);
    if ("clip" in $$props2)
      $$invalidate(15, clip = $$props2.clip);
    if ("backgroundColor" in $$props2)
      $$invalidate(16, backgroundColor = $$props2.backgroundColor);
    if ("$$scope" in $$props2)
      $$invalidate(24, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    idCounter: idCounter5,
    getId: getId7,
    getContext,
    Section: Section_default,
    Grid: Grid_default,
    Rectangle: Rectangle_default,
    Label: Label_default,
    Gradient: Gradient_default,
    parseAesthetic,
    getRectangleCoordinates,
    x1,
    x2: x23,
    y1,
    y2: y23,
    xDivider,
    yDivider,
    padding,
    labels,
    fill,
    opacity,
    stroke,
    strokeWidth,
    labelFont,
    labelFontSize,
    labelFontWeight,
    labelOpacity,
    labelColor,
    clip,
    backgroundColor,
    renderer,
    gradientId,
    opacities,
    fills,
    rectangleCoordinates
  });
  $$self.$inject_state = ($$props2) => {
    if ("x1" in $$props2)
      $$invalidate(0, x1 = $$props2.x1);
    if ("x2" in $$props2)
      $$invalidate(1, x23 = $$props2.x2);
    if ("y1" in $$props2)
      $$invalidate(2, y1 = $$props2.y1);
    if ("y2" in $$props2)
      $$invalidate(3, y23 = $$props2.y2);
    if ("xDivider" in $$props2)
      $$invalidate(4, xDivider = $$props2.xDivider);
    if ("yDivider" in $$props2)
      $$invalidate(5, yDivider = $$props2.yDivider);
    if ("padding" in $$props2)
      $$invalidate(6, padding = $$props2.padding);
    if ("labels" in $$props2)
      $$invalidate(7, labels = $$props2.labels);
    if ("fill" in $$props2)
      $$invalidate(21, fill = $$props2.fill);
    if ("opacity" in $$props2)
      $$invalidate(22, opacity = $$props2.opacity);
    if ("stroke" in $$props2)
      $$invalidate(8, stroke = $$props2.stroke);
    if ("strokeWidth" in $$props2)
      $$invalidate(9, strokeWidth = $$props2.strokeWidth);
    if ("labelFont" in $$props2)
      $$invalidate(10, labelFont = $$props2.labelFont);
    if ("labelFontSize" in $$props2)
      $$invalidate(11, labelFontSize = $$props2.labelFontSize);
    if ("labelFontWeight" in $$props2)
      $$invalidate(12, labelFontWeight = $$props2.labelFontWeight);
    if ("labelOpacity" in $$props2)
      $$invalidate(13, labelOpacity = $$props2.labelOpacity);
    if ("labelColor" in $$props2)
      $$invalidate(14, labelColor = $$props2.labelColor);
    if ("clip" in $$props2)
      $$invalidate(15, clip = $$props2.clip);
    if ("backgroundColor" in $$props2)
      $$invalidate(16, backgroundColor = $$props2.backgroundColor);
    if ("opacities" in $$props2)
      $$invalidate(17, opacities = $$props2.opacities);
    if ("fills" in $$props2)
      $$invalidate(18, fills = $$props2.fills);
    if ("rectangleCoordinates" in $$props2)
      $$invalidate(19, rectangleCoordinates = $$props2.rectangleCoordinates);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*xDivider, yDivider, labels*/
    176) {
      $:
        $$invalidate(19, rectangleCoordinates = getRectangleCoordinates(xDivider, yDivider, labels.length));
    }
    if ($$self.$$.dirty & /*fill, labels*/
    2097280) {
      $:
        $$invalidate(18, fills = parseAesthetic(fill, labels.length));
    }
    if ($$self.$$.dirty & /*opacity, labels*/
    4194432) {
      $:
        $$invalidate(17, opacities = parseAesthetic(opacity, labels.length));
    }
    if ($$self.$$.dirty & /*fills, opacities*/
    393216) {
      $: {
        if (fills.length !== opacities.length) {
          throw new Error("Aesthetics and labels must all be of same length");
        }
      }
    }
  };
  return [
    x1,
    x23,
    y1,
    y23,
    xDivider,
    yDivider,
    padding,
    labels,
    stroke,
    strokeWidth,
    labelFont,
    labelFontSize,
    labelFontWeight,
    labelOpacity,
    labelColor,
    clip,
    backgroundColor,
    opacities,
    fills,
    rectangleCoordinates,
    gradientId,
    fill,
    opacity,
    slots,
    $$scope
  ];
}
var GradientLegend = class extends SvelteComponentDev {
  constructor(options2) {
    super(options2);
    init(this, options2, instance30, create_fragment30, safe_not_equal, {
      x1: 0,
      x2: 1,
      y1: 2,
      y2: 3,
      xDivider: 4,
      yDivider: 5,
      padding: 6,
      labels: 7,
      fill: 21,
      opacity: 22,
      stroke: 8,
      strokeWidth: 9,
      labelFont: 10,
      labelFontSize: 11,
      labelFontWeight: 12,
      labelOpacity: 13,
      labelColor: 14,
      clip: 15,
      backgroundColor: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GradientLegend",
      options: options2,
      id: create_fragment30.name
    });
  }
  get x1() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x1(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get x2() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set x2(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y1() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y1(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get y2() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set y2(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xDivider() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xDivider(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get yDivider() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set yDivider(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labels() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labels(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeWidth() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeWidth(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFont() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFont(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontSize() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontSize(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFontWeight() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFontWeight(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelOpacity() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelOpacity(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelColor() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelColor(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clip() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clip(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error_16("<GradientLegend>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error_16("<GradientLegend>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GradientLegend_default = GradientLegend;

// node_modules/@snlab/florence/src/helpers/createPanHandler.js
function createPanHandler(zoomIdentity, options2) {
  const dimension = options2.dimension || "both";
  const setZoomIdentity = options2.setZoomIdentity;
  const setBlockReindexing = options2.setBlockReindexing || emptyFunc;
  let panning = false;
  let previousCoordinates;
  const start = function(event) {
    setBlockReindexing(true);
    panning = true;
    previousCoordinates = event.screenCoordinates;
  };
  const handler2 = function(event) {
    if (!panning)
      return;
    const currentCoordinates = event.screenCoordinates;
    const delta = calculateDelta(previousCoordinates, currentCoordinates);
    previousCoordinates = currentCoordinates;
    const extentX = options2.extentX || [-Infinity, Infinity];
    const extentY = options2.extentY || [-Infinity, Infinity];
    const tempX = zoomIdentity.x - delta.x;
    const tempY = zoomIdentity.y - delta.y;
    if (tempX <= extentX[1] && tempX >= extentX[0]) {
      zoomIdentity.x -= delta.x;
    }
    if (tempY <= extentY[1] && tempY >= extentY[0]) {
      zoomIdentity.y -= delta.y;
    }
    if (dimension === "x")
      zoomIdentity.y = 0;
    if (dimension === "y")
      zoomIdentity.x = 0;
    setZoomIdentity(zoomIdentity);
  };
  const end = function(event) {
    setBlockReindexing(false);
    panning = false;
  };
  const reset = function() {
    zoomIdentity.x = 0;
    zoomIdentity.y = 0;
    setZoomIdentity(zoomIdentity);
  };
  return {
    handlers: {
      onMousedown: start,
      onMousemove: handler2,
      onMouseup: end
    },
    reset
  };
}
function calculateDelta(previousCoordinates, currentCoordinates) {
  return {
    x: previousCoordinates.x - currentCoordinates.x,
    y: previousCoordinates.y - currentCoordinates.y
  };
}
var emptyFunc = () => {
};

// node_modules/@snlab/florence/src/helpers/createZoomHandler.js
function createZoomHandler(zoomIdentity, {
  setZoomIdentity,
  minZoom = 0.5,
  maxZoom = 3,
  step = 1,
  dimension = "both"
}) {
  const zoom = function(event) {
    const zoomPoint = getZoompoint(event);
    const zoomFactor = event.delta * step;
    const previousScaleX = zoomIdentity.kx;
    const previousScaleY = zoomIdentity.ky;
    const newScaleX = previousScaleX - zoomFactor;
    const newScaleY = previousScaleY - zoomFactor;
    const newZoomScale = Math.max(newScaleX, newScaleY);
    if (withinRange(newZoomScale, minZoom, maxZoom)) {
      if (dimension === "both" || dimension === "x") {
        zoomIdentity.kx = newScaleX;
        const offset = getOffset(previousScaleX, newScaleX, zoomPoint.x, zoomIdentity.x);
        zoomIdentity.x = offset;
      }
      if (dimension === "both" || dimension === "y") {
        zoomIdentity.ky = newScaleY;
        const offset = getOffset(previousScaleY, newScaleY, zoomPoint.y, zoomIdentity.y);
        zoomIdentity.y = offset;
      }
      setZoomIdentity(zoomIdentity);
    }
  };
  const reset = function() {
    zoomIdentity.x = 0;
    zoomIdentity.y = 0;
    zoomIdentity.kx = 1;
    zoomIdentity.ky = 1;
    setZoomIdentity(zoomIdentity);
  };
  return {
    handlers: {
      onWheel: zoom,
      onPinch: zoom
    },
    reset
  };
}
function getZoompoint(event) {
  if (event.type === "wheel")
    return event.screenCoordinates;
  if (event.type === "pinch")
    return event.screenCenter;
}
function getOffset(previousK, newK, zoomPoint, previousOffset, extent) {
  const unTransformedZoompoint = (zoomPoint - previousOffset) / previousK;
  const scaleChange = newK - previousK;
  const deltaOffset = -(unTransformedZoompoint * scaleChange);
  return previousOffset + deltaOffset;
}
function withinRange(value, min2, max2) {
  return min2 <= value && value <= max2;
}

// node_modules/@snlab/florence/src/helpers/labels.js
function getClassLabels(thresholdColorScale, format2 = (x3) => x3) {
  const domain = thresholdColorScale.domain();
  const labels = [`< ${format2(domain[0])}`];
  for (let i2 = 0; i2 < domain.length - 1; i2++) {
    labels.push(`${format2(domain[i2])} - ${format2(domain[i2 + 1])}`);
  }
  labels.push(` ${format2(domain[domain.length - 1])}`);
  return labels;
}
function interpolateLabels(linearColorScale, numberOfLabels) {
}
export {
  Area_default as Area,
  AreaLayer_default as AreaLayer,
  DiscreteLegend_default as DiscreteLegend,
  FuncLine_default as FuncLine,
  Glyph_default as Glyph,
  GradientLegend_default as GradientLegend,
  Graphic_default as Graphic,
  Grid_default as Grid,
  Label_default as Label,
  LabelLayer_default as LabelLayer,
  Line_default as Line,
  LineLayer_default as LineLayer,
  Point_default as Point,
  PointLayer_default as PointLayer,
  Polygon_default as Polygon,
  PolygonLayer_default as PolygonLayer,
  Rectangle_default as Rectangle,
  RectangleLayer_default as RectangleLayer,
  Section_default as Section,
  SymbolLayer_default as SymbolLayer,
  Symbol_default as Symbol_,
  XAxis_default as XAxis,
  XGridLines_default as XGridLines,
  YAxis_default as YAxis,
  YGridLines_default as YGridLines,
  cartesian,
  createPanHandler,
  createZoomHandler,
  fitScales,
  getClassLabels,
  interpolateLabels,
  polar,
  x22 as x2,
  x2s,
  y22 as y2,
  y2s
};
//# sourceMappingURL=@snlab_florence.js.map
