{
  "version": 3,
  "sources": ["../../@snlab/florence-datacontainer/dist/florence-datacontainer.umd.js"],
  "sourcesContent": ["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.DataContainer = factory());\n}(this, (function () { 'use strict';\n\n  function isColumnOriented (data) {\n    if (data.constructor === Object) {\n      const columns = Object.keys(data).map(key => data[key]);\n      return columns.every(column => column.constructor === Array)\n    }\n\n    return false\n  }\n\n  function isRowOriented (data) {\n    if (data.constructor === Array) {\n      return data.every(row => row.constructor === Object)\n    }\n\n    return false\n  }\n\n  function isGeoJSON (data) {\n    const hasCorrectType = data.type === 'FeatureCollection';\n    const hasCorrectFeatures = data.features && data.features.length > 0;\n\n    return hasCorrectType && hasCorrectFeatures\n  }\n\n  function checkFormatColumnData (data) {\n    checkFormat(data, { internal: false });\n  }\n\n  function checkFormatInternal (data) {\n    checkFormat(data, { internal: true });\n  }\n\n  function checkFormat (data, { internal }) {\n    let dataLength = null;\n    const columnNameChecker = internal\n      ? checkInternalDataColumnName\n      : checkRegularColumnName;\n\n    for (const columnName in data) {\n      columnNameChecker(columnName);\n      const column = data[columnName];\n\n      dataLength = dataLength || column.length;\n\n      if (internal === false && dataLength === 0) {\n        throw new Error('Invalid data: columns cannot be empty')\n      }\n\n      if (dataLength !== column.length) {\n        throw new Error('Invalid data: columns must be of same length')\n      }\n    }\n  }\n\n  function checkRegularColumnName (columnName) {\n    if (columnName.match(forbiddenChars)) {\n      throw new Error(`Invalid column name '${columnName}': '$' is not allowed in column names`)\n    }\n  }\n\n  const forbiddenChars = /[/$]/;\n\n  function checkInternalDataColumnName (columnName) {\n    if (!['$key', '$geometry', '$grouped'].includes(columnName)) {\n      checkRegularColumnName(columnName);\n    }\n  }\n\n  function convertRowToColumnData (data) {\n    checkIfDataIsEmpty(data);\n    let columnData = initColumnData(data);\n\n    for (let row of data) {\n      for (let key in row) {\n        columnData[key].push(row[key]);\n      }\n    }\n\n    return columnData\n  }\n\n  function initColumnData (data) {\n    let firstRow = data[0];\n    let columnKeys = Object.keys(firstRow);\n    let columnData = {};\n\n    for (let key of columnKeys) {\n      columnData[key] = [];\n    }\n\n    return columnData\n  }\n\n  function checkIfDataIsEmpty (data) {\n    if (data.length === 0) {\n      throw new Error('Received empty Array while trying to load row-oriented data. This is not allowed.')\n    }\n  }\n\n  function parseGeoJSON (geojsonData) {\n    const geometryData = [];\n    const data = {};\n\n    const features = geojsonData.features;\n    const firstFeature = features[0];\n\n    if ('properties' in firstFeature) {\n      for (const columnName in firstFeature.properties) {\n        data[columnName] = [];\n      }\n    }\n\n    for (let i = 0; i < features.length; i++) {\n      const { geometry, properties } = features[i];\n      geometryData.push(geometry);\n\n      for (const columnName in properties) {\n        data[columnName].push(properties[columnName]);\n      }\n    }\n\n    checkFormatColumnData(data);\n\n    data.$geometry = geometryData;\n\n    return data\n  }\n\n  const methods = {\n    _setColumnData (data, options) {\n      if (options.validate === false) {\n        checkFormatInternal(data);\n      } else {\n        checkFormatColumnData(data);\n      }\n\n      this._storeData(data, options);\n    },\n\n    _setRowData (rowData, options) {\n      const columnData = convertRowToColumnData(rowData);\n      this._setColumnData(columnData, options);\n    },\n\n    _setGeoJSON (geojsonData, options) {\n      const data = parseGeoJSON(geojsonData);\n      this._storeData(data, options);\n    },\n\n    _setGroup (group, options) {\n      const data = group.data;\n      checkFormatInternal(data);\n      this._storeData(data, options);\n    },\n\n    _storeData (data, options) {\n      this._data = data;\n\n      this._setupKeyColumn();\n\n      if (options.validate === true) {\n        this.validateAllColumns();\n      }\n    }\n  };\n\n  function dataLoadingMixin (targetClass) {\n    Object.assign(targetClass.prototype, methods);\n  }\n\n  function generateKeyColumn (length) {\n    return new Array(length).fill(0).map((_, i) => i.toString())\n  }\n\n  function validateKeyColumn (keyColumn, requiredLength) {\n    if (keyColumn.length !== requiredLength) {\n      throw new Error('Key column must be of same length as rest of the data')\n    }\n\n    ensureUnique(keyColumn);\n  }\n\n  function ensureUnique (keyColumn) {\n    if (keyColumn.length !== new Set(keyColumn).size) {\n      throw new Error('Keys must be unique')\n    }\n  }\n\n  function incrementKey (keyColumn) {\n    let max = -Infinity;\n\n    for (let i = 0; i < keyColumn.length; i++) {\n      const keyInt = +keyColumn[i];\n      max = keyInt > max ? keyInt : max;\n    }\n\n    max++;\n\n    return max.toString()\n  }\n\n  function getDataLength (data) {\n    const keys = Object.keys(data);\n\n    const firstKey = keys[0] === '$key'\n      ? keys[1]\n      : keys[0];\n\n    const firstColumn = data[firstKey];\n    return firstColumn.length\n  }\n\n  const methods$1 = {\n    keys () {\n      return this.column('$key')\n    },\n\n    setKey (columnName) {\n      this._keyColumn = columnName;\n      this._keyToRowIndex.clear();\n\n      const column = this.column(columnName);\n      const length = getDataLength(this._data);\n      validateKeyColumn(column, length);\n\n      this._setKeyColumn(column);\n    },\n\n    resetKey () {\n      this._keyToRowIndex.clear();\n      this._keyColumn = null;\n      delete this._data.$key;\n\n      this._setupKeyColumn();\n    },\n\n    _setupKeyColumn () {\n      const length = getDataLength(this._data);\n\n      if ('$key' in this._data) {\n        validateKeyColumn(this._data.$key, length);\n        this._constructKeyToRowIndex();\n      } else {\n        const keyColumn = generateKeyColumn(length);\n        this._setKeyColumn(keyColumn);\n      }\n    },\n\n    _setKeyColumn (keyColumn) {\n      this._data.$key = keyColumn;\n      this._constructKeyToRowIndex();\n    },\n\n    _constructKeyToRowIndex () {\n      const length = getDataLength(this._data);\n\n      for (let i = 0; i < length; i++) {\n        const key = this._data.$key[i];\n        this._keyToRowIndex.set(key, i);\n      }\n    }\n  };\n\n  function keyMixin (targetClass) {\n    Object.assign(targetClass.prototype, methods$1);\n  }\n\n  function filter (data, filterFunction) {\n    const length = getDataLength(data);\n    const newData = {};\n    for (const colName in data) { newData[colName] = []; }\n\n    for (let i = 0; i < length; i++) {\n      const row = {};\n      for (const colName in data) { row[colName] = data[colName][i]; }\n\n      if (filterFunction(row, i) === true) {\n        for (const colName in row) { newData[colName].push(row[colName]); }\n      }\n    }\n\n    return newData\n  }\n\n  function select (data, selection) {\n    if (selection.constructor === String) {\n      selection = [selection];\n    }\n\n    if (selection.constructor === Array) {\n      validateSelectionInstructions(data, selection);\n\n      const newData = {};\n\n      for (const columnName of selection) {\n        newData[columnName] = data[columnName];\n      }\n\n      return newData\n    } else {\n      throw new Error('select can only be used with a string or array of strings')\n    }\n  }\n\n  function validateSelectionInstructions (data, selection) {\n    for (const columnName of selection) {\n      if (!(columnName in data)) {\n        throw new Error(`Column '${columnName}' not found`)\n      }\n    }\n  }\n\n  // This function comes from Turf's wonderful geospatial lib\n  // We only need this single function and importing it from @turf/meta\n  // doesn't work well for in-browser compilation\n  // https://github.com/Turfjs/turf\n\n  // The MIT License (MIT)\n\n  // Copyright (c) 2019 Morgan Herlocker\n\n  // Permission is hereby granted, free of charge, to any person obtaining a copy of\n  // this software and associated documentation files (the \"Software\"), to deal in\n  // the Software without restriction, including without limitation the rights to\n  // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n  // the Software, and to permit persons to whom the Software is furnished to do so,\n  // subject to the following conditions:\n\n  // The above copyright notice and this permission notice shall be included in all\n  // copies or substantial portions of the Software.\n\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n  // FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n  // COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n  // IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n  function coordEach (geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return\n    var j; var k; var l; var geometry; var stopG; var coords;\n    var geometryMaybeCollection;\n    var wrapShrink = 0;\n    var coordIndex = 0;\n    var isGeometryCollection;\n    var type = geojson.type;\n    var isFeatureCollection = type === 'FeatureCollection';\n    var isFeature = type === 'Feature';\n    var stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n      geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry\n        : (isFeature ? geojson.geometry : geojson));\n      isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n        var multiFeatureIndex = 0;\n        var geometryIndex = 0;\n        geometry = isGeometryCollection\n          ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n        // Handles null Geometry -- Skips this geometry\n        if (geometry === null) continue\n        coords = geometry.coordinates;\n        var geomType = geometry.type;\n\n        wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n        switch (geomType) {\n          case null:\n            break\n          case 'Point':\n            if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false\n            coordIndex++;\n            multiFeatureIndex++;\n            break\n          case 'LineString':\n          case 'MultiPoint':\n            for (j = 0; j < coords.length; j++) {\n              if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false\n              coordIndex++;\n              if (geomType === 'MultiPoint') multiFeatureIndex++;\n            }\n            if (geomType === 'LineString') multiFeatureIndex++;\n            break\n          case 'Polygon':\n          case 'MultiLineString':\n            for (j = 0; j < coords.length; j++) {\n              for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false\n                coordIndex++;\n              }\n              if (geomType === 'MultiLineString') multiFeatureIndex++;\n              if (geomType === 'Polygon') geometryIndex++;\n            }\n            if (geomType === 'Polygon') multiFeatureIndex++;\n            break\n          case 'MultiPolygon':\n            for (j = 0; j < coords.length; j++) {\n              geometryIndex = 0;\n              for (k = 0; k < coords[j].length; k++) {\n                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                  if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false\n                  coordIndex++;\n                }\n                geometryIndex++;\n              }\n              multiFeatureIndex++;\n            }\n            break\n          case 'GeometryCollection':\n            for (j = 0; j < geometry.geometries.length; j++) { if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false }\n            break\n          default:\n            throw new Error('Unknown Geometry Type')\n        }\n      }\n    }\n  }\n\n  function calculateBBoxGeometries (geometries) {\n    let bbox = { x: [Infinity, -Infinity], y: [Infinity, -Infinity] };\n\n    for (let i = 0; i < geometries.length; i++) {\n      bbox = updateBBox(bbox, geometries[i]);\n    }\n\n    return bbox\n  }\n\n  function updateBBox ({ x, y }, geometry) {\n    coordEach(geometry, coord => {\n      x[0] = Math.min(coord[0], x[0]);\n      x[1] = Math.max(coord[0], x[1]);\n      y[0] = Math.min(coord[1], y[0]);\n      y[1] = Math.max(coord[1], y[1]);\n    });\n\n    return { x, y }\n  }\n\n  function isInvalid (value) {\n    if (value === undefined || value === null) { return true }\n\n    if (value.constructor === Number) {\n      return !isFinite(value)\n    }\n\n    return false\n  }\n\n  function isDefined (value) {\n    return value !== undefined\n  }\n\n  function isUndefined (value) {\n    return value === undefined\n  }\n\n  function warn (message) {\n    if (typeof process === 'undefined') console.warn(message);\n\n    if (typeof process === 'object' && process.env.NODE_ENV !== 'test') {\n      console.warn(message);\n    }\n  }\n\n  function calculateDomain (column, columnName) {\n    if (columnName === '$grouped') {\n      throw new Error(`Cannot calculate domain of column '${columnName}'.`)\n    }\n\n    if (column.length === 0) {\n      return createEmptyDomain(columnName)\n    }\n\n    const { firstValidValue, nValidValues } = findFirstValidValue(column);\n\n    if (nValidValues === 0) {\n      throw new Error(`Cannot calculate domain of column '${column}'. Column contains only missing values.`)\n    }\n\n    if (nValidValues > 0) {\n      ensureValidDataType(firstValidValue);\n      const type = getDataType(firstValidValue);\n\n      if (columnName === '$geometry') {\n        return calculateBBoxGeometries(column)\n      }\n\n      if (columnName !== '$geometry') {\n        return calculateNonGeometryColumnDomain(column, columnName, nValidValues, firstValidValue, type)\n      }\n    }\n  }\n\n  function createEmptyDomain (columnName) {\n    if (columnName === '$geometry') {\n      return { x: [], y: [] }\n    }\n\n    if (columnName !== '$geometry') {\n      return []\n    }\n  }\n\n  function findFirstValidValue (column) {\n    let firstValidValue;\n    let nValidValues = 0;\n\n    for (let i = 0; i < column.length; i++) {\n      if (!isInvalid(column[i])) {\n        nValidValues++;\n        firstValidValue = firstValidValue || column[i];\n      }\n\n      if (nValidValues > 1) break\n    }\n\n    return { firstValidValue, nValidValues }\n  }\n\n  function calculateNonGeometryColumnDomain (column, columnName, nValidValues, firstValidValue, type) {\n    let domain;\n    const nUniqueValues = calculateNumberOfUniqueValues(column, type);\n\n    if (columnHasOnlyOneUniqueValue(nValidValues, nUniqueValues)) {\n      domain = calculateDomainForColumnWithOneUniqueValue(\n        nValidValues, nUniqueValues, type, firstValidValue, columnName\n      );\n    } else {\n      domain = calculateDomainForRegularColumn(type, column, columnName);\n    }\n\n    return domain\n  }\n\n  function calculateNumberOfUniqueValues (col, type) {\n    const uniqueVals = {};\n\n    if (['quantitative', 'categorical'].includes(type)) {\n      for (let i = 0; i < col.length; i++) {\n        const val = col[i];\n        if (!isInvalid(val)) {\n          uniqueVals[val] = 0;\n        }\n      }\n    }\n\n    if (type === 'temporal') {\n      for (let i = 0; i < col.length; i++) {\n        const val = col[i];\n        if (!isInvalid(val)) {\n          uniqueVals[val.getTime()] = 0;\n        }\n      }\n    }\n\n    if (type === 'interval') {\n      for (let i = 0; i < col.length; i++) {\n        const val = col[i];\n        if (!isInvalid(val)) {\n          const str = JSON.stringify(val);\n          uniqueVals[str] = 0;\n        }\n      }\n    }\n\n    return Object.keys(uniqueVals).length\n  }\n\n  function columnHasOnlyOneUniqueValue (nValidValues, nUniqueValues) {\n    return nValidValues === 1 || nUniqueValues === 1\n  }\n\n  function calculateDomainForColumnWithOneUniqueValue (nValidValues, nUniqueValues, type, firstValidValue, columnName) {\n    const domain = createDomainForSingleValue(type, firstValidValue);\n    const warningText = nValidValues === 1 ? 'valid' : 'unique';\n\n    if (type !== 'categorical') {\n      warn(\n        `Column '${columnName}' contains only 1 ${warningText} value: ${firstValidValue}.\\n` +\n        `Using domain ${JSON.stringify(domain)}`\n      );\n    }\n\n    return domain\n  }\n\n  function calculateDomainForRegularColumn (type, column, columnName) {\n    let domain = initDomain(type);\n\n    for (let i = 0; i < column.length; i++) {\n      const value = column[i];\n\n      if (!isInvalid(value)) {\n        if (getDataType(value) !== type) {\n          throw new Error(`Invalid column ${columnName}: column contains multiple data types`)\n        }\n\n        domain = updateDomain(domain, value, type);\n      }\n    }\n\n    return domain\n  }\n\n  const minUnixTime = new Date(0);\n  const maxUnixTime = new Date('19 January 2038');\n\n  function initDomain (type) {\n    let domain;\n    switch (type) {\n      case 'quantitative': {\n        domain = [Infinity, -Infinity];\n        break\n      }\n      case 'categorical': {\n        domain = [];\n        break\n      }\n      case 'temporal': {\n        domain = [maxUnixTime, minUnixTime];\n        break\n      }\n      case 'interval': {\n        domain = [Infinity, -Infinity];\n        break\n      }\n    }\n\n    return domain\n  }\n\n  function updateDomain (domain, value, type) {\n    if (!['quantitative', 'categorical', 'temporal', 'interval'].includes(type)) {\n      throw new Error(`Cannot set domain for column of type '${type}'`)\n    }\n\n    if (type === 'quantitative') {\n      if (domain[0] >= value) { domain[0] = value; }\n      if (domain[1] <= value) { domain[1] = value; }\n    }\n\n    if (type === 'categorical') {\n      if (!domain.includes(value)) { domain.push(value); }\n    }\n\n    if (type === 'temporal') {\n      const epoch = value.getTime();\n\n      if (domain[0].getTime() >= epoch) { domain[0] = value; }\n      if (domain[1].getTime() <= epoch) { domain[1] = value; }\n    }\n\n    if (type === 'interval') {\n      domain = updateDomain(domain, value[0], 'quantitative');\n      domain = updateDomain(domain, value[1], 'quantitative');\n    }\n\n    return domain\n  }\n\n  function createDomainForSingleValue (type, value) {\n    let domain;\n\n    if (type === 'quantitative') {\n      domain = [value - 1, value + 1];\n    }\n\n    if (type === 'categorical') {\n      domain = [value];\n    }\n\n    if (type === 'temporal') {\n      domain = [getDay(value, -1), getDay(value, 1)];\n    }\n\n    if (type === 'interval') {\n      domain = value.sort((a, b) => a - b);\n    }\n\n    return domain\n  }\n\n  function getDay (date, days) {\n    const dateCopy = new Date(date.getTime());\n    return new Date(dateCopy.setDate(dateCopy.getDate() + days))\n  }\n\n  function getColumnType (column) {\n    const { firstValidValue } = findFirstValidValue(column);\n    return getDataType(firstValidValue)\n  }\n\n  function getDataType (value) {\n    if (isInvalid(value)) return undefined\n\n    if (value.constructor === Number) return 'quantitative'\n    if (value.constructor === String) return 'categorical'\n    if (value.constructor === Date) return 'temporal'\n    if (isInterval(value)) return 'interval'\n    if (isGeometry(value)) return 'geometry'\n    if (value.constructor === DataContainer) return 'grouped'\n\n    return undefined\n  }\n\n  function ensureValidDataType (value) {\n    if (isInvalid(getDataType(value))) {\n      throw new Error('Invalid data')\n    }\n  }\n\n  function isGeometry (value) {\n    return value.constructor === Object && 'type' in value && 'coordinates' in value\n  }\n\n  function isInterval (value) {\n    return value.constructor === Array && value.length === 2 && value.every(entry => entry.constructor === Number)\n  }\n\n  function arrange (data, sortInstructions) {\n    if (sortInstructions.constructor === Object) {\n      return sort(data, sortInstructions)\n    } else if (sortInstructions.constructor === Array) {\n      let newData;\n\n      for (let i = sortInstructions.length - 1; i >= 0; i--) {\n        const instruction = sortInstructions[i];\n\n        newData = sort(\n          newData ? data : newData,\n          instruction\n        );\n      }\n\n      return newData\n    } else {\n      throw new Error('arrange requires a key-value object or array of key-value objects')\n    }\n  }\n\n  const sortFuncs = {\n    quantitative: {\n      // https://beta.observablehq.com/@mbostock/manipulating-flat-arrays\n      ascending: (a, b) => a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN,\n      descending: (a, b) => b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN\n    },\n    categorical: {\n      ascending: (a, b) => {\n        const sorted = [a, b].sort();\n        return sorted[0] === a ? -1 : 1\n      },\n      descending: (a, b) => {\n        const sorted = [a, b].sort();\n        return sorted[0] === a ? 1 : -1\n      }\n    },\n    temporal: {\n      ascending: (a, b) => {\n        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN\n      },\n      descending: (a, b) => {\n        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN\n      }\n    }\n  };\n\n  function sort (data, sortInstructions) {\n    if (Object.keys(sortInstructions).length !== 1) {\n      throw new Error('Only one key-value pair allowed')\n    }\n\n    const variable = Object.keys(sortInstructions)[0];\n    const sortMethod = sortInstructions[variable];\n\n    ensureValidDataType(data[variable][0]);\n    const dataType = getDataType(data[variable][0]);\n\n    let sortFunc;\n    if (sortMethod.constructor === String) {\n      sortFunc = sortFuncs[dataType][sortMethod];\n    }\n    if (sortMethod.constructor === Function) {\n      sortFunc = sortMethod;\n    }\n\n    const column = data[variable];\n\n    const indices = column.map((v, i) => i);\n    const sortedIndices = indices.sort((a, b) => sortFunc(column[a], column[b]));\n\n    const newData = {};\n\n    for (const colName in data) {\n      newData[colName] = reorder(data[colName], sortedIndices);\n    }\n\n    return newData\n  }\n\n  function reorder (column, indices) {\n    return indices.map(i => column[i])\n  }\n\n  function rename (data, renameInstructions) {\n    if (renameInstructions.constructor !== Object) {\n      throw new Error('Rename only accepts an object')\n    }\n\n    const newData = Object.assign({}, data);\n\n    for (const oldName in renameInstructions) {\n      if (oldName in data) {\n        const newName = renameInstructions[oldName];\n        checkRegularColumnName(newName);\n\n        newData[newName] = newData[oldName];\n        delete newData[oldName];\n      } else {\n        warn(`Rename: column '${oldName}' not found`);\n      }\n    }\n\n    return newData\n  }\n\n  function mutate (data, mutateInstructions) {\n    const length = getDataLength(data);\n    const newData = initNewData(data, mutateInstructions);\n\n    for (let i = 0; i < length; i++) {\n      const row = {};\n\n      for (const columnName in data) {\n        row[columnName] = data[columnName][i];\n      }\n\n      for (const columnName in mutateInstructions) {\n        const mutateFunction = mutateInstructions[columnName];\n        newData[columnName][i] = mutateFunction(row, i);\n      }\n    }\n\n    return newData\n  }\n\n  function transmute (data, transmuteInstructions) {\n    const newData = mutate(data, transmuteInstructions);\n\n    for (const columnName in newData) {\n      if (!(columnName in transmuteInstructions)) {\n        delete newData[columnName];\n      }\n    }\n\n    return newData\n  }\n\n  function initNewData (data, mutateInstructions) {\n    const length = getDataLength(data);\n    const newData = Object.assign({}, data);\n\n    const dataColumns = new Set(Object.keys(data));\n    const mutateColumns = new Set(Object.keys(mutateInstructions));\n\n    for (const columnName of mutateColumns) {\n      if (!dataColumns.has(columnName)) {\n        newData[columnName] = new Array(length).fill(undefined);\n      }\n    }\n\n    return newData\n  }\n\n  var aggregations = {\n    count,\n    sum,\n    mean,\n    median,\n    mode,\n    min,\n    max\n  };\n\n  function count (column) {\n    return column.length\n  }\n\n  function sum (column) {\n    let total = 0;\n    for (const value of column) {\n      total += value;\n    }\n\n    return total\n  }\n\n  function mean (column) {\n    return sum(column) / count(column)\n  }\n\n  function median (column) {\n    const asc = column.sort((a, b) => a > b);\n    const len = count(column);\n\n    if (len % 2 === 1) {\n      // Odd\n      return asc[Math.floor(len / 2)]\n    } else {\n      // Even\n      const lower = asc[(len / 2) - 1];\n      const upper = asc[(len / 2)];\n      return (lower + upper) / 2\n    }\n  }\n\n  function mode (column) {\n    const counts = {};\n\n    for (const value of column) {\n      if (value in counts) {\n        counts[value]++;\n      } else {\n        counts[value] = 1;\n      }\n    }\n\n    let winner;\n    let winningVal = 0;\n\n    for (const value in counts) {\n      if (counts[value] > winningVal) {\n        winningVal = counts[value];\n        winner = value;\n      }\n    }\n\n    return winner\n  }\n\n  function min (column) {\n    let winner = Infinity;\n    for (const value of column) {\n      if (value < winner) { winner = value; }\n    }\n    return winner\n  }\n\n  function max (column) {\n    let winner = -Infinity;\n    for (const value of column) {\n      if (value > winner) { winner = value; }\n    }\n    return winner\n  }\n\n  function checkKeyValuePair (obj, allowedKeys) {\n    const keys = Object.keys(obj);\n    if (keys.length !== 1) {\n      throw new Error('Invalid transformation syntax')\n    }\n\n    const key = keys[0];\n\n    if (!allowedKeys.includes(key)) {\n      throw new Error(`Unknown column ${key}`)\n    }\n\n    return key\n  }\n\n  function summarise (data, summariseInstructions) {\n    if (summariseInstructions.constructor !== Object) {\n      throw new Error('summarise must be an object')\n    }\n\n    let newData = initNewData$1(summariseInstructions, data);\n\n    if ('$grouped' in data) {\n      checkSummariseInstructions(summariseInstructions, data);\n\n      for (const columnName in data) {\n        if (columnName !== '$grouped') {\n          newData[columnName] = data[columnName];\n        }\n      }\n\n      for (const group of data.$grouped) {\n        const data = group.data();\n        newData = summariseGroup(data, summariseInstructions, newData);\n      }\n    } else {\n      newData = summariseGroup(data, summariseInstructions, newData);\n    }\n    return newData\n  }\n\n  function initNewData$1 (summariseInstructions, data) {\n    const newData = {};\n    for (const newCol in summariseInstructions) { newData[newCol] = []; }\n    if (data && '$grouped' in data) {\n      for (const col in data) {\n        if (col !== '$grouped') {\n          newData[col] = [];\n        }\n      }\n    }\n    return newData\n  }\n\n  function summariseGroup (data, summariseInstructions, newData) {\n    for (const newColName in summariseInstructions) {\n      const instruction = summariseInstructions[newColName];\n\n      if (instruction.constructor === Object) {\n        const column = checkKeyValuePair(instruction, Object.keys(data));\n        const aggregation = instruction[column];\n\n        if (aggregation.constructor === String) {\n          if (!(aggregation in aggregations)) {\n            throw new Error(`Unkown summaryMethod: '${aggregation}'.`)\n          }\n\n          newData[newColName].push(aggregations[aggregation](data[column]));\n        } else if (aggregation.constructor === Function) {\n          newData[newColName].push(aggregation(data[column]));\n        } else {\n          throw new Error(`Invalid summaryMethod: '${aggregation}'. Must be String or Function`)\n        }\n      }\n    }\n\n    return newData\n  }\n\n  function checkSummariseInstructions (summariseInstructions, data) {\n    for (const newColName in summariseInstructions) {\n      const instruction = summariseInstructions[newColName];\n      const name = Object.keys(instruction)[0];\n\n      checkRegularColumnName(name);\n\n      if (name in data) {\n        throw new Error(`Cannot summarise the column '${name}': used for grouping`)\n      }\n    }\n  }\n\n  function mutarise (data, mutariseInstructions) {\n    if (mutariseInstructions.constructor !== Object) {\n      throw new Error('mutarise must be an object')\n    }\n\n    let newCols = initNewData$1(mutariseInstructions);\n\n    if ('$grouped' in data) {\n      checkSummariseInstructions(mutariseInstructions, data);\n\n      for (const group of data.$grouped) {\n        let summarizedData = initNewData$1(mutariseInstructions);\n        const dataInGroup = group.data();\n        summarizedData = summariseGroup(dataInGroup, mutariseInstructions, summarizedData);\n\n        const length = getDataLength(dataInGroup);\n        newCols = addGroupSummaries(newCols, summarizedData, length);\n      }\n\n      data = ungroup(data);\n    } else {\n      let summarizedData = initNewData$1(mutariseInstructions);\n      summarizedData = summariseGroup(data, mutariseInstructions, summarizedData);\n\n      const length = getDataLength(data);\n      newCols = addGroupSummaries(newCols, summarizedData, length);\n    }\n\n    return join(data, newCols)\n  }\n\n  function addGroupSummaries (newCols, summarizedData, length) {\n    for (let i = 0; i < length; i++) {\n      for (const key in summarizedData) {\n        newCols[key].push(summarizedData[key][0]);\n      }\n    }\n\n    return newCols\n  }\n\n  function ungroup (data) {\n    const newData = initNewData$1(data.$grouped[0].data());\n\n    for (const group of data.$grouped) {\n      const groupData = group.data();\n      for (const col in newData) {\n        newData[col].push(...groupData[col]);\n      }\n    }\n\n    return newData\n  }\n\n  function join (data, newCols) {\n    for (const col in newCols) {\n      data[col] = newCols[col];\n    }\n\n    return data\n  }\n\n  function groupBy (data, groupByInstructions) {\n    const groupedData = {};\n\n    const groupedColumns = getGroupedColumns(data, groupByInstructions);\n    const groups = groupBy$1(data, groupedColumns);\n\n    groupedData.$grouped = groups.map(group => new DataContainer(group));\n    for (const col of groupedColumns) {\n      groupedData[col] = [];\n    }\n\n    for (let i = 0; i < groupedColumns.length; i++) {\n      const col = groupedColumns[i];\n\n      for (const group of groups) {\n        groupedData[col].push(group.groupedValues[i]);\n      }\n    }\n\n    return groupedData\n  }\n\n  function getGroupedColumns (data, groupByInstructions) {\n    const con = groupByInstructions.constructor;\n    if (![String, Array].includes(con)) {\n      throw new Error('groupBy can only be used with a string or array of strings')\n    }\n\n    const groupedColumns = con === String ? [groupByInstructions] : groupByInstructions;\n\n    for (const col of groupedColumns) {\n      if (!(col in data)) {\n        throw new Error(`Column '${col}' not found`)\n      }\n    }\n\n    if (groupedColumns.length === Object.keys(data).length) {\n      throw new Error('Cannot group by all columns')\n    }\n\n    return groupedColumns\n  }\n\n  function getGroupedValues (data, i, columns) {\n    const groupedValues = [];\n    for (const col of columns) {\n      groupedValues.push(data[col][i]);\n    }\n\n    return groupedValues\n  }\n\n  function groupBy$1 (data, groupedColumns) {\n    const groups = {};\n\n    const length = getDataLength(data);\n\n    for (let i = 0; i < length; i++) {\n      // Ge grouped values\n      const groupedValues = getGroupedValues(data, i, groupedColumns);\n\n      // Get unique identifier for group\n      const groupID = JSON.stringify(groupedValues);\n\n      // If groups object has no entry for this group yet: create new group object\n      groups[groupID] = groups[groupID] || new Group(data, groupedValues);\n\n      // Add row to group\n      groups[groupID].addRow(data, i);\n    }\n\n    // Convert groups object to array\n    return Object.keys(groups).map(group => {\n      return groups[group]\n    })\n  }\n\n  class Group {\n    constructor (data, groupedValues) {\n      this.data = {};\n      this.groupedValues = groupedValues;\n\n      for (const col in data) {\n        this.data[col] = [];\n      }\n    }\n\n    addRow (data, i) {\n      for (const col in data) {\n        this.data[col].push(data[col][i]);\n      }\n    }\n  }\n\n  /**\n   * Classify the series in equal intervals from minimum to maximum value.\n   * @param {array} serie\n   * @param {number} nbClass\n   * @param {number} forceMin\n   * @param {number} forceMax\n   */\n  const classifyEqInterval = (serie, nbClass, forceMin, forceMax) => {\n    if (serie.length === 0) {\n      return []\n    }\n\n    const tmpMin = typeof forceMin === 'undefined' ? Math.min(...serie) : forceMin;\n    const tmpMax = typeof forceMax === 'undefined' ? Math.max(...serie) : forceMax;\n\n    const bounds = [];\n    const interval = (tmpMax - tmpMin) / nbClass;\n    let val = tmpMin;\n\n    for (let i = 0; i <= nbClass; i++) {\n      bounds.push(val);\n      val += interval;\n    }\n\n    bounds[nbClass] = tmpMax;\n\n    return bounds\n  };\n\n  /**\n   * Based on jenks implementation of geostats\n   * https://github.com/simogeo/geostats\n   * https://raw.githubusercontent.com/simogeo/geostats/a5b2b89a7bef3c412468bb1062e3cf00ffdae0ea/lib/geostats.js\n   */\n  const classifyJenks = (serie, nbClass) => {\n    if (serie.length === 0) {\n      return []\n    }\n\n    serie.sort((a, b) => a - b);\n\n    // define two matrices mat1, mat2\n    const height = serie.length + 1;\n    const width = nbClass + 1;\n    const mat1 = Array(height)\n      .fill()\n      .map(() => Array(width).fill(0));\n    const mat2 = Array(height)\n      .fill()\n      .map(() => Array(width).fill(0));\n\n    // initialize mat1, mat2\n    for (let y = 1; y < nbClass + 1; y++) {\n      mat1[0][y] = 1;\n      mat2[0][y] = 0;\n      for (let t = 1; t < serie.length + 1; t++) {\n        mat2[t][y] = Infinity;\n      }\n    }\n\n    // fill matrices\n    for (let l = 2; l < serie.length + 1; l++) {\n      let s1 = 0.0;\n      let s2 = 0.0;\n      let w = 0.0;\n      let v = 0.0;\n      for (let m = 1; m < l + 1; m++) {\n        const i3 = l - m + 1;\n        const val = parseFloat(serie[i3 - 1]);\n        s2 += val * val;\n        s1 += val;\n        w += 1;\n        v = s2 - (s1 * s1) / w;\n        const i4 = i3 - 1;\n        if (i4 !== 0) {\n          for (let p = 2; p < nbClass + 1; p++) {\n            if (mat2[l][p] >= v + mat2[i4][p - 1]) {\n              mat1[l][p] = i3;\n              mat2[l][p] = v + mat2[i4][p - 1];\n            }\n          }\n        }\n      }\n      mat1[l][1] = 1;\n      mat2[l][1] = v;\n    }\n\n    const bounds = [];\n    bounds.push(serie[serie.length - 1]);\n    let k = serie.length;\n    for (let i = nbClass; i >= 2; i--) {\n      const idx = parseInt(mat1[k][i] - 2);\n      bounds.push(serie[idx]);\n      k = parseInt(mat1[k][i] - 1);\n    }\n    bounds.push(serie[0]);\n\n    return bounds.reverse()\n  };\n\n  const classifyQuantile = (serie, nbClass) => {\n    if (serie.length === 0) {\n      return []\n    }\n\n    serie.sort((a, b) => a - b);\n    const bounds = [];\n\n    bounds.push(serie[0]);\n    const step = serie.length / nbClass;\n    for (let i = 1; i < nbClass; i++) {\n      const qidx = Math.round(i * step + 0.49);\n      bounds.push(serie[qidx - 1]);\n    }\n    bounds.push(serie[serie.length - 1]);\n\n    return bounds\n  };\n\n  const mean$1 = (serie) => {\n    const sum = serie.reduce((sum, val) => sum + val, 0);\n    return sum / serie.length\n  };\n\n  const variance = (serie) => {\n    let tmp = 0;\n    for (let i = 0; i < serie.length; i++) {\n      tmp += Math.pow(serie[i] - mean$1(serie), 2);\n    }\n    return tmp / serie.length\n  };\n\n  const stddev = (serie) => {\n    return Math.sqrt(variance(serie))\n  };\n\n  const classifyStdDeviation = (serie, nbClass) => {\n    if (serie.length === 0) {\n      return []\n    }\n\n    const _mean = mean$1(serie);\n    const _stddev = stddev(serie);\n\n    const bounds = [];\n\n    // number of classes is odd\n    if (nbClass % 2 === 1) {\n      // Euclidean division to get the inferior bound\n      const infBound = Math.floor(nbClass / 2);\n      const supBound = infBound + 1;\n      // we set the central bounds\n      bounds[infBound] = _mean - _stddev / 2;\n      bounds[supBound] = _mean + _stddev / 2;\n      // Values < to infBound, except first one\n      for (let i = infBound - 1; i > 0; i--) {\n        const val = bounds[i + 1] - _stddev;\n        bounds[i] = val;\n      }\n      // Values > to supBound, except last one\n      for (let i = supBound + 1; i < nbClass; i++) {\n        const val = bounds[i - 1] + _stddev;\n        bounds[i] = val;\n      }\n\n      // number of classes is even\n    } else {\n      const meanBound = nbClass / 2;\n      // we get the mean value\n      bounds[meanBound] = _mean;\n      // Values < to the mean, except first one\n      for (let i = meanBound - 1; i > 0; i--) {\n        const val = bounds[i + 1] - _stddev;\n        bounds[i] = val;\n      }\n      // Values > to the mean, except last one\n      for (let i = meanBound + 1; i < nbClass; i++) {\n        const val = bounds[i - 1] + _stddev;\n        bounds[i] = val;\n      }\n    }\n    // set first value\n    bounds[0] = Math.min(...serie);\n    // set last value\n    bounds[nbClass] = Math.max(...serie);\n\n    return bounds\n  };\n\n  const numericSort = arr => arr.slice().sort((a, b) => a - b);\n  const uniqueCountSorted = arr => new Set(arr).size;\n\n  /**\n   * Based on https://github.com/simple-statistics/simple-statistics/blob/master/src/ckmeans.js\n\n   * Ckmeans clustering is an improvement on heuristic-based clustering\n   * approaches like Jenks. The algorithm was developed in\n   * [Haizhou Wang and Mingzhou Song](http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)\n   * as a [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming) approach\n   * to the problem of clustering numeric data into groups with the least\n   * within-group sum-of-squared-deviations.\n   *\n   * Minimizing the difference within groups - what Wang & Song refer to as\n   * `withinss`, or within sum-of-squares, means that groups are optimally\n   * homogenous within and the data is split into representative groups.\n   * This is very useful for visualization, where you may want to represent\n   * a continuous variable in discrete color or style groups. This function\n   * can provide groups that emphasize differences between data.\n   *\n   * Being a dynamic approach, this algorithm is based on two matrices that\n   * store incrementally-computed values for squared deviations and backtracking\n   * indexes.\n   *\n   * This implementation is based on Ckmeans 3.4.6, which introduced a new divide\n   * and conquer approach that improved runtime from O(kn^2) to O(kn log(n)).\n   *\n   * Unlike the [original implementation](https://cran.r-project.org/web/packages/Ckmeans.1d.dp/index.html),\n   * this implementation does not include any code to automatically determine\n   * the optimal number of clusters: this information needs to be explicitly\n   * provided.\n   *\n   * ### References\n   * _Ckmeans.1d.dp: Optimal k-means Clustering in One Dimension by Dynamic\n   * Programming_ Haizhou Wang and Mingzhou Song ISSN 2073-4859\n   *\n   * from The R Journal Vol. 3/2, December 2011\n   * @param {Array<number>} x input data, as an array of number values\n   * @param {number} nClusters number of desired classes. This cannot be\n   * greater than the number of values in the data array.\n   * @returns {Array<Array<number>>} clustered input\n   * @throws {Error} if the number of requested clusters is higher than the size of the data\n   * @example\n   * ckmeans([-1, 2, -1, 2, 4, 5, 6, -1, 2, -1], 3);\n   * // The input, clustered into groups of similar numbers.\n   * //= [[-1, -1, -1, -1], [2, 2, 2], [4, 5, 6]]);\n   */\n  function classifyCkmeans(x, nClusters) {\n    if (nClusters > x.length) {\n      return []\n    }\n\n    const sorted = numericSort(x);\n    // we'll use this as the maximum number of clusters\n    const uniqueCount = uniqueCountSorted(sorted);\n\n    // if all of the input values are identical, there's one cluster\n    // with all of the input in it.\n    if (uniqueCount === 1) {\n      return [sorted]\n    }\n\n    // named 'S' originally\n    const matrix = makeMatrix(nClusters, sorted.length);\n    // named 'J' originally\n    const backtrackMatrix = makeMatrix(nClusters, sorted.length);\n\n    // This is a dynamic programming way to solve the problem of minimizing\n    // within-cluster sum of squares. It's similar to linear regression\n    // in this way, and this calculation incrementally computes the\n    // sum of squares that are later read.\n    fillMatrices(sorted, matrix, backtrackMatrix);\n\n    // The real work of Ckmeans clustering happens in the matrix generation:\n    // the generated matrices encode all possible clustering combinations, and\n    // once they're generated we can solve for the best clustering groups\n    // very quickly.\n    const clusters = [];\n    let clusterRight = backtrackMatrix[0].length - 1;\n\n    // Backtrack the clusters from the dynamic programming matrix. This\n    // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),\n    // and moves the cluster target with the loop.\n    for (let cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {\n      const clusterLeft = backtrackMatrix[cluster][clusterRight];\n\n      // fill the cluster from the sorted input by taking a slice of the\n      // array. the backtrack matrix makes this easy - it stores the\n      // indexes where the cluster should start and end.\n      clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);\n\n      if (cluster > 0) {\n        clusterRight = clusterLeft - 1;\n      }\n    }\n\n    const bounds = [];\n    bounds.push(clusters[0][0]);\n    for (const cluster of clusters) {\n      bounds.push(cluster[cluster.length - 1]);\n    }\n\n    return bounds\n  }\n  /**\n   * Create a new column x row matrix.\n   *\n   * @private\n   * @param {number} columns\n   * @param {number} rows\n   * @return {Array<Array<number>>} matrix\n   * @example\n   * makeMatrix(10, 10);\n   */\n  function makeMatrix(columns, rows) {\n    const matrix = [];\n    for (let i = 0; i < columns; i++) {\n      const column = [];\n      for (let j = 0; j < rows; j++) {\n        column.push(0);\n      }\n      matrix.push(column);\n    }\n    return matrix\n  }\n\n  /**\n   * Generates incrementally computed values based on the sums and sums of\n   * squares for the data array\n   *\n   * @private\n   * @param {number} j\n   * @param {number} i\n   * @param {Array<number>} sums\n   * @param {Array<number>} sumsOfSquares\n   * @return {number}\n   * @example\n   * ssq(0, 1, [-1, 0, 2], [1, 1, 5]);\n   */\n  function ssq(j, i, sums, sumsOfSquares) {\n    let sji; // s(j, i)\n    if (j > 0) {\n      const muji = (sums[i] - sums[j - 1]) / (i - j + 1); // mu(j, i)\n      sji = sumsOfSquares[i] - sumsOfSquares[j - 1] - (i - j + 1) * muji * muji;\n    } else {\n      sji = sumsOfSquares[i] - (sums[i] * sums[i]) / (i + 1);\n    }\n    if (sji < 0) {\n      return 0\n    }\n    return sji\n  }\n\n  /**\n   * Function that recursively divides and conquers computations\n   * for cluster j\n   *\n   * @private\n   * @param {number} iMin Minimum index in cluster to be computed\n   * @param {number} iMax Maximum index in cluster to be computed\n   * @param {number} cluster Index of the cluster currently being computed\n   * @param {Array<Array<number>>} matrix\n   * @param {Array<Array<number>>} backtrackMatrix\n   * @param {Array<number>} sums\n   * @param {Array<number>} sumsOfSquares\n   */\n  function fillMatrixColumn(\n    iMin,\n    iMax,\n    cluster,\n    matrix,\n    backtrackMatrix,\n    sums,\n    sumsOfSquares\n  ) {\n    if (iMin > iMax) {\n      return\n    }\n\n    // Start at midpoint between iMin and iMax\n    const i = Math.floor((iMin + iMax) / 2);\n\n    matrix[cluster][i] = matrix[cluster - 1][i - 1];\n    backtrackMatrix[cluster][i] = i;\n\n    let jlow = cluster; // the lower end for j\n\n    if (iMin > cluster) {\n      jlow = Math.max(jlow, backtrackMatrix[cluster][iMin - 1] || 0);\n    }\n    jlow = Math.max(jlow, backtrackMatrix[cluster - 1][i] || 0);\n\n    let jhigh = i - 1; // the upper end for j\n    if (iMax < matrix.length - 1) {\n      jhigh = Math.min(jhigh, backtrackMatrix[cluster][iMax + 1] || 0);\n    }\n\n    let sji;\n    let sjlowi;\n    let ssqjlow;\n    let ssqj;\n    for (let j = jhigh; j >= jlow; --j) {\n      sji = ssq(j, i, sums, sumsOfSquares);\n\n      if (sji + matrix[cluster - 1][jlow - 1] >= matrix[cluster][i]) {\n        break\n      }\n\n      // Examine the lower bound of the cluster border\n      sjlowi = ssq(jlow, i, sums, sumsOfSquares);\n\n      ssqjlow = sjlowi + matrix[cluster - 1][jlow - 1];\n\n      if (ssqjlow < matrix[cluster][i]) {\n        // Shrink the lower bound\n        matrix[cluster][i] = ssqjlow;\n        backtrackMatrix[cluster][i] = jlow;\n      }\n      jlow++;\n\n      ssqj = sji + matrix[cluster - 1][j - 1];\n      if (ssqj < matrix[cluster][i]) {\n        matrix[cluster][i] = ssqj;\n        backtrackMatrix[cluster][i] = j;\n      }\n    }\n\n    fillMatrixColumn(\n      iMin,\n      i - 1,\n      cluster,\n      matrix,\n      backtrackMatrix,\n      sums,\n      sumsOfSquares\n    );\n    fillMatrixColumn(\n      i + 1,\n      iMax,\n      cluster,\n      matrix,\n      backtrackMatrix,\n      sums,\n      sumsOfSquares\n    );\n  }\n\n  /**\n   * Initializes the main matrices used in Ckmeans and kicks\n   * off the divide and conquer cluster computation strategy\n   *\n   * @private\n   * @param {Array<number>} data sorted array of values\n   * @param {Array<Array<number>>} matrix\n   * @param {Array<Array<number>>} backtrackMatrix\n   */\n  function fillMatrices(data, matrix, backtrackMatrix) {\n    const nValues = matrix[0].length;\n\n    // Shift values by the median to improve numeric stability\n    const shift = data[Math.floor(nValues / 2)];\n\n    // Cumulative sum and cumulative sum of squares for all values in data array\n    const sums = [];\n    const sumsOfSquares = [];\n\n    // Initialize first column in matrix & backtrackMatrix\n    for (let i = 0, shiftedValue; i < nValues; ++i) {\n      shiftedValue = data[i] - shift;\n      if (i === 0) {\n        sums.push(shiftedValue);\n        sumsOfSquares.push(shiftedValue * shiftedValue);\n      } else {\n        sums.push(sums[i - 1] + shiftedValue);\n        sumsOfSquares.push(sumsOfSquares[i - 1] + shiftedValue * shiftedValue);\n      }\n\n      // Initialize for cluster = 0\n      matrix[0][i] = ssq(0, i, sums, sumsOfSquares);\n      backtrackMatrix[0][i] = 0;\n    }\n\n    // Initialize the rest of the columns\n    let iMin;\n    for (let cluster = 1; cluster < matrix.length; ++cluster) {\n      if (cluster < matrix.length - 1) {\n        iMin = cluster;\n      } else {\n        // No need to compute matrix[K-1][0] ... matrix[K-1][N-2]\n        iMin = nValues - 1;\n      }\n\n      fillMatrixColumn(\n        iMin,\n        nValues - 1,\n        cluster,\n        matrix,\n        backtrackMatrix,\n        sums,\n        sumsOfSquares\n      );\n    }\n  }\n\n  const methodMap = {\n    EqualInterval: classifyEqInterval,\n    StandardDeviation: classifyStdDeviation,\n    Quantile: classifyQuantile,\n    Jenks: classifyJenks,\n    CKMeans: classifyCkmeans\n  };\n\n  function bin (data, binInstructions) {\n    if (binInstructions.constructor === Object) {\n      const intervalBounds = getIntervalBounds(data, binInstructions);\n      const ranges = pairRanges(intervalBounds);\n\n      return bin1d(data, binInstructions.column, ranges)\n    }\n\n    if (binInstructions.constructor === Array) {\n      const intervalBoundsPerVariable = binInstructions.map(instructions => getIntervalBounds(data, instructions));\n      const rangesPerVariable = intervalBoundsPerVariable.map(bounds => pairRanges(bounds));\n      const variables = binInstructions.map(instructions => instructions.column);\n\n      return binKd(data, variables, rangesPerVariable)\n    }\n  }\n\n  function getIntervalBounds (data, binInstructions) {\n    const { column, method, numClasses } = parseBinInstructions(binInstructions);\n\n    const variableData = data[column];\n    if (!variableData) {\n      throw new Error(`Column '${column}' does not exist`)\n    }\n\n    if (method === 'IntervalSize') {\n      return createRangesFromBinSize(variableData, binInstructions.binSize)\n    }\n\n    if (method === 'Manual') {\n      return binInstructions.manualClasses\n    }\n\n    return methodMap[method](JSON.parse(JSON.stringify(variableData)), numClasses)\n  }\n\n  function parseBinInstructions (binInstructions) {\n    if (binInstructions.constructor !== Object) {\n      throw new Error('Bin only accepts an Object')\n    }\n\n    const column = binInstructions.column;\n    if (column.constructor !== String) {\n      throw new Error('column only accepts a String variable name')\n    }\n\n    return binInstructions\n  }\n\n  function createRangesFromBinSize (variableData, binSize) {\n    if (!binSize) {\n      throw new Error('Missing required option \\'binSize\\'')\n    }\n\n    const domain = calculateDomain(variableData);\n\n    const binCount = Math.floor((domain[1] - domain[0]) / binSize);\n\n    let lowerBound = domain[0];\n    const ranges = [lowerBound];\n\n    for (let i = 0; i < binCount - 1; i++) {\n      const upperBound = lowerBound + binSize;\n      ranges.push(upperBound);\n      lowerBound = upperBound;\n    }\n\n    ranges.push(domain[1]);\n\n    return ranges\n  }\n\n  function pairRanges (ranges) {\n    const l = ranges.length;\n    const newRange = [];\n\n    for (let i = 0; i < l - 1; i++) {\n      newRange.push([ranges[i], ranges[i + 1]]);\n    }\n\n    return newRange\n  }\n\n  function bin1d (data, variable, ranges) {\n    // Create an empty array to store new groups divided by range\n    const groups = Array(ranges.length);\n\n    for (let i = 0; i < groups.length; i++) {\n      groups[i] = {};\n\n      for (const col in data) {\n        groups[i][col] = [];\n      }\n    }\n\n    const length = getDataLength(data);\n\n    for (let i = 0; i < length; i++) {\n      const value = data[variable][i];\n      const binIndex = getBinIndex(ranges, value);\n\n      if (binIndex !== -1) {\n        for (const col in data) {\n          groups[binIndex][col].push(data[col][i]);\n        }\n      }\n    }\n\n    // Remove empty bins\n    const nonEmptyBinIndices = getNonEmptyBinIndices(groups);\n    const nonEmptyRanges = nonEmptyBinIndices.map(i => ranges[i]);\n    const nonEmptyGroups = nonEmptyBinIndices.map(i => groups[i]);\n\n    // Add new grouped column to newData\n    const newData = {\n      bins: nonEmptyRanges,\n      $grouped: nonEmptyGroups.map(group => new DataContainer(group, { validate: false }))\n    };\n\n    return newData\n  }\n\n  function getBinIndex (bins, value) {\n    // Find index of bin in which the instance belongs\n    const binIndex = bins.findIndex(function (bin, i) {\n      if (i === bins.length - 1) {\n        return value >= bin[0] && value <= bin[1]\n      } else {\n        return value >= bin[0] && value < bin[1]\n      }\n    });\n\n    return binIndex\n  }\n\n  function getNonEmptyBinIndices (groups) {\n    const nonEmptyBinIndices = [];\n\n    for (let i = 0; i < groups.length; i++) {\n      if (getDataLength(groups[i]) > 0) nonEmptyBinIndices.push(i);\n    }\n\n    return nonEmptyBinIndices\n  }\n\n  function binKd (data, variables, rangesPerVariable) {\n    const binIndexTree = constructBinIndexTree(data, variables, rangesPerVariable);\n    const binnedData = convertTreeIntoColumnData(binIndexTree, variables, rangesPerVariable);\n\n    binnedData.$grouped = binnedData.$grouped.map(group => new DataContainer(group, { validate: false }));\n\n    return binnedData\n  }\n\n  function constructBinIndexTree (data, variables, rangesPerVariable) {\n    let binIndexTree = {};\n    const dataLength = getDataLength(data);\n\n    for (let i = 0; i < dataLength; i++) {\n      const binIndices = getBinIndices(data, i, variables, rangesPerVariable);\n      if (rowIsNotEmpty(binIndices)) {\n        binIndexTree = updateBranch(binIndexTree, binIndices, data, i);\n      }\n    }\n\n    return binIndexTree\n  }\n\n  function getBinIndices (data, index, variables, rangesPerVariable) {\n    const binIndices = [];\n\n    for (let i = 0; i < variables.length; i++) {\n      const variable = variables[i];\n      const value = data[variable][index];\n\n      binIndices.push(getBinIndex(rangesPerVariable[i], value));\n    }\n\n    return binIndices\n  }\n\n  function rowIsNotEmpty (binIndices) {\n    return binIndices.every(binIndex => binIndex > -1)\n  }\n\n  function updateBranch (tree, indices, data, rowIndex) {\n    let currentLevel = tree;\n\n    for (let i = 0; i < indices.length; i++) {\n      const index = indices[i];\n\n      if (lastIndex(i, indices.length)) {\n        if (!(index in currentLevel)) {\n          currentLevel[index] = initGroup(data);\n        }\n\n        currentLevel[index] = addRow(currentLevel[index], data, rowIndex);\n      } else {\n        if (!(index in currentLevel)) {\n          currentLevel[index] = {};\n        }\n\n        currentLevel = currentLevel[index];\n      }\n    }\n\n    return tree\n  }\n\n  function lastIndex (i, length) {\n    return i === (length - 1)\n  }\n\n  function initGroup (data) {\n    const group = {};\n    for (const columnName in data) {\n      group[columnName] = [];\n    }\n\n    return group\n  }\n\n  function addRow (group, data, rowIndex) {\n    for (const columnName in data) {\n      group[columnName].push(data[columnName][rowIndex]);\n    }\n\n    return group\n  }\n\n  function convertTreeIntoColumnData (binIndexTree, variables, binsPerVariable) {\n    const columnData = initColumnData$1(variables);\n    const dataIndex = variables.length;\n\n    forEachBranch(binIndexTree, branchArray => {\n      for (let i = 0; i < variables.length; i++) {\n        const binIndex = branchArray[i];\n        const bin = binsPerVariable[i][binIndex];\n\n        const binnedColumnName = getBinnedColumnName(variables[i]);\n\n        columnData[binnedColumnName].push(bin);\n      }\n\n      columnData.$grouped.push(branchArray[dataIndex]);\n    });\n\n    return columnData\n  }\n\n  function initColumnData$1 (variables) {\n    const columnData = { $grouped: [] };\n\n    for (let i = 0; i < variables.length; i++) {\n      const binnedColumnName = getBinnedColumnName(variables[i]);\n      columnData[binnedColumnName] = [];\n    }\n\n    return columnData\n  }\n\n  function forEachBranch (tree, callback) {\n    for (const path of traverse(tree)) {\n      callback(path);\n    }\n  }\n\n  // https://stackoverflow.com/a/45628445\n  function * traverse (o) {\n    const memory = new Set();\n\n    function * innerTraversal (o, path = []) {\n      if (memory.has(o)) {\n        // we've seen this object before don't iterate it\n        return\n      }\n\n      // add the new object to our memory.\n      memory.add(o);\n\n      for (const i of Object.keys(o)) {\n        const itemPath = path.concat(i);\n\n        if (!('$key' in o[i])) {\n          yield * innerTraversal(o[i], itemPath);\n        } else {\n          itemPath.push(o[i]);\n          yield itemPath;\n        }\n      }\n    }\n\n    yield * innerTraversal(o);\n  }\n\n  function getBinnedColumnName (columnName) {\n    return 'bins_' + columnName\n  }\n\n  function dropNA (data, dropInstructions) {\n    let filterFunc;\n\n    if (!dropInstructions) {\n      // If the instructions are falsy, we will check all columns for invalid values\n      filterFunc = row => {\n        let keep = true;\n\n        for (const key in row) {\n          const val = row[key];\n          if (isInvalid(val)) {\n            keep = false;\n            break\n          }\n        }\n\n        return keep\n      };\n    } else if (dropInstructions.constructor === String) {\n      // If the instructions are a string, we check only one column for invalid values\n      checkIfColumnsExist(data, [dropInstructions]);\n      filterFunc = row => !isInvalid(row[dropInstructions]);\n    } else if (dropInstructions.constructor === Array) {\n      // if the instructions are an array, we check the columns named in the array\n      checkIfColumnsExist(data, dropInstructions);\n      filterFunc = row => {\n        let keep = true;\n        for (const col of dropInstructions) {\n          if (isInvalid(row[col])) {\n            keep = false;\n            break\n          }\n        }\n\n        return keep\n      };\n    } else {\n      throw new Error('dropNA can only be passed undefined, a String or an Array of Strings')\n    }\n\n    return filter(data, filterFunc)\n  }\n\n  function checkIfColumnsExist (data, columns) {\n    for (const col of columns) {\n      if (!(col in data)) {\n        throw new Error(`Column '${col}' not found`)\n      }\n    }\n  }\n\n  function transformGeometries (geometries, transformFunc) {\n    const geometriesClone = JSON.parse(JSON.stringify(geometries));\n\n    if (geometriesClone.constructor === Array) {\n      for (let i = 0; i < geometriesClone.length; i++) {\n        transformGeometryInplace(geometriesClone[i], transformFunc);\n      }\n    }\n\n    if (geometriesClone.constructor === Object) {\n      for (const key in geometriesClone) {\n        transformGeometryInplace(geometriesClone[key], transformFunc);\n      }\n    }\n\n    return geometriesClone\n  }\n\n  function transformGeometryInplace (geometry, transformFunc) {\n    coordEach(geometry, coord => {\n      const transformedPosition = transformFunc(coord);\n      coord[0] = transformedPosition[0];\n      coord[1] = transformedPosition[1];\n    });\n  }\n\n  function reproject (data, transformation) {\n    if (!('$geometry' in data)) {\n      warn('No geometry column found. Skipping reproject-transformation.');\n      return data\n    }\n\n    const transformedGeometries = transformGeometries(data.$geometry, transformation);\n\n    const newData = Object.assign({}, data);\n    newData.$geometry = transformedGeometries;\n\n    return newData\n  }\n\n  function transform (data, transformFunction) {\n    if (transformFunction.constructor !== Function) {\n      throw new Error('Invalid \\'transform\\' transformation: must be a Function')\n    }\n\n    return transformFunction(data)\n  }\n\n  function cumsum (data, cumsumInstructions, options = { asInterval: false }) {\n    const asInterval = options.asInterval;\n    const length = getDataLength(data);\n    const newColumns = {};\n\n    for (const newColName in cumsumInstructions) {\n      checkRegularColumnName(newColName);\n\n      const oldColName = cumsumInstructions[newColName];\n\n      if (getColumnType(data[oldColName]) !== 'quantitative') {\n        throw new Error('cumsum columns can only be of type \\'quantitative\\'')\n      }\n\n      let previousSum = 0;\n      let currentSum = 0;\n      newColumns[newColName] = [];\n\n      for (let i = 0; i < length; i++) {\n        const value = data[oldColName][i];\n\n        if (!isInvalid(value)) {\n          currentSum += value;\n        }\n\n        if (asInterval) {\n          newColumns[newColName].push([previousSum, currentSum]);\n        } else {\n          newColumns[newColName].push(currentSum);\n        }\n\n        previousSum = currentSum;\n      }\n    }\n\n    let newData = Object.assign({}, data);\n    newData = Object.assign(newData, newColumns);\n\n    return newData\n  }\n\n  function rowCumsum (data, _cumsumInstructions, options = { asInterval: false }) {\n    const asInterval = options.asInterval;\n    const cumsumInstructions = parseCumsumInstructions(_cumsumInstructions);\n    validateColumns(data, cumsumInstructions);\n\n    const rowCumsumColumns = {};\n    let previousColumnName;\n\n    for (const [newName, oldName] of cumsumInstructions) {\n      checkRegularColumnName(newName);\n      const oldColumn = data[oldName];\n\n      if (previousColumnName === undefined) {\n        if (asInterval) {\n          rowCumsumColumns[newName] = oldColumn.map(value => [0, value]);\n        } else {\n          rowCumsumColumns[newName] = oldColumn;\n        }\n      } else {\n        const previousColumn = rowCumsumColumns[previousColumnName];\n        let newColumn;\n\n        if (asInterval) {\n          newColumn = oldColumn.map((value, i) => {\n            const previousValue = previousColumn[i][1];\n            const newValue = previousValue + value;\n            return [previousValue, newValue]\n          });\n        } else {\n          newColumn = oldColumn.map((value, i) => value + previousColumn[i]);\n        }\n\n        rowCumsumColumns[newName] = newColumn;\n      }\n\n      previousColumnName = newName;\n    }\n\n    let newData = Object.assign({}, data);\n    newData = Object.assign(newData, rowCumsumColumns);\n\n    return newData\n  }\n\n  const invalidInstructionsError = new Error('Invalid rowCumsum instrutions');\n\n  function parseCumsumInstructions (cumsumInstructions) {\n    if (cumsumInstructions && cumsumInstructions.constructor === Array) {\n      const parsedInstructions = [];\n\n      for (const instruction of cumsumInstructions) {\n        validateInstruction(instruction);\n\n        if (instruction.constructor === String) {\n          parsedInstructions.push([instruction, instruction]);\n        }\n\n        if (instruction.constructor === Object) {\n          const newName = Object.keys(instruction)[0];\n          const oldName = instruction[newName];\n          parsedInstructions.push([newName, oldName]);\n        }\n      }\n\n      return parsedInstructions\n    }\n\n    throw invalidInstructionsError\n  }\n\n  function validateInstruction (instruction) {\n    if (instruction.constructor === String) return\n\n    if (instruction.constructor === Object) {\n      if (Object.keys(instruction).length === 1) return\n    }\n\n    throw invalidInstructionsError\n  }\n\n  function validateColumns (data, stackInstructions) {\n    for (const [, oldName] of stackInstructions) {\n      const column = data[oldName];\n\n      if (!column) {\n        throw new Error(`Column '${oldName}' does not exist`)\n      }\n\n      const columnType = getColumnType(column);\n\n      if (columnType !== 'quantitative') {\n        throw new Error('rowCumsum columns can only be of type \\'quantitative\\'')\n      }\n    }\n  }\n\n  function _isPlaceholder(a) {\n    return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;\n  }\n\n  /**\n   * Optimized internal one-arity curry function.\n   *\n   * @private\n   * @category Function\n   * @param {Function} fn The function to curry.\n   * @return {Function} The curried function.\n   */\n\n  function _curry1(fn) {\n    return function f1(a) {\n      if (arguments.length === 0 || _isPlaceholder(a)) {\n        return f1;\n      } else {\n        return fn.apply(this, arguments);\n      }\n    };\n  }\n\n  /**\n   * Optimized internal two-arity curry function.\n   *\n   * @private\n   * @category Function\n   * @param {Function} fn The function to curry.\n   * @return {Function} The curried function.\n   */\n\n  function _curry2(fn) {\n    return function f2(a, b) {\n      switch (arguments.length) {\n        case 0:\n          return f2;\n\n        case 1:\n          return _isPlaceholder(a) ? f2 : _curry1(function (_b) {\n            return fn(a, _b);\n          });\n\n        default:\n          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {\n            return fn(_a, b);\n          }) : _isPlaceholder(b) ? _curry1(function (_b) {\n            return fn(a, _b);\n          }) : fn(a, b);\n      }\n    };\n  }\n\n  function _arity(n, fn) {\n    /* eslint-disable no-unused-vars */\n    switch (n) {\n      case 0:\n        return function () {\n          return fn.apply(this, arguments);\n        };\n\n      case 1:\n        return function (a0) {\n          return fn.apply(this, arguments);\n        };\n\n      case 2:\n        return function (a0, a1) {\n          return fn.apply(this, arguments);\n        };\n\n      case 3:\n        return function (a0, a1, a2) {\n          return fn.apply(this, arguments);\n        };\n\n      case 4:\n        return function (a0, a1, a2, a3) {\n          return fn.apply(this, arguments);\n        };\n\n      case 5:\n        return function (a0, a1, a2, a3, a4) {\n          return fn.apply(this, arguments);\n        };\n\n      case 6:\n        return function (a0, a1, a2, a3, a4, a5) {\n          return fn.apply(this, arguments);\n        };\n\n      case 7:\n        return function (a0, a1, a2, a3, a4, a5, a6) {\n          return fn.apply(this, arguments);\n        };\n\n      case 8:\n        return function (a0, a1, a2, a3, a4, a5, a6, a7) {\n          return fn.apply(this, arguments);\n        };\n\n      case 9:\n        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n          return fn.apply(this, arguments);\n        };\n\n      case 10:\n        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n          return fn.apply(this, arguments);\n        };\n\n      default:\n        throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n    }\n  }\n\n  /**\n   * Internal curryN function.\n   *\n   * @private\n   * @category Function\n   * @param {Number} length The arity of the curried function.\n   * @param {Array} received An array of arguments received thus far.\n   * @param {Function} fn The function to curry.\n   * @return {Function} The curried function.\n   */\n\n  function _curryN(length, received, fn) {\n    return function () {\n      var combined = [];\n      var argsIdx = 0;\n      var left = length;\n      var combinedIdx = 0;\n\n      while (combinedIdx < received.length || argsIdx < arguments.length) {\n        var result;\n\n        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {\n          result = received[combinedIdx];\n        } else {\n          result = arguments[argsIdx];\n          argsIdx += 1;\n        }\n\n        combined[combinedIdx] = result;\n\n        if (!_isPlaceholder(result)) {\n          left -= 1;\n        }\n\n        combinedIdx += 1;\n      }\n\n      return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));\n    };\n  }\n\n  /**\n   * Returns a curried equivalent of the provided function, with the specified\n   * arity. The curried function has two unusual capabilities. First, its\n   * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the\n   * following are equivalent:\n   *\n   *   - `g(1)(2)(3)`\n   *   - `g(1)(2, 3)`\n   *   - `g(1, 2)(3)`\n   *   - `g(1, 2, 3)`\n   *\n   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify\n   * \"gaps\", allowing partial application of any combination of arguments,\n   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),\n   * the following are equivalent:\n   *\n   *   - `g(1, 2, 3)`\n   *   - `g(_, 2, 3)(1)`\n   *   - `g(_, _, 3)(1)(2)`\n   *   - `g(_, _, 3)(1, 2)`\n   *   - `g(_, 2)(1)(3)`\n   *   - `g(_, 2)(1, 3)`\n   *   - `g(_, 2)(_, 3)(1)`\n   *\n   * @func\n   * @memberOf R\n   * @since v0.5.0\n   * @category Function\n   * @sig Number -> (* -> a) -> (* -> a)\n   * @param {Number} length The arity for the returned function.\n   * @param {Function} fn The function to curry.\n   * @return {Function} A new, curried function.\n   * @see R.curry\n   * @example\n   *\n   *      const sumArgs = (...args) => R.sum(args);\n   *\n   *      const curriedAddFourNumbers = R.curryN(4, sumArgs);\n   *      const f = curriedAddFourNumbers(1, 2);\n   *      const g = f(3);\n   *      g(4); //=> 10\n   */\n\n  var curryN =\n  /*#__PURE__*/\n  _curry2(function curryN(length, fn) {\n    if (length === 1) {\n      return _curry1(fn);\n    }\n\n    return _arity(length, _curryN(length, [], fn));\n  });\n\n  /**\n   * Optimized internal three-arity curry function.\n   *\n   * @private\n   * @category Function\n   * @param {Function} fn The function to curry.\n   * @return {Function} The curried function.\n   */\n\n  function _curry3(fn) {\n    return function f3(a, b, c) {\n      switch (arguments.length) {\n        case 0:\n          return f3;\n\n        case 1:\n          return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {\n            return fn(a, _b, _c);\n          });\n\n        case 2:\n          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {\n            return fn(_a, b, _c);\n          }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {\n            return fn(a, _b, _c);\n          }) : _curry1(function (_c) {\n            return fn(a, b, _c);\n          });\n\n        default:\n          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {\n            return fn(_a, _b, c);\n          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {\n            return fn(_a, b, _c);\n          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {\n            return fn(a, _b, _c);\n          }) : _isPlaceholder(a) ? _curry1(function (_a) {\n            return fn(_a, b, c);\n          }) : _isPlaceholder(b) ? _curry1(function (_b) {\n            return fn(a, _b, c);\n          }) : _isPlaceholder(c) ? _curry1(function (_c) {\n            return fn(a, b, _c);\n          }) : fn(a, b, c);\n      }\n    };\n  }\n\n  /**\n   * Tests whether or not an object is an array.\n   *\n   * @private\n   * @param {*} val The object to test.\n   * @return {Boolean} `true` if `val` is an array, `false` otherwise.\n   * @example\n   *\n   *      _isArray([]); //=> true\n   *      _isArray(null); //=> false\n   *      _isArray({}); //=> false\n   */\n  var _isArray = Array.isArray || function _isArray(val) {\n    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';\n  };\n\n  function _isTransformer(obj) {\n    return obj != null && typeof obj['@@transducer/step'] === 'function';\n  }\n\n  function _isString(x) {\n    return Object.prototype.toString.call(x) === '[object String]';\n  }\n\n  /**\n   * Tests whether or not an object is similar to an array.\n   *\n   * @private\n   * @category Type\n   * @category List\n   * @sig * -> Boolean\n   * @param {*} x The object to test.\n   * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.\n   * @example\n   *\n   *      _isArrayLike([]); //=> true\n   *      _isArrayLike(true); //=> false\n   *      _isArrayLike({}); //=> false\n   *      _isArrayLike({length: 10}); //=> false\n   *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true\n   */\n\n  var _isArrayLike =\n  /*#__PURE__*/\n  _curry1(function isArrayLike(x) {\n    if (_isArray(x)) {\n      return true;\n    }\n\n    if (!x) {\n      return false;\n    }\n\n    if (typeof x !== 'object') {\n      return false;\n    }\n\n    if (_isString(x)) {\n      return false;\n    }\n\n    if (x.nodeType === 1) {\n      return !!x.length;\n    }\n\n    if (x.length === 0) {\n      return true;\n    }\n\n    if (x.length > 0) {\n      return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);\n    }\n\n    return false;\n  });\n\n  var XWrap =\n  /*#__PURE__*/\n  function () {\n    function XWrap(fn) {\n      this.f = fn;\n    }\n\n    XWrap.prototype['@@transducer/init'] = function () {\n      throw new Error('init not implemented on XWrap');\n    };\n\n    XWrap.prototype['@@transducer/result'] = function (acc) {\n      return acc;\n    };\n\n    XWrap.prototype['@@transducer/step'] = function (acc, x) {\n      return this.f(acc, x);\n    };\n\n    return XWrap;\n  }();\n\n  function _xwrap(fn) {\n    return new XWrap(fn);\n  }\n\n  /**\n   * Creates a function that is bound to a context.\n   * Note: `R.bind` does not provide the additional argument-binding capabilities of\n   * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).\n   *\n   * @func\n   * @memberOf R\n   * @since v0.6.0\n   * @category Function\n   * @category Object\n   * @sig (* -> *) -> {*} -> (* -> *)\n   * @param {Function} fn The function to bind to context\n   * @param {Object} thisObj The context to bind `fn` to\n   * @return {Function} A function that will execute in the context of `thisObj`.\n   * @see R.partial\n   * @example\n   *\n   *      const log = R.bind(console.log, console);\n   *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}\n   *      // logs {a: 2}\n   * @symb R.bind(f, o)(a, b) = f.call(o, a, b)\n   */\n\n  var bind =\n  /*#__PURE__*/\n  _curry2(function bind(fn, thisObj) {\n    return _arity(fn.length, function () {\n      return fn.apply(thisObj, arguments);\n    });\n  });\n\n  function _arrayReduce(xf, acc, list) {\n    var idx = 0;\n    var len = list.length;\n\n    while (idx < len) {\n      acc = xf['@@transducer/step'](acc, list[idx]);\n\n      if (acc && acc['@@transducer/reduced']) {\n        acc = acc['@@transducer/value'];\n        break;\n      }\n\n      idx += 1;\n    }\n\n    return xf['@@transducer/result'](acc);\n  }\n\n  function _iterableReduce(xf, acc, iter) {\n    var step = iter.next();\n\n    while (!step.done) {\n      acc = xf['@@transducer/step'](acc, step.value);\n\n      if (acc && acc['@@transducer/reduced']) {\n        acc = acc['@@transducer/value'];\n        break;\n      }\n\n      step = iter.next();\n    }\n\n    return xf['@@transducer/result'](acc);\n  }\n\n  function _methodReduce(xf, acc, obj, methodName) {\n    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));\n  }\n\n  var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';\n  function _reduce(fn, acc, list) {\n    if (typeof fn === 'function') {\n      fn = _xwrap(fn);\n    }\n\n    if (_isArrayLike(list)) {\n      return _arrayReduce(fn, acc, list);\n    }\n\n    if (typeof list['fantasy-land/reduce'] === 'function') {\n      return _methodReduce(fn, acc, list, 'fantasy-land/reduce');\n    }\n\n    if (list[symIterator] != null) {\n      return _iterableReduce(fn, acc, list[symIterator]());\n    }\n\n    if (typeof list.next === 'function') {\n      return _iterableReduce(fn, acc, list);\n    }\n\n    if (typeof list.reduce === 'function') {\n      return _methodReduce(fn, acc, list, 'reduce');\n    }\n\n    throw new TypeError('reduce: list must be array or iterable');\n  }\n\n  function _has(prop, obj) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n  }\n\n  /**\n   * Returns a single item by iterating through the list, successively calling\n   * the iterator function and passing it an accumulator value and the current\n   * value from the array, and then passing the result to the next call.\n   *\n   * The iterator function receives two values: *(acc, value)*. It may use\n   * [`R.reduced`](#reduced) to shortcut the iteration.\n   *\n   * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function\n   * is *(value, acc)*.\n   *\n   * Note: `R.reduce` does not skip deleted or unassigned indices (sparse\n   * arrays), unlike the native `Array.prototype.reduce` method. For more details\n   * on this behavior, see:\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description\n   *\n   * Dispatches to the `reduce` method of the third argument, if present. When\n   * doing so, it is up to the user to handle the [`R.reduced`](#reduced)\n   * shortcuting, as this is not implemented by `reduce`.\n   *\n   * @func\n   * @memberOf R\n   * @since v0.1.0\n   * @category List\n   * @sig ((a, b) -> a) -> a -> [b] -> a\n   * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n   *        current element from the array.\n   * @param {*} acc The accumulator value.\n   * @param {Array} list The list to iterate over.\n   * @return {*} The final, accumulated value.\n   * @see R.reduced, R.addIndex, R.reduceRight\n   * @example\n   *\n   *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10\n   *      //          -               -10\n   *      //         / \\              / \\\n   *      //        -   4           -6   4\n   *      //       / \\              / \\\n   *      //      -   3   ==>     -3   3\n   *      //     / \\              / \\\n   *      //    -   2           -1   2\n   *      //   / \\              / \\\n   *      //  0   1            0   1\n   *\n   * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)\n   */\n\n  var reduce =\n  /*#__PURE__*/\n  _curry3(_reduce);\n\n  function _cloneRegExp(pattern) {\n    return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));\n  }\n\n  /**\n   * Gives a single-word string description of the (native) type of a value,\n   * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not\n   * attempt to distinguish user Object types any further, reporting them all as\n   * 'Object'.\n   *\n   * @func\n   * @memberOf R\n   * @since v0.8.0\n   * @category Type\n   * @sig (* -> {*}) -> String\n   * @param {*} val The value to test\n   * @return {String}\n   * @example\n   *\n   *      R.type({}); //=> \"Object\"\n   *      R.type(1); //=> \"Number\"\n   *      R.type(false); //=> \"Boolean\"\n   *      R.type('s'); //=> \"String\"\n   *      R.type(null); //=> \"Null\"\n   *      R.type([]); //=> \"Array\"\n   *      R.type(/[A-z]/); //=> \"RegExp\"\n   *      R.type(() => {}); //=> \"Function\"\n   *      R.type(undefined); //=> \"Undefined\"\n   */\n\n  var type =\n  /*#__PURE__*/\n  _curry1(function type(val) {\n    return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);\n  });\n\n  /**\n   * Copies an object.\n   *\n   * @private\n   * @param {*} value The value to be copied\n   * @param {Array} refFrom Array containing the source references\n   * @param {Array} refTo Array containing the copied source references\n   * @param {Boolean} deep Whether or not to perform deep cloning.\n   * @return {*} The copied value.\n   */\n\n  function _clone(value, refFrom, refTo, deep) {\n    var copy = function copy(copiedValue) {\n      var len = refFrom.length;\n      var idx = 0;\n\n      while (idx < len) {\n        if (value === refFrom[idx]) {\n          return refTo[idx];\n        }\n\n        idx += 1;\n      }\n\n      refFrom[idx + 1] = value;\n      refTo[idx + 1] = copiedValue;\n\n      for (var key in value) {\n        copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];\n      }\n\n      return copiedValue;\n    };\n\n    switch (type(value)) {\n      case 'Object':\n        return copy({});\n\n      case 'Array':\n        return copy([]);\n\n      case 'Date':\n        return new Date(value.valueOf());\n\n      case 'RegExp':\n        return _cloneRegExp(value);\n\n      default:\n        return value;\n    }\n  }\n\n  function _identity(x) {\n    return x;\n  }\n\n  /**\n   * A function that does nothing but return the parameter supplied to it. Good\n   * as a default or placeholder function.\n   *\n   * @func\n   * @memberOf R\n   * @since v0.1.0\n   * @category Function\n   * @sig a -> a\n   * @param {*} x The value to return.\n   * @return {*} The input value, `x`.\n   * @example\n   *\n   *      R.identity(1); //=> 1\n   *\n   *      const obj = {};\n   *      R.identity(obj) === obj; //=> true\n   * @symb R.identity(a) = a\n   */\n\n  var identity =\n  /*#__PURE__*/\n  _curry1(_identity);\n\n  function _objectAssign(target) {\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    var idx = 1;\n    var length = arguments.length;\n\n    while (idx < length) {\n      var source = arguments[idx];\n\n      if (source != null) {\n        for (var nextKey in source) {\n          if (_has(nextKey, source)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n\n      idx += 1;\n    }\n\n    return output;\n  }\n\n  var _objectAssign$1 = typeof Object.assign === 'function' ? Object.assign : _objectAssign;\n\n  /**\n   * Creates an object containing a single key:value pair.\n   *\n   * @func\n   * @memberOf R\n   * @since v0.18.0\n   * @category Object\n   * @sig String -> a -> {String:a}\n   * @param {String} key\n   * @param {*} val\n   * @return {Object}\n   * @see R.pair\n   * @example\n   *\n   *      const matchPhrases = R.compose(\n   *        R.objOf('must'),\n   *        R.map(R.objOf('match_phrase'))\n   *      );\n   *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}\n   */\n\n  var objOf =\n  /*#__PURE__*/\n  _curry2(function objOf(key, val) {\n    var obj = {};\n    obj[key] = val;\n    return obj;\n  });\n\n  var _stepCatArray = {\n    '@@transducer/init': Array,\n    '@@transducer/step': function (xs, x) {\n      xs.push(x);\n      return xs;\n    },\n    '@@transducer/result': _identity\n  };\n  var _stepCatString = {\n    '@@transducer/init': String,\n    '@@transducer/step': function (a, b) {\n      return a + b;\n    },\n    '@@transducer/result': _identity\n  };\n  var _stepCatObject = {\n    '@@transducer/init': Object,\n    '@@transducer/step': function (result, input) {\n      return _objectAssign$1(result, _isArrayLike(input) ? objOf(input[0], input[1]) : input);\n    },\n    '@@transducer/result': _identity\n  };\n  function _stepCat(obj) {\n    if (_isTransformer(obj)) {\n      return obj;\n    }\n\n    if (_isArrayLike(obj)) {\n      return _stepCatArray;\n    }\n\n    if (typeof obj === 'string') {\n      return _stepCatString;\n    }\n\n    if (typeof obj === 'object') {\n      return _stepCatObject;\n    }\n\n    throw new Error('Cannot create transformer for ' + obj);\n  }\n\n  /**\n   * Transforms the items of the list with the transducer and appends the\n   * transformed items to the accumulator using an appropriate iterator function\n   * based on the accumulator type.\n   *\n   * The accumulator can be an array, string, object or a transformer. Iterated\n   * items will be appended to arrays and concatenated to strings. Objects will\n   * be merged directly or 2-item arrays will be merged as key, value pairs.\n   *\n   * The accumulator can also be a transformer object that provides a 2-arity\n   * reducing iterator function, step, 0-arity initial value function, init, and\n   * 1-arity result extraction function result. The step function is used as the\n   * iterator function in reduce. The result function is used to convert the\n   * final accumulator into the return type and in most cases is R.identity. The\n   * init function is used to provide the initial accumulator.\n   *\n   * The iteration is performed with [`R.reduce`](#reduce) after initializing the\n   * transducer.\n   *\n   * @func\n   * @memberOf R\n   * @since v0.12.0\n   * @category List\n   * @sig a -> (b -> b) -> [c] -> a\n   * @param {*} acc The initial accumulator value.\n   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.\n   * @param {Array} list The list to iterate over.\n   * @return {*} The final, accumulated value.\n   * @see R.transduce\n   * @example\n   *\n   *      const numbers = [1, 2, 3, 4];\n   *      const transducer = R.compose(R.map(R.add(1)), R.take(2));\n   *\n   *      R.into([], transducer, numbers); //=> [2, 3]\n   *\n   *      const intoArray = R.into([]);\n   *      intoArray(transducer, numbers); //=> [2, 3]\n   */\n\n  var into =\n  /*#__PURE__*/\n  _curry3(function into(acc, xf, list) {\n    return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);\n  });\n\n  function wrap (data) {\n    const length = _getLength(data);\n\n    return {\n      reduce: function (step, acc) {\n        let idx = 0;\n\n        while (idx < length) {\n          const row = {};\n\n          for (const columnName in data) {\n            row[columnName] = data[columnName][idx];\n          }\n\n          acc = step(acc, row);\n\n          if (acc && acc['@@transducer/reduced']) {\n            acc = acc['@@transducer/value'];\n            break\n          }\n\n          idx += 1;\n        }\n\n        return acc\n      }\n    }\n  }\n\n  function accumulator () {\n    return new ColumnOrientedAccumulator()\n  }\n\n  function _getLength (data) {\n    return data[Object.keys(data)[0]].length\n  }\n\n  function ColumnOrientedAccumulator () {\n    this.init = true;\n  }\n\n  ColumnOrientedAccumulator.prototype['@@transducer/init'] = () => ({});\n  ColumnOrientedAccumulator.prototype['@@transducer/result'] = identity;\n  ColumnOrientedAccumulator.prototype['@@transducer/step'] = function (acc, row) {\n    if (this.init) {\n      this.init = false;\n      return this._initStep(acc, row)\n    }\n\n    return this._step(acc, row)\n  };\n  ColumnOrientedAccumulator.prototype._initStep = _initStep;\n  ColumnOrientedAccumulator.prototype._step = _step;\n\n  function _initStep (acc, row) {\n    for (const columnName in row) {\n      acc[columnName] = [row[columnName]];\n    }\n\n    return acc\n  }\n\n  function _step (acc, row) {\n    for (const columnName in row) {\n      acc[columnName].push(row[columnName]);\n    }\n\n    return acc\n  }\n\n  var columnOriented = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    wrap: wrap,\n    accumulator: accumulator\n  });\n\n  const REDUCABLE = Symbol('Reducable');\n\n  // Adapted from ramda: https://github.com/ramda/ramda\n  var _isArray$1 = Array.isArray || function _isArray (val) {\n    return (val != null &&\n            val.length >= 0 &&\n            Object.prototype.toString.call(val) === '[object Array]')\n  };\n\n  function _isString$1 (x) {\n    return Object.prototype.toString.call(x) === '[object String]'\n  }\n\n  // Adapted from ramda: https://github.com/ramda/ramda\n\n  const _isArrayLike$1 = curryN(1, function isArrayLike (x) {\n    if (_isArray$1(x)) { return true }\n    if (!x) { return false }\n    if (typeof x !== 'object') { return false }\n    if (_isString$1(x)) { return false }\n    if (x.length === 0) { return true }\n    if (x.length > 0) {\n      return 0 in x && (x.length - 1) in x\n    }\n    return false\n  });\n\n  function _isTransformer$1 (obj) {\n    return obj != null && typeof obj['@@transducer/step'] === 'function'\n  }\n\n  // Adapted from ramda: https://github.com/ramda/ramda\n\n  function _dispatchable (methodNames, transducerCreator, fn) {\n    return function () {\n      if (arguments.length === 0) {\n        return fn()\n      }\n      const obj = arguments[arguments.length - 1];\n\n      if (!_isArray$1(obj)) {\n        let idx = 0;\n        while (idx < methodNames.length) {\n          if (typeof obj[methodNames[idx]] === 'function') {\n            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1))\n          }\n          idx += 1;\n        }\n        if (_isTransformer$1(obj)) {\n          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n          return transducer(obj)\n        }\n      }\n      return fn.apply(this, arguments)\n    }\n  }\n\n  var _xfBase = {\n    init: function () {\n      return this.xf['@@transducer/init']()\n    },\n    result: function (result) {\n      return this.xf['@@transducer/result'](result)\n    }\n  };\n\n  const _xarrange = curryN(2, function _xarrange (arrangeInstructions, xf) {\n    return new XArrange(arrangeInstructions, xf)\n  });\n\n  const arrange$1 = curryN(2, _dispatchable([], _xarrange,\n    function (arrangeInstructions, df) {\n      return into(\n        [],\n        arrange$1(arrangeInstructions),\n        df\n      )\n    }\n  ));\n\n  function XArrange (arrangeInstructions, xf) {\n    this.arrangeFn = arrangeInstructions.constructor === Function\n      ? arrangeInstructions\n      : _combineArrangeFns(arrangeInstructions);\n\n    this.rows = [];\n    this.xf = xf;\n  }\n\n  XArrange.prototype['@@transducer/init'] = _xfBase.init;\n  XArrange.prototype['@@transducer/result'] = function () {\n    this.rows.sort(this.arrangeFn);\n\n    return this.xf['@@transducer/result'](reduce(\n      this.xf['@@transducer/step'].bind(this.xf),\n      this.xf['@@transducer/init'](),\n      this.rows\n    ))\n  };\n  XArrange.prototype['@@transducer/step'] = function (acc, row) {\n    this.rows.push(row);\n  };\n\n  function _combineArrangeFns (arrangeFns) {\n    return function (a, b) {\n      for (let i = 0; i < arrangeFns.length; i++) {\n        const res = arrangeFns[i](a, b);\n        if (res) return res\n      }\n\n      return -1\n    }\n  }\n\n  function _reduceObjVals (step, acc, obj) {\n    for (const key in obj) {\n      const val = obj[key];\n\n      acc = step(acc, val);\n\n      if (acc && acc['@@transducer/reduced']) {\n        acc = acc['@@transducer/value'];\n        break\n      }\n    }\n\n    return acc\n  }\n\n  function _idFromCols (row, idCols, sep = '@') {\n    let id = sep;\n\n    for (let i = 0; i < idCols.length; i++) {\n      id += row[idCols[i]] + sep;\n    }\n\n    return id\n  }\n\n  const _xsummariseByReducable = (summariseFn, by, xf) => {\n    return new XSummariseByReducable(summariseFn, by, xf)\n  };\n\n  function XSummariseByReducable (summariseFn, by, xf) {\n    this.instructions = _getReducableInstructions(summariseFn);\n    this.by = by;\n    this.xf = xf;\n\n    this.summarizedDataById = {};\n  }\n\n  function _getReducableInstructions (f) {\n    const columnProxy = new Proxy({}, { get (_, prop) { return prop } });\n    return f(columnProxy)\n  }\n\n  XSummariseByReducable.prototype['@@transducer/init'] = _xfBase.init;\n  XSummariseByReducable.prototype['@@transducer/result'] = _result;\n  XSummariseByReducable.prototype['@@transducer/step'] = _step$2;\n  XSummariseByReducable.prototype._finalStep = _finalStep;\n\n  function _result () {\n    return this.xf['@@transducer/result'](_reduceObjVals(\n      this._finalStep.bind(this),\n      this.xf['@@transducer/init'](),\n      this.summarizedDataById\n    ))\n  }\n\n  function _step$2 (acc, row) {\n    const id = _idFromCols(row, this.by);\n    const newId = !(id in this.summarizedDataById);\n\n    if (newId) {\n      this.summarizedDataById[id] = _initSummaryGroup(\n        this.instructions,\n        row,\n        this.by\n      );\n    }\n\n    this.summarizedDataById[id] = _updateSummaryGroup(\n      this.summarizedDataById[id],\n      this.instructions,\n      row\n    );\n\n    return acc\n  }\n\n  function _finalStep (acc, row) {\n    for (const newColumnName in this.instructions) {\n      row[newColumnName] = this\n        .instructions[newColumnName]\n        .xf['@@transducer/result'](row[newColumnName]);\n    }\n\n    return this.xf['@@transducer/step'](acc, row)\n  }\n\n  function _initSummaryGroup (instructions, row, by) {\n    const summaryGroup = {};\n\n    for (const newColumnName in instructions) {\n      const instruction = instructions[newColumnName];\n      summaryGroup[newColumnName] = instruction.xf['@@transducer/init']();\n    }\n\n    for (let i = 0; i < by.length; i++) {\n      const byCol = by[i];\n      summaryGroup[byCol] = row[byCol];\n    }\n\n    return summaryGroup\n  }\n\n  function _updateSummaryGroup (summaryGroup, instructions, row) {\n    for (const newColumnName in instructions) {\n      const instruction = instructions[newColumnName];\n\n      summaryGroup[newColumnName] = instruction.xf['@@transducer/step'](\n        summaryGroup[newColumnName],\n        row[instruction.column]\n      );\n    }\n\n    return summaryGroup\n  }\n\n  const _stepCatArray$1 = {\n    '@@transducer/init': Array,\n    '@@transducer/step': function (xs, x) {\n      xs.push(x);\n      return xs\n    },\n    '@@transducer/result': identity\n  };\n\n  const _stepCatString$1 = {\n    '@@transducer/init': String,\n    '@@transducer/step': function (a, b) { return a + b },\n    '@@transducer/result': identity\n  };\n\n  const _stepCatObject$1 = {\n    '@@transducer/init': Object,\n    '@@transducer/step': function (result, input) {\n      return Object.assign(\n        result,\n        _isArrayLike$1(input) ? objOf(input[0], input[1]) : input\n      )\n    },\n    '@@transducer/result': identity\n  };\n\n  function _stepCat$1 (obj) {\n    if (_isTransformer$1(obj)) {\n      return obj\n    }\n\n    if (_isArrayLike$1(obj)) {\n      return _stepCatArray$1\n    }\n\n    if (typeof obj === 'string') {\n      return _stepCatString$1\n    }\n\n    if (typeof obj === 'object') {\n      return _stepCatObject$1\n    }\n\n    throw new Error('Cannot create transformer for ' + obj)\n  }\n\n  function _getSelectFn (columns) {\n    return row => {\n      const newRow = {};\n\n      for (let i = 0; i < columns.length; i++) {\n        const columnName = columns[i];\n        newRow[columnName] = row[columnName];\n      }\n\n      return newRow\n    }\n  }\n\n  const _xnestBy = curryN(3, function _xnestBy (nestInstructions, by, xf) {\n    return new XNestBy(nestInstructions, by, xf)\n  });\n\n  const nestBy = curryN(3, _dispatchable([], _xnestBy,\n    function (nestInstructions, by, df) {\n      return into(\n        [],\n        nestBy(nestInstructions, by),\n        df\n      )\n    }\n  ));\n\n  function XNestBy (nestInstructions, by, xf) {\n    const nestInstructionsIsObj = nestInstructions.constructor === Object;\n\n    this.nestColName = nestInstructionsIsObj\n      ? nestInstructions.column\n      : nestInstructions;\n\n    this.getAccumulator = nestInstructionsIsObj && nestInstructions.getAccumulator\n      ? nestInstructions.getAccumulator\n      : () => [];\n\n    this.by = by;\n    this.xf = xf;\n\n    this.select = null;\n    this.nestedDataById = {};\n    this.accumulatorById = {};\n\n    this.init = true;\n  }\n\n  XNestBy.prototype['@@transducer/init'] = _xfBase.init;\n  XNestBy.prototype['@@transducer/result'] = _result$1;\n  XNestBy.prototype['@@transducer/step'] = function (acc, row) {\n    if (this.init) {\n      this._initStep(acc, row);\n      this.init = false;\n    }\n\n    return this._step(acc, row)\n  };\n  XNestBy.prototype._initStep = _initStep$1;\n  XNestBy.prototype._step = _step$3;\n\n  function _result$1 () {\n    return this.xf['@@transducer/result'](_reduceObjVals(\n      this.xf['@@transducer/step'].bind(this.xf),\n      this.xf['@@transducer/init'](),\n      this.nestedDataById\n    ))\n  }\n\n  function _initStep$1 (acc, row) {\n    const bySet = new Set(this.by);\n    const nestedColumns = [];\n\n    for (const columnName in row) {\n      if (!bySet.has(columnName)) {\n        nestedColumns.push(columnName);\n      }\n    }\n\n    this.select = _getSelectFn(nestedColumns);\n  }\n\n  function _step$3 (acc, row) {\n    const id = _idFromCols(row, this.by);\n    const newId = !(id in this.accumulatorById);\n\n    if (newId) {\n      this.accumulatorById[id] = _stepCat$1(this.getAccumulator());\n\n      const nestRow = _initNestRow(\n        row,\n        this.nestColName,\n        this.by,\n        this.accumulatorById[id]['@@transducer/init']()\n      );\n\n      this.nestedDataById[id] = nestRow;\n    }\n\n    const xf = this.accumulatorById[id];\n\n    this.nestedDataById[id][this.nestColName] = xf['@@transducer/step'](\n      this.nestedDataById[id][this.nestColName],\n      this.select(row)\n    );\n\n    return acc\n  }\n\n  function _initNestRow (row, nestColName, by, initVal) {\n    const nestRow = {};\n\n    for (let i = 0; i < by.length; i++) {\n      const colName = by[i];\n      nestRow[colName] = row[colName];\n    }\n\n    nestRow[nestColName] = initVal;\n\n    return nestRow\n  }\n\n  const _xsummariseByIrreducable = (summariseFn, by, xf) => {\n    return new XSummariseByIrreducable(summariseFn, by, xf)\n  };\n\n  function XSummariseByIrreducable (summariseFn, by, xf) {\n    this.summariseFn = summariseFn;\n    this.by = by;\n    this.xf = xf;\n\n    this.nestColName = Symbol('nested');\n    this.getAccumulator = accumulator;\n\n    this.nestedColumns = [];\n    this.nestedDataById = {};\n    this.accumulatorById = {};\n\n    this.init = true;\n  }\n\n  XSummariseByIrreducable.prototype['@@transducer/init'] = _xfBase.init;\n  XSummariseByIrreducable.prototype['@@transducer/result'] = _result$2;\n  XSummariseByIrreducable.prototype['@@transducer/step'] = function (acc, row) {\n    if (this.init) {\n      this._initStep(acc, row);\n      this.init = false;\n    }\n\n    return this._step(acc, row)\n  };\n  XSummariseByIrreducable.prototype._initStep = _initStep$1;\n  XSummariseByIrreducable.prototype._step = _step$3;\n  XSummariseByIrreducable.prototype._finalStep = _finalStep$1;\n\n  function _result$2 () {\n    return this.xf['@@transducer/result'](_reduceObjVals(\n      this._finalStep.bind(this),\n      this.xf['@@transducer/init'](),\n      this.nestedDataById\n    ))\n  }\n\n  function _finalStep$1 (acc, row) {\n    const summarizedRow = this.summariseFn(row[this.nestColName]);\n\n    for (let i = 0; i < this.by.length; i++) {\n      const byCol = this.by[i];\n      summarizedRow[byCol] = row[byCol];\n    }\n\n    return this.xf['@@transducer/step'](acc, summarizedRow)\n  }\n\n  const _xsummariseBy = curryN(3, (summariseFn, by, xf) => {\n    return _isReducable(summariseFn)\n      ? _xsummariseByReducable(summariseFn, by, xf)\n      : _xsummariseByIrreducable(summariseFn, by, xf)\n  });\n\n  const summariseBy = curryN(3, _dispatchable([], _xsummariseBy,\n    function (summariseFn, by, df) {\n      return into(\n        [],\n        summariseBy(summariseFn, by),\n        df\n      )\n    }\n  ));\n\n  function _isReducable (summariseFn) {\n    try {\n      const summariseInstructions = summariseFn({});\n\n      for (const newColumnName in summariseInstructions) {\n        if (summariseInstructions[newColumnName] !== REDUCABLE) {\n          return false\n        }\n      }\n    } catch (e) {\n      return false\n    }\n\n    return true\n  }\n\n  const _xfilterByReducable = (summariseFn, predicate, by, xf) => {\n    return new XFilterByReducable(summariseFn, predicate, by, xf)\n  };\n\n  function XFilterByReducable (summariseFn, predicate, by, xf) {\n    this.instructions = _getReducableInstructions(summariseFn);\n    this.predicate = predicate;\n    this.by = by;\n    this.xf = xf;\n\n    this.summarizedDataById = {};\n    this.rows = [];\n    this.ids = [];\n  }\n\n  XFilterByReducable.prototype['@@transducer/init'] = _xfBase.init;\n  XFilterByReducable.prototype['@@transducer/result'] = _result$3;\n  XFilterByReducable.prototype['@@transducer/step'] = _step$4;\n\n  function _result$3 () {\n    for (const id in this.summarizedDataById) {\n      for (const newColumnName in this.instructions) {\n        const resultFn = this\n          .instructions[newColumnName]\n          .xf['@@transducer/result'];\n\n        this.summarizedDataById[id][newColumnName] = resultFn(\n          this.summarizedDataById[id][newColumnName]\n        );\n      }\n    }\n\n    let acc = this.xf['@@transducer/init']();\n    let idx = 0;\n    const len = this.rows.length;\n\n    while (idx < len) {\n      const row = this.rows[idx];\n      const id = this.ids[idx];\n\n      if (this.predicate(row, this.summarizedDataById[id])) {\n        acc = this.xf['@@transducer/step'](acc, row);\n      }\n\n      if (acc && acc['@@transducer/reduced']) {\n        acc = acc['@@transducer/value'];\n        break\n      }\n\n      idx++;\n    }\n\n    return this.xf['@@transducer/result'](acc)\n  }\n\n  function _step$4 (acc, row) {\n    const id = _idFromCols(row, this.by);\n    const newId = !(id in this.summarizedDataById);\n\n    this.rows.push(row);\n    this.ids.push(id);\n\n    if (newId) {\n      this.summarizedDataById[id] = _initSummaryGroup(\n        this.instructions,\n        row,\n        this.by\n      );\n    }\n\n    this.summarizedDataById[id] = _updateSummaryGroup(\n      this.summarizedDataById[id],\n      this.instructions,\n      row\n    );\n\n    return acc\n  }\n\n  // import _reduceObjVals from './_reduceObjVals.js'\n\n  const _xfilterByIrreducable = (summariseFn, predicate, by, xf) => {\n    return new XFilterByIrreducable(summariseFn, predicate, by, xf)\n  };\n\n  function XFilterByIrreducable (summariseFn, predicate, by, xf) {\n    this.summariseFn = summariseFn;\n    this.predicate = predicate;\n    this.by = by;\n    this.xf = xf;\n\n    this.nestColName = Symbol('nested');\n    this.getAccumulator = accumulator;\n\n    this.nestedColumns = [];\n    this.nestedDataById = {};\n    this.accumulatorById = {};\n    this.rows = [];\n    this.ids = [];\n\n    this.init = true;\n  }\n\n  XFilterByIrreducable.prototype['@@transducer/init'] = _xfBase.init;\n  XFilterByIrreducable.prototype['@@transducer/result'] = _result$4;\n  XFilterByIrreducable.prototype['@@transducer/step'] = function (acc, row) {\n    if (this.init) {\n      this._initStep(acc, row);\n      this.init = false;\n    }\n\n    return this._step(acc, row)\n  };\n  XFilterByIrreducable.prototype._initStep = _initStep$1;\n  XFilterByIrreducable.prototype._step = _step$5;\n\n  function _result$4 () {\n    for (const id in this.nestedDataById) {\n      const row = this.nestedDataById[id];\n\n      const summarizedRow = this.summariseFn(row[this.nestColName]);\n\n      for (let i = 0; i < this.by.length; i++) {\n        const byCol = this.by[i];\n        summarizedRow[byCol] = row[byCol];\n      }\n\n      this.nestedDataById[id] = summarizedRow;\n    }\n\n    this.summarizedDataById = this.nestedDataById;\n    this.nestedDataById = null;\n\n    let acc = this.xf['@@transducer/init']();\n    let idx = 0;\n    const len = this.rows.length;\n\n    while (idx < len) {\n      const row = this.rows[idx];\n      const id = this.ids[idx];\n\n      if (this.predicate(row, this.summarizedDataById[id])) {\n        acc = this.xf['@@transducer/step'](acc, row);\n      }\n\n      if (acc && acc['@@transducer/reduced']) {\n        acc = acc['@@transducer/value'];\n        break\n      }\n\n      idx++;\n    }\n\n    return this.xf['@@transducer/result'](acc)\n  }\n\n  function _step$5 (acc, row) {\n    const id = _idFromCols(row, this.by);\n    const newId = !(id in this.accumulatorById);\n\n    this.rows.push(row);\n    this.ids.push(id);\n\n    if (newId) {\n      this.accumulatorById[id] = _stepCat$1(this.getAccumulator());\n\n      const nestRow = _initNestRow(\n        row,\n        this.nestColName,\n        this.by,\n        this.accumulatorById[id]['@@transducer/init']()\n      );\n\n      this.nestedDataById[id] = nestRow;\n    }\n\n    const xf = this.accumulatorById[id];\n\n    this.nestedDataById[id][this.nestColName] = xf['@@transducer/step'](\n      this.nestedDataById[id][this.nestColName],\n      this.select(row)\n    );\n\n    return acc\n  }\n\n  const _xfilterBy = curryN(4, function _xfilterBy (summariseFn, predicate, by, xf) {\n    return _isReducable(summariseFn)\n      ? _xfilterByReducable(summariseFn, predicate, by, xf)\n      : _xfilterByIrreducable(summariseFn, predicate, by, xf)\n  });\n\n  const filterBy = curryN(4, _dispatchable([], _xfilterBy,\n    function (summariseFn, predicate, by, df) {\n      return into(\n        [],\n        filterBy(summariseFn, predicate, by),\n        df\n      )\n    }\n  ));\n\n  const _xpivotLonger = curryN(2, function _xpivotLonger (pivotInstructions, xf) {\n    return new XPivotLonger(pivotInstructions, xf)\n  });\n\n  const pivotLonger = curryN(2, _dispatchable([], _xpivotLonger,\n    function (pivotInstructions, df) {\n      return into(\n        [],\n        pivotLonger(pivotInstructions),\n        df\n      )\n    }\n  ));\n\n  function XPivotLonger ({ columns, namesTo, valuesTo }, xf) {\n    this.pivotColumns = columns;\n    this.pivotColumnsSet = new Set(columns);\n    this.namesTo = namesTo;\n    this.valuesTo = valuesTo;\n    this.xf = xf;\n\n    this.columns = null;\n    this.idColumns = null;\n\n    this.init = true;\n  }\n\n  XPivotLonger.prototype['@@transducer/init'] = _xfBase.init;\n  XPivotLonger.prototype['@@transducer/result'] = _xfBase.result;\n  XPivotLonger.prototype['@@transducer/step'] = function (acc, row) {\n    if (this.init) {\n      this._initStep(acc, row);\n      this.init = false;\n    }\n\n    return this._step(acc, row)\n  };\n  XPivotLonger.prototype._initStep = _initStep$2;\n  XPivotLonger.prototype._step = _step$6;\n\n  function _initStep$2 (acc, row) {\n    this.columns = Object.keys(row);\n\n    this.idColumns = this.columns.filter(\n      columnName => !this.pivotColumnsSet.has(columnName)\n    );\n  }\n\n  function _step$6 (acc, row) {\n    const newRows = [];\n\n    for (let j = 0; j < this.pivotColumns.length; j++) {\n      const newRow = {};\n\n      const pivotColumnName = this.pivotColumns[j];\n      const pivotColumnValue = row[pivotColumnName];\n\n      newRow[this.namesTo] = pivotColumnName;\n      newRow[this.valuesTo] = pivotColumnValue;\n\n      for (let k = 0; k < this.idColumns.length; k++) {\n        const idColumnName = this.idColumns[k];\n        newRow[idColumnName] = row[idColumnName];\n      }\n\n      newRows.push(newRow);\n    }\n\n    return reduce(\n      this.xf['@@transducer/step'].bind(this.xf),\n      acc,\n      newRows\n    )\n  }\n\n  const _xpivotWider = curryN(2, function _xpivotWider (pivotInstructions, xf) {\n    return new XPivotWider(pivotInstructions, xf)\n  });\n\n  const pivotWider = curryN(2, _dispatchable([], _xpivotWider,\n    function (pivotInstructions, df) {\n      return into(\n        [],\n        pivotWider(pivotInstructions),\n        df\n      )\n    }\n  ));\n\n  function XPivotWider ({ namesFrom, valuesFrom, valuesFill = null }, xf) {\n    this.namesFrom = namesFrom;\n    this.valuesFrom = valuesFrom;\n    this.valuesFill = valuesFill;\n    this.xf = xf;\n\n    this.idColumns = null;\n    this.widerRowsById = {};\n    this.newColumnsSet = new Set();\n    this.newColumns = null;\n\n    this.init = true;\n  }\n\n  XPivotWider.prototype['@@transducer/init'] = _xfBase.init;\n  XPivotWider.prototype['@@transducer/result'] = _result$5;\n  XPivotWider.prototype['@@transducer/step'] = function (acc, row) {\n    if (this.init) {\n      this._initStep(acc, row);\n      this.init = false;\n    }\n\n    return this._step(acc, row)\n  };\n  XPivotWider.prototype._initStep = _initStep$3;\n  XPivotWider.prototype._step = _step$7;\n  XPivotWider.prototype._finalStep = _finalStep$2;\n\n  function _result$5 () {\n    this.newColumns = Array.from(this.newColumnsSet);\n\n    return this.xf['@@transducer/result'](_reduceObjVals(\n      this._finalStep.bind(this),\n      this.xf['@@transducer/init'](),\n      this.widerRowsById\n    ))\n  }\n\n  function _initStep$3 (acc, row) {\n    const columns = Object.keys(row);\n    const nonIdColumns = [this.namesFrom, this.valuesFrom];\n    this.idColumns = columns.filter(c => !nonIdColumns.includes(c));\n  }\n\n  function _step$7 (acc, row) {\n    const id = _idFromCols(row, this.idColumns);\n    const newId = !(id in this.widerRowsById);\n\n    if (newId) {\n      const widerRow = {};\n\n      for (let i = 0; i < this.idColumns.length; i++) {\n        const idColumn = this.idColumns[i];\n        widerRow[idColumn] = row[idColumn];\n      }\n\n      this.widerRowsById[id] = widerRow;\n    }\n\n    const column = row[this.namesFrom];\n    const value = row[this.valuesFrom];\n\n    this.widerRowsById[id][column] = value;\n    this.newColumnsSet.add(column);\n  }\n\n  function _finalStep$2 (acc, row) {\n    for (let i = 0; i < this.newColumns.length; i++) {\n      const newColumn = this.newColumns[i];\n\n      if (!(newColumn in row)) {\n        row[newColumn] = this.valuesFill;\n      }\n    }\n\n    return this.xf['@@transducer/step'](acc, row)\n  }\n\n  function _reduced (x) {\n    return x && x['@@transducer/reduced']\n      ? x\n      : {\n        '@@transducer/value': x,\n        '@@transducer/reduced': true\n      }\n  }\n\n  const _xslice = curryN(2, function _xslice (indices, xf) {\n    return new XSlice(indices, xf)\n  });\n\n  const slice = curryN(2, _dispatchable([], _xslice,\n    function (indices, df) {\n      return into(\n        [],\n        slice(indices),\n        df\n      )\n    }\n  ));\n\n  function XSlice (indices, xf) {\n    this.indices = new Set(indices);\n    this.xf = xf;\n\n    this.counter = -1;\n  }\n\n  XSlice.prototype['@@transducer/init'] = _xfBase.init;\n  XSlice.prototype['@@transducer/result'] = _xfBase.result;\n  XSlice.prototype['@@transducer/step'] = function (acc, row) {\n    this.counter++;\n\n    if (this.indices.has(this.counter)) {\n      this.indices.delete(this.counter);\n      const output = this.xf['@@transducer/step'](acc, row);\n\n      return this.indices.size === 0\n        ? _reduced(output)\n        : output\n    }\n\n    return acc\n  };\n\n  const _xunnest = curryN(3, function _xunnest (nestColName, nestWrapper, xf) {\n    return new XUnnest(nestColName, nestWrapper, xf)\n  });\n\n  const unnest = curryN(3, _dispatchable([], _xunnest,\n    function (nestColName, nestWrapper, df) {\n      return into(\n        [],\n        unnest(nestColName, nestWrapper),\n        df\n      )\n    }\n  ));\n\n  function XUnnest (nestColName, nestWrapper, xf) {\n    this.nestColName = nestColName;\n    this.nestWrapper = nestWrapper;\n    this.xf = xf;\n    this.outerColumns = [];\n\n    this.init = true;\n  }\n\n  XUnnest.prototype['@@transducer/init'] = _xfBase.init;\n  XUnnest.prototype['@@transducer/result'] = _xfBase.result;\n  XUnnest.prototype['@@transducer/step'] = function (acc, row) {\n    if (this.init) {\n      this._initStep(acc, row);\n      this.init = false;\n    }\n\n    return this._step(acc, row)\n  };\n\n  XUnnest.prototype._initStep = function (acc, row) {\n    for (const columnName in row) {\n      if (columnName !== this.nestColName) {\n        this.outerColumns.push(columnName);\n      }\n    }\n  };\n\n  XUnnest.prototype._step = function (acc, row) {\n    const nestedData = row[this.nestColName];\n\n    const rowWithoutNested = Object.assign({}, row);\n    delete rowWithoutNested[this.nestColName];\n\n    return reduce(\n      (innerAcc, innerRow) => this.xf[['@@transducer/step']](\n        innerAcc,\n        _attach(innerRow, rowWithoutNested)\n      ),\n      acc,\n      this.nestWrapper(nestedData)\n    )\n  };\n\n  function _attach (innerRow, outerRow) {\n    const newRow = Object.assign({}, innerRow);\n\n    for (const columnName in outerRow) {\n      newRow[columnName] = outerRow[columnName];\n    }\n\n    return newRow\n  }\n\n  function pivotLonger$1 (_data, pivotInstructions) {\n    const data = Object.assign({}, _data);\n    delete data.$key;\n\n    return into(\n      columnOriented.accumulator(),\n      pivotLonger(pivotInstructions),\n      columnOriented.wrap(data)\n    )\n  }\n\n  function pivotWider$1 (_data, pivotInstructions) {\n    const data = Object.assign({}, _data);\n    delete data.$key;\n\n    return into(\n      columnOriented.accumulator(),\n      pivotWider(pivotInstructions),\n      columnOriented.wrap(data)\n    )\n  }\n\n  const transformations = {\n    filter,\n    select,\n    arrange,\n    rename,\n    mutate,\n    transmute,\n    summarise,\n    mutarise,\n    groupBy,\n    bin,\n    dropNA,\n    reproject,\n    transform,\n    cumsum,\n    rowCumsum,\n    pivotLonger: pivotLonger$1,\n    pivotWider: pivotWider$1\n  };\n\n  const methods$2 = {\n    arrange (sortInstructions) {\n      const data = transformations.arrange(this._data, sortInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    bin (binInstructions) {\n      const data = transformations.bin(this._data, binInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    cumsum (cumsumInstructions, options) {\n      const data = transformations.cumsum(this._data, cumsumInstructions, options);\n      return new DataContainer(data, { validate: false })\n    },\n\n    dropNA (dropInstructions) {\n      const data = transformations.dropNA(this._data, dropInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    filter (filterFunction) {\n      const data = transformations.filter(this._data, filterFunction);\n      return new DataContainer(data, { validate: false })\n    },\n\n    groupBy (groupByInstructions) {\n      const data = transformations.groupBy(this._data, groupByInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    mutarise (mutariseInstructions) {\n      const data = transformations.mutarise(this._data, mutariseInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    mutarize (mutariseInstructions) {\n      const data = transformations.mutarise(this._data, mutariseInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    mutate (mutateInstructions) {\n      const data = transformations.mutate(this._data, mutateInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    pivotLonger (pivotInstructions) {\n      const data = transformations.pivotLonger(this._data, pivotInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    pivotWider (pivotInstructions) {\n      const data = transformations.pivotWider(this._data, pivotInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    transmute (transmuteInstructions) {\n      const data = transformations.transmute(this._data, transmuteInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    rename (renameInstructions) {\n      const data = transformations.rename(this._data, renameInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    reproject (reprojectInstructions) {\n      const data = transformations.reproject(this._data, reprojectInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    rowCumsum (cumsumInstructions, options) {\n      const data = transformations.rowCumsum(this._data, cumsumInstructions, options);\n      return new DataContainer(data, { validate: false })\n    },\n\n    select (selection) {\n      const data = transformations.select(this._data, selection);\n      return new DataContainer(data, { validate: false })\n    },\n\n    summarise (summariseInstructions) {\n      const data = transformations.summarise(this._data, summariseInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    summarize (summariseInstructions) {\n      const data = transformations.summarise(this._data, summariseInstructions);\n      return new DataContainer(data, { validate: false })\n    },\n\n    transform (transformFunction) {\n      const data = transformations.transform(this._data, transformFunction);\n      return new DataContainer(data, { validate: false })\n    }\n  };\n\n  function transformationsMixin (targetClass) {\n    Object.assign(targetClass.prototype, methods$2);\n  }\n\n  function ensureValidRow (row, self) {\n    for (const columnName in row) {\n      if (!(columnName in self._data)) throw new Error(`Column '${columnName}' not found`)\n    }\n\n    for (const columnName in self._data) {\n      if (columnName === '$key') {\n        if (columnName in row) throw new Error('Cannot set \\'$key\\' column')\n      } else {\n        if (!(columnName in row)) throw new Error(`Missing column '${columnName}'`)\n\n        const value = row[columnName];\n        ensureValueIsRightForColumn(value, columnName, self);\n      }\n    }\n  }\n\n  function ensureValidRowUpdate (row, self) {\n    for (const columnName in row) {\n      if (!(columnName in self._data)) throw new Error(`Column '${columnName}' not found`)\n\n      const value = row[columnName];\n      ensureValueIsRightForColumn(value, columnName, self);\n    }\n  }\n\n  function ensureRowExists (accessorObject, self) {\n    if (isUndefined(self._rowIndex(accessorObject))) {\n      throw new Error(`Invalid accessor object: '${accessorObject.toString()}'`)\n    }\n  }\n\n  function ensureValueIsRightForColumn (value, columnName, self) {\n    if (!isInvalid(value)) {\n      const columnType = getColumnType(self._data[columnName]);\n\n      ensureValidDataType(value);\n      const valueType = getDataType(value);\n\n      if (columnType !== valueType) {\n        throw new Error(`Column '${columnName}' is of type '${columnType}'. Received value of type '${valueType}'`)\n      }\n    }\n  }\n\n  function isValidColumn (column, columnName) {\n    const columnType = getColumnType(column);\n\n    if (columnType === undefined) return false\n    if (!columnNameMatchesType(columnName, columnType)) return false\n    if (!allValidValuesHaveTheSameType(column, columnType)) return false\n\n    return true\n  }\n\n  function ensureValidColumn (column, columnName) {\n    const { nValidValues } = findFirstValidValue(column);\n\n    if (nValidValues === 0) {\n      throw new Error(`Invalid column '${columnName}'. Column contains only invalid values.`)\n    }\n\n    const columnType = getColumnType(column);\n\n    if (columnType === undefined) throw new Error(`Column '${columnName}' contains data of unknown type`)\n    ensureColumnNameMatchesType(columnType);\n    ensureAllValidValuesHaveTheSameType(column, columnType, columnName);\n  }\n\n  function columnNameMatchesType (columnName, columnType) {\n    if (columnName === '$geometry' && columnType !== 'geometry') return false\n    if (columnName !== '$geometry' && columnType === 'geometry') return false\n\n    return true\n  }\n\n  function ensureColumnNameMatchesType (columnName, columnType) {\n    if (columnName === '$geometry' && columnType !== 'geometry') {\n      throw new Error(`Column '$geometry' can only contain data of type 'geometry', received '${columnType}'`)\n    }\n\n    if (columnName !== '$geometry' && columnType === 'geometry') {\n      throw new Error(`Only the '$geometry' column can contain data of type 'geometry'`)\n    }\n  }\n\n  function allValidValuesHaveTheSameType (column, columnType) {\n    for (let i = 0; i < column.length; i++) {\n      const value = column[i];\n\n      if (isInvalid(value)) continue\n\n      const valueType = getDataType(value);\n\n      if (valueType !== columnType) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  function ensureAllValidValuesHaveTheSameType (column, columnType, columnName) {\n    if (!allValidValuesHaveTheSameType(column, columnType)) {\n      throw new Error(`Column '${columnName}' mixes types`)\n    }\n  }\n\n  function columnExists (columnName, self) {\n    return columnName in self._data\n  }\n\n  function ensureColumnExists (columnName, self) {\n    if (!columnExists(columnName, self)) {\n      throw new Error(`Invalid column name: '${columnName}'`)\n    }\n  }\n\n  const methods$3 = {\n    // Rows\n    addRow (row) {\n      ensureValidRow(row, this);\n\n      for (const columnName in row) {\n        const value = row[columnName];\n        this._data[columnName].push(value);\n\n        this._updateDomainIfNecessary(columnName, value);\n      }\n\n      const rowIndex = getDataLength(this._data) - 1;\n\n      if (!this._keyColumn) {\n        const key = incrementKey(this._data.$key);\n\n        this._data.$key.push(key);\n        this._keyToRowIndex.set(key, rowIndex);\n      }\n\n      if (this._keyColumn) {\n        const key = row[this._keyColumn];\n\n        if (this._keyToRowIndex.has(key)) {\n          throw new Error(`Duplicate key '${key}'`)\n        }\n\n        this._keyToRowIndex.set(key, rowIndex);\n      }\n    },\n\n    updateRow (accessorObject, row) {\n      if (row.constructor === Function) {\n        const result = row(this.row(accessorObject));\n\n        if (!(result && result.constructor === Object)) {\n          throw new Error('updateRow function must return Object')\n        }\n\n        this.updateRow(accessorObject, result);\n      }\n\n      ensureRowExists(accessorObject, this);\n      ensureValidRowUpdate(row, this);\n\n      const rowIndex = this._rowIndex(accessorObject);\n\n      if (this._keyColumn && this._keyColumn in row) {\n        const oldKey = this._row(rowIndex).$key;\n        const newKey = row[this._keyColumn];\n\n        if (\n          newKey !== oldKey &&\n          this._keyToRowIndex.has(newKey)\n        ) {\n          throw new Error(`Duplicate key '${newKey}'`)\n        }\n\n        this._keyToRowIndex.delete(oldKey);\n        this._keyToRowIndex.set(newKey, rowIndex);\n      }\n\n      for (const columnName in row) {\n        throwErrorIfColumnIsKey(columnName);\n\n        const value = row[columnName];\n        this._data[columnName][rowIndex] = value;\n\n        this._resetDomainIfNecessary(columnName);\n      }\n    },\n\n    deleteRow (accessorObject) {\n      ensureRowExists(accessorObject, this);\n\n      const rowIndex = this._rowIndex(accessorObject);\n      const key = this._row(rowIndex).$key;\n\n      this._keyToRowIndex.delete(key);\n\n      for (const columnName in this._data) {\n        if (!(this._keyColumn && columnName === '$key')) {\n          this._data[columnName].splice(rowIndex, 1);\n          this._resetDomainIfNecessary(columnName);\n        }\n      }\n    },\n\n    // Columns\n    addColumn (columnName, column) {\n      this._validateNewColumn(columnName, column);\n      this._data[columnName] = column;\n    },\n\n    replaceColumn (columnName, column) {\n      this.deleteColumn(columnName);\n      this.addColumn(columnName, column);\n    },\n\n    deleteColumn (columnName) {\n      ensureColumnExists(columnName, this);\n      throwErrorIfColumnIsKey(columnName);\n\n      if (Object.keys(this._data).length === 2) {\n        throw new Error('Cannot delete last column')\n      }\n\n      delete this._data[columnName];\n    },\n\n    // Private methods\n    _updateDomainIfNecessary (columnName, value) {\n      const type = getDataType(value);\n\n      if (columnName in this._domains) {\n        this._domains[columnName] = updateDomain(\n          this._domains[columnName],\n          value,\n          type\n        );\n      }\n    },\n\n    _resetDomainIfNecessary (columnName) {\n      if (columnName in this._domains) {\n        delete this._domains[columnName];\n      }\n    },\n\n    _validateNewColumn (columnName, column) {\n      checkRegularColumnName(columnName);\n\n      if (columnName in this._data) {\n        throw new Error(`Column '${columnName}' already exists`)\n      }\n\n      const dataLength = getDataLength(this._data);\n      if (dataLength !== column.length) {\n        throw new Error('Column must be of same length as rest of data')\n      }\n\n      ensureValidColumn(column);\n    }\n  };\n\n  function modifyingRowsAndColumnsMixin (targetClass) {\n    Object.assign(targetClass.prototype, methods$3);\n  }\n\n  function throwErrorIfColumnIsKey (columnName) {\n    if (columnName === '$key') throw new Error('Cannot modify key column')\n  }\n\n  function ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n\n  function bisector(f) {\n    let delta = f;\n    let compare = f;\n\n    if (f.length === 1) {\n      delta = (d, x) => f(d) - x;\n      compare = ascendingComparator(f);\n    }\n\n    function left(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        const mid = (lo + hi) >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    }\n\n    function right(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        const mid = (lo + hi) >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n\n    function center(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      const i = left(a, x, lo, hi);\n      return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n    }\n\n    return {left, center, right};\n  }\n\n  function ascendingComparator(f) {\n    return (d, x) => ascending(f(d), x);\n  }\n\n  var ascendingBisect = bisector(ascending);\n  var bisectRight = ascendingBisect.right;\n\n  function initRange(domain, range) {\n    switch (arguments.length) {\n      case 0: break;\n      case 1: this.range(domain); break;\n      default: this.range(range).domain(domain); break;\n    }\n    return this;\n  }\n\n  function threshold() {\n    var domain = [0.5],\n        range = [0, 1],\n        unknown,\n        n = 1;\n\n    function scale(x) {\n      return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;\n    }\n\n    scale.domain = function(_) {\n      return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n    };\n\n    scale.range = function(_) {\n      return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n    };\n\n    scale.invertExtent = function(y) {\n      var i = range.indexOf(y);\n      return [domain[i - 1], domain[i]];\n    };\n\n    scale.unknown = function(_) {\n      return arguments.length ? (unknown = _, scale) : unknown;\n    };\n\n    scale.copy = function() {\n      return threshold()\n          .domain(domain)\n          .range(range)\n          .unknown(unknown);\n    };\n\n    return initRange.apply(scale, arguments);\n  }\n\n  const methods$4 = {\n    bounds (binInstructions) {\n      const bounds = this.fullBounds(binInstructions);\n      return bounds.slice(1, bounds.length - 1)\n    },\n\n    fullBounds (binInstructions) {\n      if (this.type(binInstructions.column) !== 'quantitative') {\n        throw new Error('Column should be of type \\'quantitative\\'')\n      }\n\n      const bounds = getIntervalBounds(\n        this._data,\n        binInstructions\n      );\n\n      return bounds\n    },\n\n    boundRanges (binInstructions) {\n      const bounds = this.fullBounds(binInstructions);\n      const boundRanges = [];\n\n      for (let i = 0; i < bounds.length - 1; i++) {\n        boundRanges.push([bounds[i], bounds[i + 1]]);\n      }\n\n      return boundRanges\n    },\n\n    classify (binInstructions, range) {\n      const bounds = this.bounds(binInstructions);\n\n      return threshold()\n        .domain(bounds)\n        .range(range)\n    }\n  };\n\n  function classificationMixin (targetClass) {\n    Object.assign(targetClass.prototype, methods$4);\n  }\n\n  function getJoinColumns (left, right, by) {\n    const leftData = left.data();\n    const rightData = right.data();\n\n    if (isUndefined(by)) {\n      const leftDataLength = getDataLength(leftData);\n      const joinColumns = {};\n\n      for (const columnName in rightData) {\n        if (columnName !== '$key') {\n          const rightColumn = rightData[columnName];\n          joinColumns[columnName] = rightColumn.slice(0, leftDataLength);\n        }\n      }\n\n      return joinColumns\n    }\n\n    if (isDefined(by)) {\n      const joinColumns = initJoinColumns(rightData, by[1]);\n\n      const rightRowsByKey = generateRightRowsByKey(rightData, by[1]);\n      const leftByColumn = leftData[by[0]];\n\n      for (let i = 0; i < leftByColumn.length; i++) {\n        const leftKey = leftByColumn[i];\n        const row = rightRowsByKey[leftKey];\n\n        for (const columnName in row) {\n          joinColumns[columnName].push(row[columnName]);\n        }\n      }\n\n      return joinColumns\n    }\n  }\n\n  function initJoinColumns (right, byColumnName) {\n    const joinColumns = {};\n\n    for (const columnName in right) {\n      if (columnName !== '$key' && columnName !== byColumnName) {\n        joinColumns[columnName] = [];\n      }\n    }\n\n    return joinColumns\n  }\n\n  function generateRightRowsByKey (right, byColumnName) {\n    const rightRowsByKey = {};\n    const byColumn = right[byColumnName];\n\n    for (let i = 0; i < byColumn.length; i++) {\n      const key = byColumn[i];\n      const row = {};\n\n      for (const columnName in right) {\n        if (columnName !== '$key' && columnName !== byColumnName) {\n          row[columnName] = right[columnName][i];\n        }\n      }\n\n      rightRowsByKey[key] = row;\n    }\n\n    return rightRowsByKey\n  }\n\n  function validateJoin (left, right, by) {\n    const leftData = left.data();\n    const rightData = getRightData(right);\n\n    if (isUndefined(by)) {\n      const leftLength = getDataLength(leftData);\n      const rightLength = getDataLength(rightData);\n\n      if (rightLength < leftLength) {\n        throw new Error(\n          'Without \\'by\\', the right DataContainer must be the same length as or longer than left DataContainer'\n        )\n      }\n    }\n\n    if (isDefined(by)) {\n      validateByColumnsExist(leftData, rightData, by);\n      ensureColumnsAreCompatible(leftData, rightData, by);\n      ensureNoDuplicateColumnNames(leftData, rightData, by);\n    }\n  }\n\n  function getRightData (right) {\n    if (!(right instanceof DataContainer)) {\n      throw new Error('It is only possible to join another DataContainer')\n    }\n\n    return right.data()\n  }\n\n  function validateByColumnsExist (left, right, by) {\n    if (!(by.constructor === Array && by.length === 2 && by.every(c => c.constructor === String))) {\n      throw new Error('Invalid format of \\'by\\'. Must be Array of two column names.')\n    }\n\n    const [leftColumnName, rightColumnName] = by;\n\n    if (!(leftColumnName in left)) {\n      throw new Error(`Column '${leftColumnName}' not found`)\n    }\n\n    if (!(rightColumnName in right)) {\n      throw new Error(`Column '${rightColumnName}' not found`)\n    }\n  }\n\n  function ensureColumnsAreCompatible (left, right, by) {\n    const [leftColumnName, rightColumnName] = by;\n    const leftColumn = left[leftColumnName];\n    const rightColumn = right[rightColumnName];\n\n    const leftType = getColumnType(leftColumn);\n    const rightType = getColumnType(rightColumn);\n\n    if (leftType !== rightType) throw new Error('\\'by\\' columns must be of the same type')\n\n    ensureRightByColumnIsUnique(right[rightColumnName]);\n    ensureLeftColumnIsSubsetOfRightColumn(leftColumn, rightColumn);\n  }\n\n  function ensureRightByColumnIsUnique (column) {\n    if (column.length !== new Set(column).size) {\n      throw new Error('Right \\'by\\' column must contain only unique values')\n    }\n  }\n\n  function ensureLeftColumnIsSubsetOfRightColumn (leftColumn, rightColumn) {\n    const rightSet = new Set(rightColumn);\n\n    for (let i = 0; i < leftColumn.length; i++) {\n      const leftKey = leftColumn[i];\n      if (!rightSet.has(leftKey)) {\n        throw new Error('Left \\'by\\' column must be subset of right column')\n      }\n    }\n  }\n\n  function ensureNoDuplicateColumnNames (left, right, by) {\n    const rightColumnName = by[1];\n\n    for (const columnName in right) {\n      if (columnName !== '$key' && columnName in left) {\n        if (columnName !== rightColumnName) {\n          throw new Error(`Duplicate column name: '${columnName}'`)\n        }\n      }\n    }\n  }\n\n  function validateAccessorObject (accessorObject) {\n    const keys = Object.keys(accessorObject);\n\n    if (\n      accessorObject &&\n      accessorObject.constructor === Object &&\n      keys.length === 1 &&\n      ['index', 'key'].includes(keys[0])\n    ) {\n      return\n    }\n\n    throw new Error('Invalid accessor object, must be either \\'{ index: <index> }\\'  or \\'{ key: <key> }\\'')\n  }\n\n  class DataContainer {\n    constructor (data, options = { validate: true }) {\n      this._data = {};\n      this._keyToRowIndex = new Map();\n      this._keyColumn = null;\n      this._domains = {};\n\n      if (isColumnOriented(data)) {\n        this._setColumnData(data, options);\n        return\n      }\n\n      if (isRowOriented(data)) {\n        this._setRowData(data, options);\n        return\n      }\n\n      if (isGeoJSON(data)) {\n        this._setGeoJSON(data, options);\n        return\n      }\n\n      if (data instanceof Group) {\n        this._setGroup(data, options);\n        return\n      }\n\n      throw invalidDataError\n    }\n\n    // Accessing data\n    data () {\n      return this._data\n    }\n\n    row (accessorObject) {\n      const rowIndex = this._rowIndex(accessorObject);\n      return this._row(rowIndex)\n    }\n\n    rows () {\n      const rows = [];\n      const length = getDataLength(this._data);\n\n      for (let i = 0; i < length; i++) {\n        rows.push(this._row(i));\n      }\n\n      return rows\n    }\n\n    column (columnName) {\n      ensureColumnExists(columnName, this);\n      return this._data[columnName]\n    }\n\n    map (columnName, mapFunction) {\n      return this.column(columnName).map(mapFunction)\n    }\n\n    domain (columnName) {\n      if (columnName in this._domains) {\n        return this._domains[columnName]\n      }\n\n      const column = this.column(columnName);\n      const domain = calculateDomain(column, columnName);\n      this._domains[columnName] = domain;\n      return domain\n    }\n\n    bbox () {\n      return this.domain('$geometry')\n    }\n\n    min (columnName) {\n      if (!['quantitative', 'interval'].includes(this.type(columnName))) {\n        throw new Error('Column must be quantitative')\n      }\n\n      return this.domain(columnName)[0]\n    }\n\n    max (columnName) {\n      if (!['quantitative', 'interval'].includes(this.type(columnName))) {\n        throw new Error('Column must be quantitative')\n      }\n\n      return this.domain(columnName)[1]\n    }\n\n    type (columnName) {\n      const column = this.column(columnName);\n      return getColumnType(column)\n    }\n\n    columnNames () {\n      return Object.keys(this._data)\n    }\n\n    nrow () {\n      return getDataLength(this._data)\n    }\n\n    // Checks\n    hasColumn (columnName) {\n      return columnExists(columnName, this)\n    }\n\n    hasRow (accessorObject) {\n      const rowIndex = this._rowIndex(accessorObject);\n      const length = this.nrow();\n\n      return typeof rowIndex !== 'undefined' && rowIndex < length && rowIndex >= 0\n    }\n\n    columnIsValid (columnName) {\n      const column = this.column(columnName);\n      return isValidColumn(column, columnName)\n    }\n\n    validateColumn (columnName) {\n      const column = this.column(columnName);\n      ensureValidColumn(column, columnName);\n    }\n\n    validateAllColumns () {\n      for (const columnName in this._data) {\n        this.validateColumn(columnName);\n      }\n    }\n\n    // Join\n    join (dataContainer, { by = undefined } = {}) {\n      validateJoin(this, dataContainer, by);\n      const joinColumns = getJoinColumns(this, dataContainer, by);\n\n      for (const columnName in joinColumns) {\n        this.addColumn(columnName, joinColumns[columnName]);\n      }\n    }\n\n    // Private methods\n    _rowIndex (accessorObject) {\n      validateAccessorObject(accessorObject);\n\n      const rowIndex = 'key' in accessorObject\n        ? this._keyToRowIndex.get(accessorObject.key)\n        : accessorObject.index;\n\n      return rowIndex\n    }\n\n    _row (rowIndex) {\n      const length = getDataLength(this._data);\n\n      if (rowIndex < 0 || rowIndex >= length) {\n        return undefined\n      }\n\n      const row = {};\n\n      for (const columnName in this._data) {\n        const value = this._data[columnName][rowIndex];\n        row[columnName] = value;\n      }\n\n      return row\n    }\n  }\n\n  dataLoadingMixin(DataContainer);\n  keyMixin(DataContainer);\n  transformationsMixin(DataContainer);\n  modifyingRowsAndColumnsMixin(DataContainer);\n  classificationMixin(DataContainer);\n\n  const invalidDataError = new Error('Data passed to DataContainer is of unknown format');\n\n  return DataContainer;\n\n})));\n"],
  "mappings": "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",
  "names": ["max", "type", "data", "sum", "bin", "o", "curryN", "_isArray", "XWrap", "bind", "copy", "objOf", "into", "_xarrange", "_xnestBy", "_xfilterBy", "_xpivotLonger", "_xpivotWider", "_xslice", "_xunnest", "self"]
}
