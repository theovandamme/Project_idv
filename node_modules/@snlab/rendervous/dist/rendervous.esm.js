import { path as path$2 } from 'd3-path';
import { scaleLinear } from 'd3-scale';
import RBush from 'rbush';
import { curveLinear as curveLinear$1 } from 'd3-shape';
import { ColorTranslator } from 'colortranslator';

function getAspectRatio (parentSection) {
  const { rangeX, rangeY } = parentSection.ranges;

  const dx = Math.abs(rangeX[0] - rangeX[1]);
  const dy = Math.abs(rangeY[0] - rangeY[1]);

  return dx / dy
}

function getNRowsAndColumns (numberOfCells, nrows, ncolumns, aspectRatio) {
  if (!nrows && !ncolumns) {
    return getNRowsAndColumnsFromAspectRatio(numberOfCells, aspectRatio)
  }

  if (nrows && !ncolumns) {
    return {
      nrows,
      ncolumns: Math.ceil(numberOfCells / nrows)
    }
  }

  if (!nrows && ncolumns) {
    return {
      nrows: Math.ceil(numberOfCells / ncolumns),
      ncolumns
    }
  }

  return { nrows, ncolumns }
}

function getNRowsAndColumnsFromAspectRatio (numberOfCells, aspectRatio) {
  let ncolumns = 1;
  let nrows = 1;

  while (ncolumns * nrows < numberOfCells) {
    const aspectRatioIfColumnsAreIncremented = (ncolumns + 1) / nrows;
    const aspectRatioIfRowsAreIncremented = ncolumns / (nrows + 1);

    const deltaC = Math.abs(aspectRatio - aspectRatioIfColumnsAreIncremented);
    const deltaR = Math.abs(aspectRatio - aspectRatioIfRowsAreIncremented);

    if (deltaC < deltaR) {
      ncolumns++;
    } else {
      nrows++;
    }
  }

  return { nrows, ncolumns }
}

function getGridCellPositions (numberOfCells, nrows, ncolumns) {
  const cellWidth = 1 / ncolumns;
  const cellHeight = 1 / nrows;

  const cells = [];

  for (let rowIndex = 0; rowIndex < nrows; rowIndex++) {
    for (let columnIndex = 0; columnIndex < ncolumns; columnIndex++) {
      cells.push({
        x1: cellWidth * columnIndex,
        x2: cellWidth * (columnIndex + 1),
        y1: cellHeight * rowIndex,
        y2: cellHeight * (rowIndex + 1)
      });

      if (cells.length === numberOfCells) break
    }
    if (cells.length === numberOfCells) break
  }

  return cells
}

function getGridCells (
  {
    numberOfCells,
    rows,
    columns
  },
  parentSection
) {
  if (numberOfCells === 0) return []

  const aspectRatio = getAspectRatio(parentSection);

  const { nrows, ncolumns } = getNRowsAndColumns(
    numberOfCells,
    rows,
    columns,
    aspectRatio
  );

  if ((nrows * ncolumns) < numberOfCells) {
    throw new Error('numberOfCells lower than rows * columns')
  }

  return getGridCellPositions(numberOfCells, nrows, ncolumns)
}

/* eslint lines-between-class-members: 0 */
class RecorderBase {
  constructor () {
    this._resetCalls();
  }

  _resetCalls () {
    this._positioningCalls = { call: [], args: [], submarks: [] };
  }

  // Record method calls
  closePath () { addCall(this._positioningCalls, 'closePath', arguments); }
  moveTo () { addCall(this._positioningCalls, 'moveTo', arguments); }
  lineTo () { addCall(this._positioningCalls, 'lineTo', arguments); }
  quadraticCurveTo () { addCall(this._positioningCalls, 'quadraticCurveTo', arguments); }
  bezierCurveTo () { addCall(this._positioningCalls, 'bezierCurveTo', arguments); }
  arcTo () { addCall(this._positioningCalls, 'arcTo', arguments); }
  arc () { addCall(this._positioningCalls, 'arc', arguments); }
  ellipse () { addCall(this._positioningCalls, 'ellipse', arguments); }
  translate () { addCall(this._positioningCalls, 'translate', arguments); }
  rotate () { addCall(this._positioningCalls, 'rotate', arguments); }

  // Custom method to detect multi polygons / multi linestrings
  submarkStart () {
    this._positioningCalls.submarks.push(this._positioningCalls.call.length);
  }
}

function addCall (obj, callName, args) {
  obj.call.push(callName);
  obj.args.push(args);
}

class RecorderMark extends RecorderBase {
  result () {
    return this._positioningCalls
  }
}

class RecorderLayer extends RecorderBase {
  constructor () {
    super();
    this._marks = [];
  }

  markEnd () {
    this._marks.push(this._positioningCalls);
    this._resetCalls();
  }

  result () {
    return this._marks
  }
}

class RecorderLabel extends RecorderMark {
  _resetCalls () {
    this._positioningCalls = { call: [], args: [], submarks: [] };
  }
}

class RecorderLabelLayer extends RecorderLayer {
  _resetCalls () {
    this._positioningCalls = { call: [], args: [], submarks: [] };
  }
}

function recorderMark () {
  return new RecorderMark()
}

function recorderLayer () {
  return new RecorderLayer()
}

function recorderLabel () {
  return new RecorderLabel()
}

function recorderLabelLayer () {
  return new RecorderLabelLayer()
}

class BaseContext {
  beginPath () {}
  closePath () {}
  moveTo () {}
  lineTo () {}
  quadraticCurveTo () {}
  bezierCurveTo () {}
  arcTo () {}
  arc () {}
  ellipse () {}
  fill () {}
  stroke () {}
  setLineDash () {}
  fillText () {}
  strokeText () {}
  translate () {}
  rotate () {}
  save () {}
  restore () {}
  rect () {}
  clip () {}
  setTransform () {}

  markStart () {}
  markEnd () {}
  layerStart () {}
  layerEnd () {}
  submarkStart () {}
}

// Adapted from https://github.com/d3/d3-path/blob/master/src/path.js#L84
const pi = Math.PI;
const tau = 2 * pi;
const epsilon = 1e-6;
const tauEpsilon = tau - epsilon;

function ellipse (pathGen, x, y, rx, ry, rot, a0, a1, ccw) {
  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;
  ccw = !!ccw;

  const dx = rx * Math.cos(a0);
  const dy = ry * Math.sin(a0);
  const x0 = x + dx;
  const y0 = y + dy;
  const cw = 1 ^ ccw;
  let da = ccw ? a0 - a1 : a1 - a0;

  // Is the radius negative? Error.
  if (rx < 0) throw new Error('negative radius x: ' + rx)
  if (ry < 0) throw new Error('negative radius: ' + ry)

  if (pathGen._x1 === null) {
    // Is this path empty? Move to (x0,y0).
    pathGen._ += 'M' + x0 + ',' + y0;
  } else if (Math.abs(pathGen._x1 - x0) > epsilon || Math.abs(pathGen._y1 - y0) > epsilon) {
    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    pathGen._ += 'L' + x0 + ',' + y0;
  }

  // Is this arc empty? Weâ€™re done.
  if (!rx) return
  if (!ry) return

  // Does the angle go the wrong way? Flip the direction.
  if (da < 0) da = da % tau + tau;

  if (da > tauEpsilon) {
    // Is this a complete circle? Draw two arcs to complete the circle.
    pathGen._ += 'A' + rx + ',' + ry + ',0,1,' + cw + ',' + (x - dx) + ',' + (y - dy) + 'A' + rx + ',' + ry + ',0,1,' + cw + ',' + (pathGen._x1 = x0) + ',' + (pathGen._y1 = y0);
  } else if (da > epsilon) {
    // Is this arc non-empty? Draw an arc!
    pathGen._ += 'A' + rx + ',' + ry + ',0,' + (+(da >= pi)) + ',' + cw + ',' + (pathGen._x1 = x + rx * Math.cos(a1)) + ',' + (pathGen._y1 = y + ry * Math.sin(a1));
  }
}

/* eslint lines-between-class-members: 0 */

function path () {
  return new Path()
}

function pathLayer () {
  return new PathLayer()
}

class BasePath extends BaseContext {
  constructor () {
    super();
    this._pathContext = path$2();
  }

  _reset () {
    this._pathContext._x0 = null;
    this._pathContext._y0 = null;
    this._pathContext._x1 = null;
    this._pathContext._y1 = null;
    this._pathContext._ = '';
  }
  closePath () { this._pathContext.closePath(); }
  moveTo (x, y) { this._pathContext.moveTo(x, y); }
  lineTo (x, y) { this._pathContext.lineTo(x, y); }
  quadraticCurveTo () {
    this._pathContext.quadraticCurveTo.apply(this._pathContext, arguments);
  }
  bezierCurveTo () {
    this._pathContext.bezierCurveTo.apply(this._pathContext, arguments);
  }
  arcTo () {
    this._pathContext.arcTo.apply(this._pathContext, arguments);
  }
  arc () {
    this._pathContext.arc.apply(this._pathContext, arguments);
  }
  ellipse (x, y, rx, ry, rot, a0, a1, ccw) {
    ellipse(this._pathContext, x, y, rx, ry, rot, a0, a1, ccw);
  }
}

class Path extends BasePath {
  result () {
    const output = { d: this._pathContext.toString() };
    this._reset();

    return output
  }
}

class PathLayer extends BasePath {
  constructor () {
    super();
    this.marks = [];
  }

  markEnd () {
    this.marks.push({ d: this._pathContext.toString() });
    this._reset();
  }

  result () {
    const result = this.marks;
    this.marks = [];

    return result
  }
}

function text () {
  return new Text()
}

function textLayer () {
  return new TextLayer()
}

class BaseText extends BaseContext {
  constructor () {
    super();
    this._reset();
  }

  _reset () {
    this._currentStyle = {};
    this._currentRotation = null;
  }
  translate (x, y) {
    this._currentStyle.x = x;
    this._currentStyle.y = y;
  }
  rotate (rotation) {
    this._currentRotation = rotation;
  }
}

class Text extends BaseText {
  result () {
    const result = getTextData(this);
    this._reset();

    return result
  }
}

class TextLayer extends BaseText {
  constructor () {
    super();
    this.marks = [];
  }

  markEnd () {
    const result = getTextData(this);
    this._reset();

    this.marks.push(result);
  }

  result () {
    const result = this.marks;
    this.marks = [];
    return result
  }
}

function getTextData (self) {
  const result = self._currentStyle;

  if (self._currentRotation) {
    result.transform = getRotation(self._currentRotation, result.x, result.y);
  }

  return result
}

function getRotation (rotationRadians, x, y) {
  const rotationDegrees = rotationRadians * (180 / Math.PI);
  return `rotate(${rotationDegrees},${x},${y})`
}

function circle () {
  return new Circle()
}

function circleLayer () {
  return new CircleLayer()
}

class BaseCircle extends BaseContext {
  constructor () {
    super();
    this._reset();
  }

  _reset () {
    this._currentStyle = {};
  }
  beginPath () {}
  arc (x, y, radius, sAngle, eAngle, counterclockwise) {
    this._currentStyle.cx = x;
    this._currentStyle.cy = y;
  }
}

class Circle extends BaseCircle {
  result () {
    const result = getCircleData(this);
    this._reset();
    return result
  }
}

class CircleLayer extends BaseCircle {
  constructor () {
    super();
    this.marks = [];
  }

  markEnd () {
    this.marks.push(this._currentStyle);
    this._reset();
  }

  result () {
    const result = this.marks;
    this.marks = [];
    return result
  }
}

function getCircleData (self) {
  const result = self._currentStyle;
  return result
}

var svgPositioning = /*#__PURE__*/Object.freeze({
  __proto__: null,
  path: path,
  pathLayer: pathLayer,
  text: text,
  textLayer: textLayer,
  getRotation: getRotation,
  circle: circle,
  circleLayer: circleLayer
});

/* eslint lines-between-class-members: 0 */

function path$1 () {
  return new Path$1()
}

function pathLayer$1 () {
  return new PathLayer$1()
}

class BasePath$1 extends BaseContext {
  constructor () {
    super();
    this._pathContext = path$2();
  }

  _reset () {
    this._pathContext._x0 = null;
    this._pathContext._y0 = null;
    this._pathContext._x1 = null;
    this._pathContext._y1 = null;
    this._pathContext._ = '';

    resetStyles(this, PATH_STYLES);
  }

  closePath () { this._pathContext.closePath(); }
  moveTo (x, y) { this._pathContext.moveTo(x, y); }
  lineTo (x, y) { this._pathContext.lineTo(x, y); }
  quadraticCurveTo () {
    this._pathContext.quadraticCurveTo.apply(this._pathContext, arguments);
  }
  bezierCurveTo () {
    this._pathContext.bezierCurveTo.apply(this._pathContext, arguments);
  }
  arcTo () {
    this._pathContext.arcTo.apply(this._pathContext, arguments);
  }
  arc () {
    this._pathContext.arc.apply(this._pathContext, arguments);
  }
  ellipse (x, y, rx, ry, rot, a0, a1, ccw) {
    ellipse(this._pathContext, x, y, rx, ry, rot, a0, a1, ccw);
  }
  setLineDash (dashArray) {
    this._strokeDashArray = dashArray.join(' ');
  }
}

class Path$1 extends BasePath$1 {
  result () {
    const result = getPathData(this);
    this._reset();

    return result
  }
}

class PathLayer$1 extends BasePath$1 {
  constructor () {
    super();
    this.marks = [];
  }

  markEnd () {
    this.marks.push(getPathData(this));
    this._reset();
  }

  layerEnd () {
    if (anyStylesActive(this, PATH_STYLES)) {
      for (let i = 0; i < this.marks.length; i++) {
        attachStyles(this.marks[i], this, PATH_STYLES);
      }
    }
  }

  result () {
    const result = this.marks;
    this.marks = [];

    return result
  }
}

function getPathData (self) {
  const result = { d: self._pathContext.toString() };

  attachStyles(result, self, PATH_STYLES);

  return result
}

const PATH_STYLES = {
  fillStyle: 'fill',
  strokeStyle: 'stroke',
  lineWidth: 'stroke-width',
  _strokeDashArray: 'stroke-dasharray',
  lineCap: 'stroke-linecap',
  lineJoin: 'stroke-linejoin',
  miterLimit: 'stroke-miterlimit',
  lineDashOffset: 'stroke-dashoffset'
};

function attachStyles (target, source, styles) {
  for (const styleName in styles) {
    if (source[styleName]) { target[styles[styleName]] = source[styleName]; }
  }
}

function anyStylesActive (context, styles) {
  for (const styleName in styles) {
    if (context[styleName]) return true
  }

  return false
}

function resetStyles (context, styles) {
  for (const styleName in styles) {
    context[styleName] = undefined;
  }
}

function text$1 () {
  return new Text$1()
}

function textLayer$1 () {
  return new TextLayer$1()
}

class BaseText$1 extends BaseContext {
  constructor () {
    super();
    this._reset();
  }

  _reset () {
    this._currentStyle = {};
    this._currentRotation = null;
  }
  fillText (text, x, y) {
    this._currentStyle.text = text;
    this._currentStyle.fill = this.fillStyle;
  }
  strokeText (text, x, y) {
    this._currentStyle.text = text;
    this._currentStyle.stroke = this.strokeStyle;
    this._currentStyle['stroke-width'] = this.lineWidth;
  }
  translate (x, y) {
    this._currentStyle.x = x;
    this._currentStyle.y = y;
  }
  rotate (rotation) {
    this._currentRotation = rotation;
  }
}

class Text$1 extends BaseText$1 {
  result () {
    const result = getTextData$1(this);
    this._reset();

    return result
  }
}

class TextLayer$1 extends BaseText$1 {
  constructor () {
    super();
    this.marks = [];
  }

  markEnd () {
    const result = getTextData$1(this);
    this._reset();

    this.marks.push(result);
  }

  result () {
    const result = this.marks;
    this.marks = [];

    return result
  }
}

function getTextData$1 (self) {
  const result = self._currentStyle;
  result.style = `font:${self.font};`;
  result['dominant-baseline'] = self.textBaseline;
  result['text-anchor'] = self.textAlign === 'center' ? 'middle' : self.textAlign;

  if (self._currentRotation) {
    result.transform = getRotation(self._currentRotation, result.x, result.y);
  }

  return result
}

function circle$1 () {
  return new Circle$1()
}

function circleLayer$1 () {
  return new CircleLayer$1()
}

class BaseCircle$1 extends BaseContext {
  constructor () {
    super();
    this._currentStyle = {};
  }

  beginPath () {}
  arc (x, y, radius, sAngle, eAngle, counterclockwise) {
    this._currentStyle.cx = x;
    this._currentStyle.cy = y;
    this._currentStyle.r = radius;
  }
  setLineDash (dashArray) {
    this._strokeDashArray = dashArray.join(' ');
  }
}

class Circle$1 extends BaseCircle$1 {
  result () {
    const result = getCircleData$1(this);

    this._currentStyle = {};
    resetStyles(this, POINT_STYLES);

    return result
  }
}

class CircleLayer$1 extends BaseCircle$1 {
  constructor () {
    super();
    this.marks = [];
  }

  markEnd () {
    const result = getCircleData$1(this);
    this.marks.push(result);

    this._currentStyle = {};
    resetStyles(this, POINT_STYLES);
  }

  layerEnd () {
    if (anyStylesActive(this, POINT_STYLES)) {
      for (let i = 0; i < this.marks.length; i++) {
        attachStyles(this.marks[i], this, POINT_STYLES);
      }
    }
  }

  result () {
    const result = this.marks;
    this.marks = [];

    return result
  }
}

function getCircleData$1 (self) {
  const result = self._currentStyle;

  attachStyles(result, self, POINT_STYLES);

  return result
}

const POINT_STYLES = {
  fillStyle: 'fill',
  strokeStyle: 'stroke',
  lineWidth: 'stroke-width',
  _strokeDashArray: 'stroke-dasharray',
  lineDashOffset: 'stroke-dashoffset'
};

var svgStyled = /*#__PURE__*/Object.freeze({
  __proto__: null,
  path: path$1,
  pathLayer: pathLayer$1,
  text: text$1,
  textLayer: textLayer$1,
  circle: circle$1,
  circleLayer: circleLayer$1
});

function chain (...transformers) {
  const lastIndex = transformers.length - 1;

  let result = transformers[lastIndex];

  for (let i = lastIndex - 1; i >= 0; i--) {
    const transformer = transformers[i];

    if (transformer) {
      result = transformer(result);
    }
  }

  result.markEnd = transformers[lastIndex].markEnd
    ? transformers[lastIndex].markEnd.bind(transformers[lastIndex])
    : () => {};

  result.submarkStart = transformers[lastIndex].submarkStart
    ? transformers[lastIndex].submarkStart.bind(transformers[lastIndex])
    : () => {};

  return result
}

// Inspired by https://github.com/d3/d3-geo/blob/master/src/transform.js
function createTransformer (methods) {
  return function (stream) {
    const transformer = new Transformer(stream);

    for (const key in methods) {
      if (methods[key]) {
        transformer[key] = methods[key];
      }
    }

    return transformer
  }
}

function Transformer (stream) {
  this.stream = stream;
}

Transformer.prototype = {
  constructor: Transformer,
  // Stream
  point (x, y) { this.stream.point(x, y); },
  areaStart () { this.stream.areaStart(); },
  areaEnd () { this.stream.areaEnd(); },
  lineStart () { this.stream.lineStart(); },
  lineEnd () { this.stream.lineEnd(); },
  polygonStart () { this.stream.polygonStart(); },
  polygonEnd () { this.stream.polygonEnd(); },

  // Context
  beginPath () { this.stream.beginPath(); },
  moveTo () { this.stream.moveTo.apply(this.stream, arguments); },
  closePath () { this.stream.closePath(); },
  lineTo () { this.stream.lineTo.apply(this.stream, arguments); },
  quadraticCurveTo () { this.stream.quadraticCurveTo.apply(this.stream, arguments); },
  bezierCurveTo () { this.stream.quadraticCurveTo.apply(this.stream, arguments); },
  arc () { this.stream.arc.apply(this.stream, arguments); },
  arcTo () { this.stream.arcTo.apply(this.stream, arguments); },
  ellipse () { this.stream.ellipse.apply(this.stream, arguments); }
};

function split (...streams) {
  return {
    // Stream
    point (x, y) { streams.forEach(stream => stream.point(x, y)); },
    areaStart () { streams.forEach(stream => stream.areaStart()); },
    areaEnd () { streams.forEach(stream => stream.areaEnd()); },
    lineStart () { streams.forEach(stream => stream.lineStart()); },
    lineEnd () { streams.forEach(stream => stream.lineEnd()); },
    polygonStart () { streams.forEach(stream => stream.polygonStart()); },
    polygonEnd () { streams.forEach(stream => stream.polygonEnd()); },

    // Context
    beginPath () { streams.forEach(stream => stream.beginPath()); },
    moveTo (x, y) { streams.forEach(stream => stream.moveTo(x, y)); },
    closePath () { streams.forEach(stream => stream.closePath()); },
    lineTo (x, y) { streams.forEach(stream => stream.lineTo(x, y)); },
    quadraticCurveTo (...args) { streams.forEach(stream => stream.quadraticCurveTo.apply(stream, args)); },
    bezierCurveTo (...args) { streams.forEach(stream => stream.quadraticCurveTo.apply(stream, args)); },
    arc (...args) { streams.forEach(stream => stream.arc.apply(stream, args)); },
    arcTo (...args) { streams.forEach(stream => stream.arcTo.apply(stream, args)); }
  }
}

/**
 * Scales a value in the x-dimension and adds bandwidth. Should only be used in combination with d3scale.scaleBand.
 *
 * @param {*} value Value to be scaled.
 *
 * @return {function} A function that will return the scaled value.
 */
function x2 (value) {
  return ({ scaleX }) => scaleX(value) + scaleX.bandwidth()
}

/**
 * Scales a value in the y-dimension and adds bandwidth. Should only be used in combination with d3scale.scaleBand.
 *
 * @param {*} value Value to be scaled.
 *
 * @return {function} A function that will return the scaled value.
 */
function y2 (value) {
  return ({ scaleY }) => scaleY(value) + scaleY.bandwidth()
}

/**
 * Scales an array of values in the x-dimension and adds bandwidth. Should only be used in combination with d3scale.scaleBand.
 *
 * @param {Array} values Array of values to be scaled.
 *
 * @return {function} A function that will return an array of scaled values.
 */
function x2s (values) {
  return ({ scaleX }) => values.map(x => scaleX(x) + scaleX.bandwidth())
}

/**
 * Scales an array of values in the y-dimension and adds bandwidth. Should only be used in combination with d3scale.scaleBand.
 *
 * @param {Array} values Array of values to be scaled.
 *
 * @return {function} A function that will return an array of scaled values.
 */
function y2s (values) {
  return ({ scaleY }) => values.map(x => scaleY(x) + scaleY.bandwidth())
}

/**
 * Create x and y scales to fit bounding box while preserving aspect ratio.
 *
 * @param {Object} bbox
 * @param {number[]} bbox.x The x-extents of the bounding box.
 * @param {number[]} bbox.y The y-extents of the bounding box.
 *
 * @return {Object} An object containing a virtual scaleX and scaleY to be passed on to a section.
 */
function fitScales (bbox) {
  const domainX = bbox.x;
  const domainY = bbox.y;

  let rangeX;
  let rangeY;

  const scaleX = scaleLinear().domain(domainX);
  const scaleY = scaleLinear().domain(domainY);

  const setRangeX = range => {
    rangeX = range;
    updateRanges();
    return scaleX
  };

  const setRangeY = range => {
    rangeY = range;
    updateRanges();
    return scaleY
  };

  function updateRanges () {
    if (rangeX && rangeY) {
      const rangeDeltaX = Math.abs(rangeX[1] - rangeX[0]);
      const rangeDeltaY = Math.abs(rangeY[1] - rangeY[0]);

      const midX = (rangeX[0] + rangeX[1]) / 2;
      const midY = (rangeY[0] + rangeY[1]) / 2;

      const scalingFactorX = rangeDeltaX / (domainX[1] - domainX[0]);
      const scalingFactorY = rangeDeltaY / (domainY[1] - domainY[0]);

      if (scalingFactorX < scalingFactorY) {
        const fromMidY = (domainY[1] - domainY[0]) / 2 * scalingFactorX;
        const newRangeY = [midY - fromMidY, midY + fromMidY];

        if (rangeY[0] > rangeY[1]) newRangeY.reverse();

        scaleX.range(rangeX);
        scaleY.range(newRangeY);
      }

      if (scalingFactorX >= scalingFactorY) {
        const fromMidX = (domainX[1] - domainX[0]) / 2 * scalingFactorY;
        const newRangeX = [midX - fromMidX, midX + fromMidX];

        scaleX.range(newRangeX);
        scaleY.range(rangeY);
      }
    }
  }

  const dummyScaleObject = {
    scaleX: { range: setRangeX, copy: function () { return this } },
    scaleY: { range: setRangeY, copy: function () { return this } }
  };

  return dummyScaleObject
}

function getClipId (props, section) {
  const clipType = getClipType(props, section);

  if (clipType === 'padding') {
    return `clip-padding-${section.id}`
  }

  if (clipType === 'outer') {
    return `clip-outer-${section.id}`
  }
}

function getClipPathURL (props, section) {
  const clipId = getClipId(props, section);
  if (clipId === undefined) return

  return `url(#${clipId})`
}

function getClipType (props, section) {
  return props.clip !== undefined
    ? props.clip
    : section.clip
}

function bboxToClipRect ({ minX, minY, maxX, maxY }) {
  return {
    x: minX,
    y: minY,
    width: Math.max(maxX - minX, 0),
    height: Math.max(maxY - minY, 0)
  }
}

function bboxToClipArgs ({ minX, minY, maxX, maxY }) {
  return [
    minX,
    minY,
    maxX - minX,
    maxY - minY
  ]
}

let canvas;
let ctx;

function getCtx () {
  if (!ctx) {
    canvas = document.createElement('canvas');
    ctx = canvas.getContext('2d');
  }
  return ctx
}

function aestheticGetter (aesthetic, keys) {
  if (aesthetic === undefined) return () => undefined

  if (aesthetic.constructor === Array) {
    return i => aesthetic[i]
  }

  if (aesthetic.constructor === Function) {
    return keys
      ? i => aesthetic({ index: i, key: keys[i] })
      : i => aesthetic({ index: i, key: i })
  }

  return () => aesthetic
}

function batchAestheticGetter (props, aestheticNames, keys) {
  const aestheticGetters = {};

  for (const aestheticName of aestheticNames) {
    if (props[aestheticName] !== undefined) {
      aestheticGetters[aestheticName] = aestheticGetter(props[aestheticName], keys);
    }
  }

  return function (i) {
    const aesthetics = {};

    for (const aestheticName in aestheticGetters) {
      aesthetics[aestheticName] = aestheticGetters[aestheticName](i);
    }

    return aesthetics
  }
}

function areAllStylesGlobal (props, aestheticNames) {
  for (let i = 0; i < aestheticNames.length; i++) {
    const aestheticName = aestheticNames[i];

    if (props[aestheticName] === undefined) continue

    if (
      props[aestheticName].constructor === Array ||
      props[aestheticName].constructor === Function
    ) {
      return false
    }
  }

  return true
}

function pointInPolygon (point, polygon) {
  const x = point[0];
  const y = point[1];

  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i][0];
    const yi = polygon[i][1];
    const xj = polygon[j][0];
    const yj = polygon[j][1];

    const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }

  return inside
}

function hasStartAndEndCalls (context) {
  return 'markEnd' in context
}

function getClipBbox (props, section) {
  const clipType = getClipType$1(props, section);

  if (clipType === 'padding') {
    return section.paddedBbox
  }

  if (clipType === 'outer') {
    return section.bbox
  }
}

function getClip (props, section) {
  return clipArgs(getClipBbox(props, section))
}

function applyClipping (context, clipping) {
  context.beginPath();
  context.rect.apply(context, clipping);
  context.clip();
}

function applyPositioning (context, positioning) {
  for (let i = 0; i < positioning.call.length; i++) {
    context[positioning.call[i]].apply(context, positioning.args[i]);
  }
}

function getClipType$1 (props, section) {
  return props.clip !== undefined
    ? props.clip
    : section.clip
}

function clipArgs ({ minX, minY, maxX, maxY }) {
  return [
    minX,
    minY,
    maxX - minX,
    maxY - minY
  ]
}

let currentId = 0;

function getId () {
  return 'm' + currentId++
}

/** Creates new Mark object. */
class Mark {
  constructor (
    positioning,
    props,
    section,
    styler,
    type
  ) {
    this.positioning = positioning;
    this.props = props;
    this.section = section;
    this.styler = styler;
    this.type = type;
    this.id = getId();
  }

  /**
   * Render mark to context.
   * @param {Object} context A 2d canvas context, or some other rendervous context.
   */
  render (context) {
    context.save();

    hasStartAndEndCalls(context)
      ? this._renderWithStartAndEndCalls(context)
      : this._render(context);

    context.restore();
  }

  /**
   * Updates non-positioning props / aesthetics.
   * @param {Object} aesthetics An object containing the updated values
   */
  updateAesthetics (aesthetics) {
    for (const aestheticName in aesthetics) {
      this.props[aestheticName] = aesthetics[aestheticName];
    }
  }

  // Internal
  _renderWithStartAndEndCalls (context) {
    context.markStart();

    const clip = getClip(this.props, this.section);
    applyClipping(context, clip);

    applyPositioning(context, this.positioning);
    this.styler.apply(context, this.props);

    context.markEnd();
  }

  _render (context) {
    const clip = getClip(this.props, this.section);
    applyClipping(context, clip);

    context.beginPath();
    applyPositioning(context, this.positioning);
    this.styler.apply(context, this.props);
  }
}

class SpatialIndex {
  constructor (interactionHandler, getMark, getLayer) {
    this._rbush = new RBush();

    this._interactionHandler = interactionHandler;
    this._getMark = getMark.bind(interactionHandler);
    this._getLayer = getLayer.bind(interactionHandler);
  }

  indexMark (markId) {
    const mark = this._getMark(markId);
    this._rbush.load(mark);
  }

  unindexMark (markId) {
    const mark = this._getMark(markId);
    for (let i = 0; i < mark.length; i++) {
      this._rbush.remove(mark[i]);
    }
  }

  indexLayer (layerId) {
    const layer = this._getLayer(layerId);
    this._rbush.load(layer);
  }

  unindexLayer (layerId) {
    const layer = this._getLayer(layerId);
    for (let i = 0; i < layer.length; i++) {
      this._rbush.remove(layer[i]);
    }
  }

  queryMouseCoordinates ({ x, y }) {
    const potentialHits = this._rbush.search({ minX: x, maxX: x, minY: y, maxY: y });
    return this._getHits(x, y, potentialHits)
  }

  queryBoundingBox (boundingBox) {
    return this._rbush.search(boundingBox)
  }

  _getHits (x, y, potentialHits) {
    const ctx = getCtx();
    const hits = [];

    for (let i = 0; i < potentialHits.length; i++) {
      const potentialHit = potentialHits[i];

      ctx.beginPath();

      const isHit = potentialHit.data.constructor === Mark
        ? this._detectCollisionMark(x, y, potentialHit)
        : this._detectCollisionLayer(x, y, potentialHit);

      if (isHit) hits.push(potentialHit);
    }

    return hits
  }

  _detectCollisionMark (x, y, potentialHit) {
    const ctx = getCtx();

    if ('text' in potentialHit.data.props) {
      return detectCollisionText(x, y, potentialHit)
    }

    const markData = potentialHit.data;

    'segment' in potentialHit
      ? runCallsSegment(ctx, markData.positioning, potentialHit.segment)
      : runCalls(ctx, markData.positioning);

    const props = markData.props;

    if (hasFill(props)) {
      if (ctx.isPointInPath(x, y)) return true
    }

    if (hasStroke(props)) {
      ctx.lineWidth = props.strokeWidth;
      if (ctx.isPointInStroke(x, y)) return true
    }

    return false
  }

  _detectCollisionLayer (x, y, potentialHit) {
    const ctx = getCtx();

    if ('text' in potentialHit.data.props) {
      return detectCollisionText(x, y, potentialHit)
    }

    const layerData = potentialHit.data;
    const index = potentialHit.index;
    const positioning = layerData.positioning[index];

    'segment' in potentialHit
      ? runCallsSegment(ctx, positioning, potentialHit.segment)
      : runCalls(ctx, positioning);

    const props = batchAestheticGetter(
      layerData.props,
      ['fill', 'stroke', 'strokeWidth'],
      layerData.props.keys
    )(index);

    if (hasFill(props)) {
      if (ctx.isPointInPath(x, y)) return true
    }

    if (hasStroke(props)) {
      ctx.lineWidth = props.strokeWidth;
      if (ctx.isPointInStroke(x, y)) return true
    }

    return false
  }
}

const hasProp = prop => props => props[prop] && props[prop] !== 'none';
const hasFill = hasProp('fill');
const hasStroke = hasProp('stroke');

function runCallsSegment (context, positioning, segment) {
  const lastCoords = getLastCoords(positioning, segment);

  const thisCall = positioning.call[segment];
  const thisArgs = positioning.args[segment];

  const segmentPositioning = {
    call: ['moveTo', thisCall],
    args: [lastCoords, thisArgs]
  };

  runCalls(context, segmentPositioning);
}

function getLastCoords (callObj, segment) {
  const lastCall = callObj.call[segment - 1];
  const lastArgs = callObj.args[segment - 1];

  switch (lastCall) {
    case 'moveTo':
      return lastArgs
    case 'lineTo':
      return lastArgs
    case 'quadraticCurveTo':
      return [lastArgs[2], lastArgs[3]]
    case 'bezierCurveTo':
      return [lastArgs[4], lastArgs[5]]
    default:
      throw new Error(`Invalid last call: ${lastCall}`)
  }
}

function runCalls (context, positioning) {
  for (let i = 0; i < positioning.call.length; i++) {
    context[positioning.call[i]].apply(context, positioning.args[i]);
  }
}

// https://stackoverflow.com/a/67015797/7237112
function detectCollisionText (x, y, potentialHit) {
  const rotatedBbox = potentialHit.rotatedBbox;
  return pointInPolygon([x, y], rotatedBbox)
}

// Taken from https://github.com/rafgraph/detect-it/blob/main/src/index.ts

const w = typeof window !== 'undefined' ? window : { screen: {}, navigator: {} };
const matchMedia = w.matchMedia || (() => ({ matches: false }));
const options = {
  get passive () {
    return (true)
  }
};

const noop = () => {};
w.addEventListener && w.addEventListener('p', noop, options);
w.removeEventListener && w.removeEventListener('p', noop, false);

const onTouchStartInWindow = 'ontouchstart' in w;
const touchEventInWindow = 'TouchEvent' in w;

const supportsTouchEvents =
  onTouchStartInWindow || (touchEventInWindow && matchMedia('(any-pointer: coarse)').matches);

const hasTouch = (w.navigator.maxTouchPoints || 0) > 0 || supportsTouchEvents;

const userAgent = w.navigator.userAgent || '';

const isIPad =
  matchMedia('(pointer: coarse)').matches &&
  /iPad|Macintosh/.test(userAgent) &&
  Math.min(w.screen.width || 0, w.screen.height || 0) >= 768;

const hasCoarsePrimaryPointer =
  (matchMedia('(pointer: coarse)').matches ||
  (!matchMedia('(pointer: fine)').matches && onTouchStartInWindow)) &&
  !/Windows.*Firefox/.test(userAgent);

const hasAnyHoverOrAnyFinePointer =
  matchMedia('(any-pointer: fine)').matches ||
  matchMedia('(any-hover: hover)').matches ||
  isIPad || !onTouchStartInWindow;

const deviceType =
  hasTouch && (hasAnyHoverOrAnyFinePointer || !hasCoarsePrimaryPointer)
    ? 'hybrid'
    : hasTouch
      ? 'touchOnly'
      : 'mouseOnly';

const primaryInput =
  deviceType === 'mouseOnly'
    ? 'mouse'
    : deviceType === 'touchOnly'
      ? 'touch'
      : hasCoarsePrimaryPointer
        ? 'touch'
        : 'mouse';

let handler;
let _window;

function initWindow (w) {
  if (w) {
    _window = w;
  } else {
    _window = window;
  }
}

class EventTracker {
  constructor (eventManager, { eventName, nativeEventName, useWindow, preventDefault }) {
    this._eventManager = eventManager;
    this._eventName = eventName;
    this._nativeEventName = nativeEventName;
    this._useWindow = useWindow;
    this._preventDefault = preventDefault;

    this._numberOfActiveListeners = 0;
    this._callbacks = {};
  }

  setNativeEventName (nativeEventName) {
    this._nativeEventName = nativeEventName;
  }

  addListener (listenerId, callback) {
    this._callbacks[listenerId] = callback;

    if (this._eventManagerHasBeenMounted()) {
      this._attachNativeListenerIfNecessary();
    }
  }

  attachAllListeners () {
    /* eslint-disable-next-line */
    for (const _ in this._callbacks) {
      this._attachNativeListenerIfNecessary();
    }
  }

  removeListener (listenerId) {
    delete this._callbacks[listenerId];

    if (this._eventManagerHasBeenMounted()) {
      this._removeNativeListenerIfNecessary();
    }
  }

  _eventManagerHasBeenMounted () {
    return this._eventManager._mounted
  }

  _attachNativeListenerIfNecessary () {
    if (this._numberOfActiveListeners === 0) {
      handler = this._handleEvent.bind(this);
      const nativeEventName = this._nativeEventName;

      if (this._useWindow) {
        _window.addEventListener(nativeEventName, handler);
      }

      if (!this._useWindow) {
        this._eventManager._domNode.addEventListener(nativeEventName, handler);
      }
    }

    this._numberOfActiveListeners++;
  }

  _removeNativeListenerIfNecessary () {
    this._numberOfActiveListeners--;

    if (this._numberOfActiveListeners === 0) {
      const nativeEventName = this._nativeEventName;

      if (this._useWindow) {
        _window.removeEventListener(nativeEventName, handler);
      }

      if (!this._useWindow) {
        this._eventManager._domNode.removeEventListener(nativeEventName, handler);
      }
    }
  }

  _handleEvent (nativeEvent) {
    if (this._preventDefault) nativeEvent.preventDefault();

    const screenCoordinates = this._getScreenCoordinates(nativeEvent);
    nativeEvent.eventName = this._eventName;

    for (const listenerId in this._callbacks) {
      this._callbacks[listenerId](screenCoordinates, nativeEvent);
    }
  }

  _getScreenCoordinates (nativeEvent) {
    return this._eventManager._getScreenCoordinates(nativeEvent)
  }
}

class BaseEventManager {
  constructor (EXPOSED_EVENTS, managerType) {
    this._domNode = undefined;
    this._svgPoint = undefined;
    this._mounted = false;
    this._trackers = {};
    this._BROWSER_TYPE = undefined;
    this._managerType = managerType;

    for (const event of EXPOSED_EVENTS) {
      this._trackers[event.eventName] = new EventTracker(this, event);
    }
  }

  // Svelte can only bind to DOM nodes after initialization
  addRootNode (domNode, type) {
    this._domNode = domNode;

    if (type === 'svg') {
      this._svgPoint = this._domNode.createSVGPoint();
    }

    // set browser type only after mount
    this._BROWSER_TYPE = window.navigator.pointerEnabled
      ? 'IE11 / MSEdge'
      : window.navigator.msPointerEnabled
        ? 'IE10 / WP8'
        : 'other';

    this._mounted = true;
  }

  attachEventListeners () {
    if (this._mounted === false) throw new Error('root node must be added first')

    for (const eventName in this._trackers) {
      // set native event names here, just before attaching actual listeners
      if (this._managerType === 'mouse') {
        this._trackers[eventName].setNativeEventName(this._getNativeMouseEventName(eventName, this._BROWSER_TYPE));
      }
      if (this._managerType === 'touch') {
        this._trackers[eventName].setNativeEventName(this._getNativeTouchEventName(eventName, this._BROWSER_TYPE));
      }

      this._trackers[eventName].attachAllListeners();
    }
  }

  eventTracker (eventName) {
    return this._trackers[eventName]
  }
}

var capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);

class MouseEventManager extends BaseEventManager {
  constructor () {
    super(EXPOSED_EVENTS, 'mouse');
  }

  _getNativeMouseEventName (exposedEventName, BROWSER_TYPE) {
    // 'click' has the same name in every non-mobile browser
    if (exposedEventName === 'click') return 'click'

    // 'wheel' has the same name in every non-mobile browser
    if (exposedEventName === 'wheel') return 'wheel'

    // In this non-mobile browser type, events are called 'pointerup' etc
    if (BROWSER_TYPE === 'IE11 / MSEdge') {
      const lastPart = sliceOffMouse(exposedEventName);
      return 'pointer' + lastPart
    }

    // In this non-mobile browser type, events are called 'MSPointerUp' etc
    if (BROWSER_TYPE === 'IE10 / WP8') {
      const lastPart = sliceOffMouse(exposedEventName);
      return 'MSPointer' + capitalize(lastPart)
    }

    // In other non-mobile browsers, events are called like the exposed ones
    if (BROWSER_TYPE === 'other') {
      return exposedEventName
    }
  }

  _getScreenCoordinates (nativeEvent) {
    // SVG
    if (this._svgPoint) {
      this._svgPoint.x = nativeEvent.clientX;
      this._svgPoint.y = nativeEvent.clientY;

      return this._svgPoint.matrixTransform(this._domNode.getScreenCTM().inverse())
    }

    // Canvas
    // ????
    const rect = this._domNode.getBoundingBoxClientRect
      ? this._domNode.getBoundingBoxClientRect()
      : this._domNode.getBoundingClientRect();

    const x = nativeEvent.clientX - rect.left;
    const y = nativeEvent.clientY - rect.top;

    return { x, y }
  }
}

const EVENT_NAMES = ['mousedown', 'mouseup', 'mousemove', 'mouseout', 'click', 'wheel'];
const WINDOW_EVENTS = ['mousemove', 'mouseup'];
const PREVENT_DEFAULT = ['mousedown'];

const EXPOSED_EVENTS = EVENT_NAMES.map(eventName => ({
  eventName,
  nativeEventName: undefined,
  useWindow: WINDOW_EVENTS.includes(eventName),
  preventDefault: PREVENT_DEFAULT.includes(eventName)
}));

const sliceOffMouse = str => str.slice(5, str.length);

class TouchEventManager extends BaseEventManager {
  constructor () {
    super(EXPOSED_EVENTS$1, 'touch');
  }

  _getNativeTouchEventName (exposedEventName, BROWSER_TYPE) {
    // In this mobile browser type, events are called 'pointerup' etc
    if (BROWSER_TYPE === 'IE11 / MSEdge') {
      const lastPart = sliceOffTouch(exposedEventName);
      return 'pointer' + lastPart
    }

    // In this mobile browser type, events are called 'MSPointerUp' etc
    if (BROWSER_TYPE === 'IE10 / WP8') {
      const lastPart = sliceOffTouch(exposedEventName);
      return 'MSPointer' + capitalize(lastPart)
    }

    // In other mobile browsers, events are called like the exposed ones
    if (BROWSER_TYPE === 'other') {
      return exposedEventName
    }
  }

  _getScreenCoordinates (nativeEvent) {
    const touches = getTouches(nativeEvent);

    if (touches.length === 1) {
      return this._getScreenCoordinatesSingle(touches[0])
    }

    if (touches.length > 1) {
      return this._getScreenCoordinatesMulti(touches)
    }
  }

  _getScreenCoordinatesSingle (touch) {
    // SVG
    if (this._svgPoint) {
      this._svgPoint.x = touch.clientX;
      this._svgPoint.y = touch.clientY;

      return this._svgPoint.matrixTransform(this._domNode.getScreenCTM().inverse())
    }

    // Canvas
    // ????
    const rect = this._domNode.getBoundingBoxClientRect
      ? this._domNode.getBoundingBoxClientRect()
      : this._domNode.getBoundingClientRect();

    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    return { x, y }
  }

  _getScreenCoordinatesMulti (touches) {
    const touchesInScreenCoordinates = [];

    for (const touch of touches) {
      touchesInScreenCoordinates.push(this._getScreenCoordinatesSingle(touch));
    }

    return touchesInScreenCoordinates
  }
}

const EVENT_NAMES$1 = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];

const EXPOSED_EVENTS$1 = EVENT_NAMES$1.map(eventName => ({
  eventName,
  nativeEventName: undefined,
  useWindow: false,
  preventDefault: true
}));

const sliceOffTouch = str => str.slice(5, str.length);

function getTouches (nativeEvent) {
  return nativeEvent.touches
}

class EventManager {
  constructor () {
    if (primaryInput === 'mouse') {
      this._mouseEventManager = new MouseEventManager();
    }

    if (primaryInput === 'touch') {
      this._touchEventManager = new TouchEventManager();
    }
  }

  // Initialization
  addRootNode (domNode, type, w) {
    this._forEachManager(manager => { manager.addRootNode(domNode, type); });
    initWindow(w);
  }

  attachEventListeners () {
    this._forEachManager(manager => { manager.attachEventListeners(); });
  }

  mouse () {
    return this._mouseEventManager
  }

  touch () {
    return this._touchEventManager
  }

  _forEachManager (callback) {
    if (this._mouseEventManager) callback(this._mouseEventManager);
    if (this._touchEventManager) callback(this._touchEventManager);
  }
}

class BaseInteractionManager {
  constructor () {
    this._id = undefined;
    this._eventManager = undefined;

    this._section = undefined;

    this._markInteractionInterface = undefined;
    this._sectionInteractionInterface = undefined;
  }

  // Initialization
  setId (id) {
    this._id = id;
  }

  linkEventManager (eventManager) {
    this._eventManager = eventManager;
  }

  // Section context loading
  loadSection (sectionData) {
    this._section = sectionData;
  }

  // Mark and layer interactions interface
  marks () {
    return this._markInteractionInterface
  }

  // Section interactions interface
  section () {
    return this._sectionInteractionInterface
  }
}

class BaseInteractionInterface {
  constructor (interactionManager, InteractionHandlers) {
    this._interactionManager = interactionManager;
    this._handlers = {};

    for (const handlerName in InteractionHandlers) {
      this._handlers[handlerName] = new InteractionHandlers[handlerName](this._interactionManager);
    }
  }

  _getHandler (interactionName) {
    const handlerName = interactionNameToHandlerName(interactionName);
    return this._handlers[handlerName]
  }
}

const interactionNameToHandlerName = interactionName => {
  return capitalize(interactionName) + 'Handler'
};

// https://stackoverflow.com/a/55388272
const PI = Math.PI;
const HALF_PI = Math.PI / 2;
const TWO_PI = Math.PI * 2;

function getArcBbox (cx, cy, radius, _startAngle, _endAngle, counterclockwise) {
  if (_startAngle === 0 && _endAngle === TWO_PI) {
    return {
      minX: cx - radius,
      maxX: cx + radius,
      minY: cy - radius,
      maxY: cy + radius
    }
  }

  let startAngle = _startAngle;
  let endAngle = _endAngle;

  if (counterclockwise) {
    startAngle = _endAngle;
    endAngle = _startAngle;
  }

  const iniQuad = getQuadrant(startAngle);
  const endQuad = getQuadrant(endAngle);

  const ix = Math.cos(startAngle) * radius;
  const iy = Math.sin(startAngle) * radius;
  const ex = Math.cos(endAngle) * radius;
  const ey = Math.sin(endAngle) * radius;

  const minX = Math.min(ix, ex);
  const minY = Math.min(iy, ey);
  const maxX = Math.max(ix, ex);
  const maxY = Math.max(iy, ey);

  const r = radius;
  const xMax = [[maxX, r, r, r], [maxX, maxX, r, r], [maxX, maxX, maxX, r], [maxX, maxX, maxX, maxX]];
  const yMax = [[maxY, maxY, maxY, maxY], [r, maxY, r, r], [r, maxY, maxY, r], [r, maxY, maxY, maxY]];
  const xMin = [[minX, -r, minX, minX], [minX, minX, minX, minX], [-r, -r, minX, -r], [-r, -r, minX, minX]];
  const yMin = [[minY, -r, -r, minY], [minY, minY, -r, minY], [minY, minY, minY, minY], [-r, -r, -r, minY]];

  const x1 = xMin[endQuad][iniQuad];
  const y1 = yMin[endQuad][iniQuad];
  const x2 = xMax[endQuad][iniQuad];
  const y2 = yMax[endQuad][iniQuad];

  return {
    minX: x1 + cx,
    maxX: x2 + cx,
    minY: y1 + cy,
    maxY: y2 + cy
  }
}

function getQuadrant (_angle) {
  const angle = _angle % (TWO_PI);

  if (angle > 0.0 && angle < HALF_PI) return 0
  if (angle >= HALF_PI && angle < PI) return 1
  if (angle >= PI && angle < PI + HALF_PI) return 2
  return 3
}

function applyLWAndClipping (bbox, props, section) {
  const useLineWidth = props.stroke && props.stroke !== 'none';

  if (useLineWidth) {
    applyMargin(bbox, props.strokeWidth / 2);
  }

  const clipBbox = getClipBbox(props, section);
  applyClip(bbox, clipBbox);

  return bbox
}

function applyMargin (bbox, margin) {
  bbox.minX -= margin;
  bbox.maxX += margin;
  bbox.minY -= margin;
  bbox.maxY += margin;
}

function applyClip (bbox, clipBbox) {
  bbox.minX = clamp(bbox.minX, clipBbox.minX, clipBbox.maxX);
  bbox.maxX = clamp(bbox.maxX, clipBbox.minX, clipBbox.maxX);
  bbox.minY = clamp(bbox.minY, clipBbox.minY, clipBbox.maxY);
  bbox.maxY = clamp(bbox.maxY, clipBbox.minY, clipBbox.maxY);
}

const clamp = (n, min, max) => Math.min(Math.max(n, min), max);

function bboxPoint (mark) {
  const { positioning, props, section } = mark;
  return [getBbox(positioning, props, section)]
}

function bboxPointLayer (layer) {
  const layerBboxes = [];

  const { props, section } = layer;

  const getAesthetics = batchAestheticGetter(props, ['stroke', 'strokeWidth'], props.keys);

  for (let i = 0; i < layer.positioning.length; i++) {
    const bbox = getBbox(
      layer.positioning[i],
      getAesthetics(i),
      section
    );

    bbox.index = i;

    layerBboxes.push(bbox);
  }

  return layerBboxes
}

function getBbox (positioning, props, section) {
  for (let i = 0; i < positioning.call.length; i++) {
    if (positioning.call[i] === 'arc') {
      const bbox = getArcBbox.apply(null, positioning.args[i]);

      return applyLWAndClipping(
        bbox,
        props,
        section
      )
    }
  }
}

function attach (bboxes, stuffToAttach) {
  for (let i = 0; i < bboxes.length; i++) {
    const bbox = bboxes[i];

    for (const stuffKey in stuffToAttach) {
      bbox[stuffKey] = stuffToAttach[stuffKey];
    }
  }
}

function attachWithKeys (bboxes, stuffToAttach, keys) {
  for (let i = 0; i < bboxes.length; i++) {
    const bbox = bboxes[i];

    for (const stuffKey in stuffToAttach) {
      bbox[stuffKey] = stuffToAttach[stuffKey];
    }

    bbox.key = keys[bbox.index];
  }
}

function indexPoint (mark) {
  const bboxes = bboxPoint(mark);
  attach(bboxes, { data: mark });

  return bboxes
}

function indexPointLayer (layer) {
  const bboxes = bboxPointLayer(layer);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function getBbox$1 (x0, x1, y0, y1) {
  return {
    minX: Math.min(x0, x1),
    maxX: Math.max(x0, x1),
    minY: Math.min(y0, y1),
    maxY: Math.max(y0, y1)
  }
}

// https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Quadratic_B%C3%A9zier_curves
function evalQuadratic (p0, p1, p2, t) {
  return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2
}

function evalCubic (p0, p1, p2, p3, t) {
  return (
    p0 * (1 - t) * (1 - t) * (1 - t) + 3 * p1 * t * (1 - t) *
    (1 - t) + 3 * p2 * t * t * (1 - t) + p3 * t * t * t
  )
}

// https://stackoverflow.com/a/24814530
function getBezierBbox (p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
  let a = 3 * p3x - 9 * p2x + 9 * p1x - 3 * p0x;
  let b = 6 * p0x - 12 * p1x + 6 * p2x;
  let c = 3 * p1x - 3 * p0x;

  let disc = b * b - 4 * a * c;
  let xl = p0x;
  let xh = p0x;
  if (p3x < xl) xl = p3x;
  if (p3x > xh) xh = p3x;
  if (disc >= 0) {
    const t1 = (-b + Math.sqrt(disc)) / (2 * a);

    if (t1 > 0 && t1 < 1) {
      const x1 = evalCubic(p0x, p1x, p2x, p3x, t1);
      if (x1 < xl) xl = x1;
      if (x1 > xh) xh = x1;
    }

    const t2 = (-b - Math.sqrt(disc)) / (2 * a);

    if (t2 > 0 && t2 < 1) {
      const x2 = evalCubic(p0x, p1x, p2x, p3x, t2);
      if (x2 < xl) xl = x2;
      if (x2 > xh) xh = x2;
    }
  }

  a = 3 * p3y - 9 * p2y + 9 * p1y - 3 * p0y;
  b = 6 * p0y - 12 * p1y + 6 * p2y;
  c = 3 * p1y - 3 * p0y;
  disc = b * b - 4 * a * c;

  let yl = p0y;
  let yh = p0y;

  if (p3y < yl) yl = p3y;
  if (p3y > yh) yh = p3y;
  if (disc >= 0) {
    const t1 = (-b + Math.sqrt(disc)) / (2 * a);

    if (t1 > 0 && t1 < 1) {
      const y1 = evalCubic(p0y, p1y, p2y, p3y, t1);
      if (y1 < yl) yl = y1;
      if (y1 > yh) yh = y1;
    }

    const t2 = (-b - Math.sqrt(disc)) / (2 * a);

    if (t2 > 0 && t2 < 1) {
      const y2 = evalCubic(p0y, p1y, p2y, p3y, t2);
      if (y2 < yl) yl = y2;
      if (y2 > yh) yh = y2;
    }
  }

  return getBbox$1(xl, xh, yl, yh)
}

// https://stackoverflow.com/a/63059651
function quadraticToCubic (x1, y1, cpx, cpy, x2, y2) {
  return [
    x1 / 3 + (2 / 3) * cpx,
    y1 / 3 + (2 / 3) * cpy,
    x2 / 3 + (2 / 3) * cpx,
    y2 / 3 + (2 / 3) * cpy,
    x2,
    y2
  ]
}

function getQuadraticBbox (x0, y0, x1, y1, x2, y2) {
  return getBezierBbox.apply(
    null,
    quadraticToCubic(x0, y0, x1, y1, x2, y2)
  )
}

function getEllipseBbox (x, y, rx, ry, rot, a0, a1, ccw) {
  if (rot !== 0) throw Error('Rotation not supported yet')

  const dimRatio = rx / ry;
  const r = dimRatio > 1 ? rx : ry;

  const bbox = getArcBbox(x, y, r, a0, a1, ccw);
  rescaleBbox(bbox, dimRatio);

  return bbox
}

function getEllipseEndCoords (x, y, rx, ry, rot, a0, a1) {
  const endX = Math.cos(a1) * rx;
  const endY = Math.sin(a1) * ry;

  return [x + endX, y + endY]
}

function rescaleBbox (bbox, dimRatio) {
  if (dimRatio < 1) {
    const cx = (bbox.minX + bbox.maxX) / 2;
    const dxMin = cx - bbox.minX;
    const dxMax = bbox.maxX - cx;

    bbox.minX = cx - (dxMin * dimRatio);
    bbox.maxX = cx + (dxMax * dimRatio);
  }

  if (dimRatio > 1) {
    const cy = (bbox.minY + bbox.maxY) / 2;
    const dyMin = cy - bbox.minY;
    const dyMax = bbox.maxY - cy;

    bbox.minY = cy - (dyMin / dimRatio);
    bbox.maxY = cy + (dyMax / dimRatio);
  }
}

function updateBbox (bbox, x, y) {
  bbox.minX = x < bbox.minX ? x : bbox.minX;
  bbox.maxX = x > bbox.maxX ? x : bbox.maxX;
  bbox.minY = y < bbox.minY ? y : bbox.minY;
  bbox.maxY = y > bbox.maxY ? y : bbox.maxY;
}

function updateBboxWithBbox (bbox, { minX, maxX, minY, maxY }) {
  bbox.minX = minX < bbox.minX ? minX : bbox.minX;
  bbox.maxX = maxX > bbox.maxX ? maxX : bbox.maxX;
  bbox.minY = minY < bbox.minY ? minY : bbox.minY;
  bbox.maxY = maxY > bbox.maxY ? maxY : bbox.maxY;
}

/* eslint-disable no-case-declarations */

function bboxPolygon (mark) {
  const bboxes = [];

  const { positioning, props, section } = mark;

  const submarks = positioning.submarks.length
    ? positioning.submarks
    : [0];

  for (let i = 0; i < submarks.length; i++) {
    const submarkStart = submarks[i];
    const submarkEnd = submarks[i + 1] || positioning.call.length;

    bboxes.push(getBboxOfRange(
      positioning,
      props,
      section,
      submarkStart,
      submarkEnd
    ));
  }

  return bboxes
}

function bboxPolygonLayer (layer) {
  const layerBboxes = [];

  const { props, section } = layer;

  const getAesthetics = batchAestheticGetter(props, ['stroke', 'strokeWidth'], props.keys);

  for (let i = 0; i < layer.positioning.length; i++) {
    const positioning = layer.positioning[i];

    const submarks = positioning.submarks.length
      ? positioning.submarks
      : [0];

    for (let j = 0; j < submarks.length; j++) {
      const submarkStart = submarks[j];
      const submarkEnd = submarks[j + 1] || positioning.call.length;

      const bbox = getBboxOfRange(
        positioning,
        getAesthetics(i),
        section,
        submarkStart,
        submarkEnd
      );

      bbox.index = i;

      layerBboxes.push(bbox);
    }
  }

  return layerBboxes
}

function getBboxOfRange (
  positioning,
  props,
  section,
  start,
  end
) {
  const bbox = {
    minX: Infinity,
    maxX: -Infinity,
    minY: Infinity,
    maxY: -Infinity
  };

  let numberOfMoveTos = 0;
  let lastX;
  let lastY;

  for (let i = start; i < end; i++) {
    const call = positioning.call[i];
    const args = positioning.args[i];

    switch (call) {
      case 'moveTo':
        // This ignores holes
        numberOfMoveTos++;

        if (numberOfMoveTos === 2) {
          return applyLWAndClipping(
            bbox,
            props,
            section
          )
        }

        lastX = args[0];
        lastY = args[1];
        break
      case 'lineTo':
        updateBbox(bbox, lastX, lastY);
        lastX = args[0];
        lastY = args[1];
        updateBbox(bbox, lastX, lastY);
        break
      case 'quadraticCurveTo':
        updateBboxWithBbox(
          bbox,
          getQuadraticBbox(lastX, lastY, ...args)
        );
        lastX = args[2];
        lastY = args[3];
        break
      case 'bezierCurveTo':
        updateBboxWithBbox(
          bbox,
          getBezierBbox(lastX, lastY, ...args)
        );
        lastX = args[4];
        lastY = args[5];
        break
      case 'ellipse':
        updateBboxWithBbox(
          bbox,
          getEllipseBbox.apply(null, args)
        );
        const endCoords = getEllipseEndCoords.apply(null, args);
        lastX = endCoords[0];
        lastY = endCoords[1];
        break
    }
  }

  return applyLWAndClipping(
    bbox,
    props,
    section
  )
}

function indexRectangle (mark) {
  const bboxes = bboxPolygon(mark);
  attach(bboxes, { data: mark });

  return bboxes
}

function indexRectangleLayer (layer) {
  const bboxes = bboxPolygonLayer(layer);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function indexPolygon (mark) {
  const bboxes = bboxPolygon(mark);
  attach(bboxes, { data: mark });

  return bboxes
}

function indexPolygonLayer (layer) {
  const bboxes = bboxPolygonLayer(layer);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function bboxLabel (mark) {
  const { positioning, props, section } = mark;
  return [getBbox$2(positioning, props, section)]
}

function bboxLabelLayer (layer) {
  const layerBboxes = [];

  const { props, section } = layer;

  const getAesthetics = batchAestheticGetter(
    props,
    ['text', 'fontSize', 'rotate', 'anchorPoint', 'stroke', 'strokeWidth'],
    props.keys
  );

  for (let i = 0; i < layer.positioning.length; i++) {
    const bbox = getBbox$2(
      layer.positioning[i],
      getAesthetics(i),
      section
    );

    bbox.index = i;

    layerBboxes.push(bbox);
  }

  return layerBboxes
}

function getBbox$2 (positioning, props, section) {
  const ctx = getCtx();
  ctx.save();

  const width = ctx.measureText(props.text).width;
  const height = props.fontSize;
  const [x0, y0] = getXY0(props, width, height);
  const x1 = x0 + width;
  const y1 = y0 + height;

  const bboxAround0Points = [
    [x0, y0],
    [x1, y0],
    [x1, y1],
    [x0, y1]
  ];

  ctx.translate.apply(ctx, positioning.args[0]);
  ctx.rotate(props.rotate);

  // Again, necessary bc of unit tests (getTransform not defined in canvas package)
  const transformation = ctx.getTransform
    ? ctx.getTransform()
    : ctx.currentTransform;

  const rotatedPoints = bboxAround0Points.map(([x, y]) => {
    const rotatedPoint = transformation.transformPoint({ x, y });
    return [rotatedPoint.x, rotatedPoint.y]
  });

  ctx.restore();

  const bboxRotatedPoints = getBboxPoints(rotatedPoints);
  const bbox = applyLWAndClipping(bboxRotatedPoints, props, section);
  bbox.rotatedBbox = rotatedPoints;

  return bbox
}

function getXY0 ({ anchorPoint }, w, h) {
  const x = anchorPoint.startsWith('l')
    ? 0
    : anchorPoint.startsWith('r')
      ? -w
      : -w / 2;

  const y = anchorPoint.endsWith('t')
    ? 0
    : anchorPoint.endsWith('b')
      ? -h
      : -h / 2;

  return [x, y]
}

function getBboxPoints (points) {
  const bbox = {
    minX: Infinity,
    maxX: -Infinity,
    minY: Infinity,
    maxY: -Infinity
  };

  for (let i = 0; i < points.length; i++) {
    const [x, y] = points[i];
    updateBbox(bbox, x, y);
  }

  return bbox
}

function indexLabel (mark) {
  const bboxes = bboxLabel(mark);
  attach(bboxes, { data: mark });

  return bboxes
}

function indexLabelLayer (layer) {
  const bboxes = bboxLabelLayer(layer);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function bboxLine (mark) {
  const { positioning, props, section } = mark;
  return getBboxes(positioning, props, section)
}

function bboxLineLayer (layer) {
  const layerBboxes = [];

  const { props, section } = layer;

  const getAesthetics = batchAestheticGetter(props, ['stroke', 'strokeWidth'], props.keys);

  for (let i = 0; i < layer.positioning.length; i++) {
    const bboxes = getBboxes(
      layer.positioning[i],
      getAesthetics(i),
      section
    );

    for (let j = 0; j < bboxes.length; j++) {
      bboxes[j].index = i;
      layerBboxes.push(bboxes[j]);
    }
  }

  return layerBboxes
}

function getBboxes (positioning, props, section) {
  const bboxes = [];

  let lastX;
  let lastY;

  let bbox;

  for (let i = 0; i < positioning.call.length; i++) {
    const call = positioning.call[i];
    const args = positioning.args[i];

    switch (call) {
      case 'moveTo':
        lastX = args[0];
        lastY = args[1];
        break
      case 'lineTo':
        bbox = applyLWAndClipping(
          getBbox$1(lastX, args[0], lastY, args[1]),
          props,
          section
        );

        bbox.segment = i;

        bboxes.push(bbox);

        lastX = args[0];
        lastY = args[1];
        break
      case 'quadraticCurveTo':
        bbox = applyLWAndClipping(
          getQuadraticBbox(lastX, lastY, ...args),
          props,
          section
        );

        bbox.segment = i;

        bboxes.push(bbox);

        lastX = args[2];
        lastY = args[3];
        break
      case 'bezierCurveTo':
        bbox = applyLWAndClipping(
          getBezierBbox(lastX, lastY, ...args),
          props,
          section
        );

        bbox.segment = i;

        bboxes.push(bbox);

        lastX = args[4];
        lastY = args[5];
        break
    }
  }

  return bboxes
}

function indexLine (mark) {
  const bboxes = bboxLine(mark);
  attach(bboxes, { data: mark });

  return bboxes
}

function indexLineLayer (layer) {
  const bboxes = bboxLineLayer(layer);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function indexArea (mark) {
  const bboxes = bboxPolygon(mark);
  attach(bboxes, { data: mark });

  return bboxes
}

function indexAreaLayer (layer) {
  const bboxes = bboxPolygonLayer(layer);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function indexSymbol (mark) {
  const bboxes = bboxPolygon(mark);
  attach(bboxes, { data: mark });

  return bboxes
}

function indexSymbolLayer (layer) {
  const bboxes = bboxPolygonLayer(layer);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

const markIndexing = {
  Point: indexPoint,
  Rectangle: indexRectangle,
  Polygon: indexPolygon,
  Line: indexLine,
  Area: indexArea,
  Symbol: indexSymbol,
  Label: indexLabel,
  FuncLine: indexLine
};

const layerIndexing = {
  Point: indexPointLayer,
  Rectangle: indexRectangleLayer,
  Polygon: indexPolygonLayer,
  Line: indexLineLayer,
  Label: indexLabelLayer,
  Area: indexAreaLayer,
  Symbol: indexSymbolLayer
};

class MarkInteractionInterface extends BaseInteractionInterface {
  constructor (interactionManager, InteractionHandlers) {
    super(interactionManager, InteractionHandlers);

    this._indexableMarks = {};
    this._indexableLayers = {};
  }

  // Mark loading and removing
  loadMark (mark) {
    const indexingFunction = markIndexing[mark.type];
    const indexableMark = indexingFunction(mark);

    const markId = mark.id;
    this._indexableMarks[markId] = indexableMark;
  }

  markIsLoaded ({ id }) {
    return id in this._indexableMarks
  }

  removeMark ({ id }) {
    delete this._indexableMarks[id];
  }

  // Layer loading and removing
  loadLayer (layer) {
    const indexingFunction = layerIndexing[layer.type];
    const indexableLayer = indexingFunction(layer);

    const layerId = layer.id;
    this._indexableLayers[layerId] = indexableLayer;
  }

  layerIsLoaded ({ id }) {
    return id in this._indexableLayers
  }

  removeLayer ({ id }) {
    delete this._indexableLayers[id];
  }

  // Add/remove mark interactions
  addMarkInteraction (interactionName, { id }, callback) {
    this._getHandler(interactionName).addMarkInteraction(id, callback);
  }

  removeAllMarkInteractions ({ id }) {
    for (const handlerName in this._handlers) {
      const handler = this._handlers[handlerName];

      if (handler.hasMark(id)) {
        handler.removeMarkInteraction(id);
      }
    }
  }

  // Add/remove layer interactions
  addLayerInteraction (interactionName, { id }, callback) {
    this._getHandler(interactionName).addLayerInteraction(id, callback);
  }

  removeAllLayerInteractions ({ id }) {
    for (const handlerName in this._handlers) {
      const handler = this._handlers[handlerName];

      if (handler.hasLayer(id)) {
        handler.removeLayerInteraction(id);
      }
    }
  }
}

class SectionInteractionInterface extends BaseInteractionInterface {
  addInteraction (interactionName, callback) {
    this._getHandler(interactionName).addInteraction(callback);
  }

  removeAllInteractions () {
    for (const handlerName in this._handlers) {
      const handler = this._handlers[handlerName];

      if (handler.hasInteraction()) {
        handler.removeInteraction();
      }
    }
  }
}

class BaseInteractionHandler {
  constructor (interactionManager, { eventName, interactionName }) {
    this._interactionManager = interactionManager;
    this._eventName = eventName;
    this._interactionName = interactionName;
  }

  interactionManager () {
    return this._interactionManager
  }

  eventManager () {
    return this._interactionManager._eventManager
  }

  section () {
    return this._interactionManager._section
  }

  id () {
    return this._interactionManager._id
  }

  _addEventListener () {
    const handler = this._handleEvent.bind(this);

    const eventManager = this.eventManager();
    const listenerId = this.getId();

    const events = isArray(this._eventName) ? this._eventName : [this._eventName];

    for (const event of events) {
      eventManager
        .eventTracker(event)
        .addListener(listenerId, handler);
    }
  }

  _removeEventListener () {
    const eventManager = this.eventManager();
    const listenerId = this.getId();

    const events = isArray(this._eventName) ? this._eventName : [this._eventName];

    for (const event of events) {
      eventManager
        .eventTracker(event)
        .removeListener(listenerId);
    }
  }
}

function isArray (value) {
  return value.constructor === Array
}

class MarkInteractionHandler extends BaseInteractionHandler {
  constructor (interactionManager, options) {
    super(interactionManager, options);

    const getMark = function (markId) {
      return this._interactionManager.marks()._indexableMarks[markId]
    };

    const getLayer = function (layerId) {
      return this._interactionManager.marks()._indexableLayers[layerId]
    };

    this._spatialIndex = new SpatialIndex(this, getMark, getLayer);

    this._numberOfInteractions = 0;

    this._markCallbacks = {};
    this._layerCallbacks = {};
  }

  // Add/remove mark interactions
  addMarkInteraction (markId, callback) {
    this._addEventListenerIfNecessary();
    this._numberOfInteractions++;
    this._markCallbacks[markId] = callback;

    this._spatialIndex.indexMark(markId);
  }

  hasMark (markId) {
    return markId in this._markCallbacks
  }

  removeMarkInteraction (markId) {
    this._removeEventListenerIfNecessary();
    delete this._markCallbacks[markId];
    this._numberOfInteractions--;

    this._spatialIndex.unindexMark(markId);
  }

  // Add/remove layer interactions
  addLayerInteraction (layerId, callback) {
    if (!(layerId in this._layerCallbacks)) {
      this._addEventListenerIfNecessary();
      this._numberOfInteractions++;
      this._layerCallbacks[layerId] = callback;

      this._spatialIndex.indexLayer(layerId);
    }
  }

  hasLayer (layerId) {
    return layerId in this._layerCallbacks
  }

  removeLayerInteraction (layerId) {
    if (layerId in this._layerCallbacks) {
      this._numberOfInteractions--;
      delete this._layerCallbacks[layerId];
      this._removeEventListenerIfNecessary();

      this._spatialIndex.unindexLayer(layerId);
    }
  }

  _addEventListenerIfNecessary () {
    if (this._numberOfInteractions === 0) {
      this._addEventListener();
    }
  }

  _removeEventListenerIfNecessary () {
    if (this._numberOfInteractions === 0) {
      this._removeEventListener();
    }
  }

  getId () {
    return `${this.id()}-mark-${this._interactionName}`
  }
}

function createMarkEvent (eventType, eventOptions, hit, nativeEvent) {
  eventOptions.markType = hit.data.type;
  eventOptions.hitBbox = extractBbox(hit);
  eventOptions.hitSource = 'mark';

  return createEvent(eventType, eventOptions, nativeEvent)
}

function createLayerEvent (eventType, eventOptions, hit, nativeEvent) {
  eventOptions.markType = hit.data.type;
  eventOptions.hitBbox = extractBbox(hit);
  eventOptions.key = hit.key;
  eventOptions.index = hit.index;
  eventOptions.hitSource = 'layer';

  return createEvent(eventType, eventOptions, nativeEvent)
}

function createSectionEvent (eventType, eventOptions, nativeEvent) {
  eventOptions.hitSource = 'section';

  return createEvent(eventType, eventOptions, nativeEvent)
}

function extractBbox (hit) {
  return { minX: hit.minX, maxX: hit.maxX, minY: hit.minY, maxY: hit.maxY }
}

function createEvent (eventType, eventOptions, nativeEvent) {
  const event = eventOptions;

  event.type = eventType;
  event.nativeType = nativeEvent.type;

  for (const key of INTERESTING_NATIVE_KEYS) {
    event[key] = nativeEvent[key];
  }

  return event
}

const INTERESTING_NATIVE_KEYS = [
  'altKey', 'ctrlKey', 'shiftKey',
  'clientX', 'clientY',
  'pageX', 'pageY',
  'screenX', 'screenY',
  'timeStamp'
];

function createSelectMarkEvent (eventType, hit) {
  const event = {
    type: eventType,
    markType: hit.data.type,
    hitSource: 'mark'
  };

  return event
}

function createSelectLayerEvent (eventType, hit) {
  const event = {
    type: eventType,
    markType: hit.data.type,
    key: hit.key,
    index: hit.index,
    hitSource: 'layer'
  };

  return event
}

function getLocalCoordinates (screenCoordinates, interactionManager) {
  const section = interactionManager._section;
  const inverseTotalTransformation = section.inverseTotalTransformation;

  const { minX, maxX, minY, maxY } = section.paddedBbox;

  const clampedX = clamp$1(screenCoordinates.x, minX, maxX);
  const clampedY = clamp$1(screenCoordinates.y, minY, maxY);

  const [localX, localY] = inverseTotalTransformation([clampedX, clampedY]);

  return { x: localX, y: localY }
}

function clamp$1 (value, min, max) {
  return Math.max(min, Math.min(value, max))
}

let currentId$1 = 0;

function getId$1 () {
  return 'l' + currentId$1++
}

/** Creates new Layer object. */
class Layer {
  constructor (
    positioning,
    props,
    section,
    styler,
    type
  ) {
    this.positioning = positioning;
    this.props = props;
    this.section = section;
    this.styler = styler;
    this.type = type;
    this.id = getId$1();
  }

  /**
   * Render layer to context.
   * @param {Object} context A 2d canvas context, or some other rendervous context.
   */
  render (context) {
    context.save();

    hasStartAndEndCalls(context)
      ? this._renderWithStartAndEndCalls(context)
      : this._render(context);

    context.restore();
  }

  /**
   * Updates non-positioning props / aesthetics.
   * @param {Object} aesthetics An object containing the updated values
   */
  updateAesthetics (aesthetics) {
    for (const aestheticName in aesthetics) {
      this.props[aestheticName] = aesthetics[aestheticName];
    }
  }

  // Internal
  _renderWithStartAndEndCalls (context) {
    context.layerStart();

    const clip = getClip(this.props, this.section);
    applyClipping(context, clip);

    const asOnePath = this.styler.asOnePath(this.props);
    const applyStyling = this.styler.create(this.props);

    if (asOnePath) {
      context.markStart();

      for (let i = 0; i < this.positioning.length; i++) {
        applyPositioning(context, this.positioning[i]);
      }

      applyStyling(context);

      context.markEnd();
    }

    if (!asOnePath) {
      for (let i = 0; i < this.positioning.length; i++) {
        context.markStart();

        applyPositioning(context, this.positioning[i]);
        applyStyling(context, i);

        context.markEnd();
      }
    }

    context.layerEnd();
  }

  _render (context) {
    const clip = getClip(this.props, this.section);
    applyClipping(context, clip);

    const asOnePath = this.styler.asOnePath(this.props);
    const applyStyling = this.styler.create(this.props);

    if (asOnePath) {
      context.beginPath();

      for (let i = 0; i < this.positioning.length; i++) {
        applyPositioning(context, this.positioning[i]);
      }

      applyStyling(context);
    }

    if (!asOnePath) {
      for (let i = 0; i < this.positioning.length; i++) {
        context.beginPath();
        applyPositioning(context, this.positioning[i]);
        applyStyling(context, i);
      }
    }
  }
}

function coordinatesAreInsideSection ({ x, y }, section) {
  const bbox = section.bbox;

  return (
    x >= bbox.minX &&
    x <= bbox.maxX &&
    y >= bbox.minY &&
    y <= bbox.maxY
  )
}

function hitIsMark (hit) {
  return hit.data.constructor === Mark
}

function hitIsInLayer (hit) {
  return hit.data.constructor === Layer
}

function getHitId (hit) {
  if (hitIsMark(hit)) return hit.data.id
  if (hitIsInLayer(hit)) return hit.data.id + '-' + hit.index
}

class ClickHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'click',
      eventName: 'click'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];

      if (hitIsMark(hit)) {
        const clickEvent = createMarkEvent('click', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._markCallbacks[hit.data.id](clickEvent);
      }

      if (hitIsInLayer(hit)) {
        const clickEvent = createLayerEvent('click', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._layerCallbacks[hit.data.id](clickEvent);
      }
    }
  }
}

class MouseoverHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mouseover',
      eventName: 'mousemove'
    });

    this._previousMouseoverIds = {};
    this._currentMouseoverIds = {};
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._currentMouseoverIds[hitId] = true;

      if (!(hitId in this._previousMouseoverIds)) {
        this._fireCallback(hit, screenCoordinates, nativeEvent);
      }
    }

    this._previousMouseoverIds = this._currentMouseoverIds;
    this._currentMouseoverIds = {};
  }

  _fireCallback (hit, screenCoordinates, nativeEvent) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    if (hitIsMark(hit)) {
      const mouseoverEvent = createMarkEvent('mouseover', {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);

      this._markCallbacks[hit.data.id](mouseoverEvent);
    }

    if (hitIsInLayer(hit)) {
      const mouseoverEvent = createLayerEvent('mouseover', {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);

      this._layerCallbacks[hit.data.id](mouseoverEvent);
    }
  }
}

class MouseoutHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mouseout',
      eventName: 'mousemove'
    });

    this._previousMouseoverHits = {};
    this._currentMouseoverHits = {};
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._currentMouseoverHits[hitId] = hit;
    }

    for (const hitId in this._previousMouseoverHits) {
      if (!(hitId in this._currentMouseoverHits)) {
        const hit = this._previousMouseoverHits[hitId];
        this._fireCallback(hit, screenCoordinates, nativeEvent);
      }
    }

    this._previousMouseoverHits = this._currentMouseoverHits;
    this._currentMouseoverHits = {};
  }

  _fireCallback (hit, screenCoordinates, nativeEvent) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    if (hitIsMark(hit)) {
      const mouseoutEvent = createMarkEvent('mouseout', {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);

      this._markCallbacks[hit.data.id](mouseoutEvent);
    }

    if (hitIsInLayer(hit)) {
      const mouseoutEvent = createLayerEvent('mouseout', {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);

      this._layerCallbacks[hit.data.id](mouseoutEvent);
    }
  }
}

class MousedownHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mousedown',
      eventName: 'mousedown'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];

      if (hitIsMark(hit)) {
        const mousedownEvent = createMarkEvent('mousedown', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._markCallbacks[hit.data.id](mousedownEvent);
      }

      if (hitIsInLayer(hit)) {
        const mousedownEvent = createLayerEvent('mousedown', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._layerCallbacks[hit.data.id](mousedownEvent);
      }
    }
  }
}

class MouseupHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mouseup',
      eventName: 'mouseup'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];

      if (hitIsMark(hit)) {
        const mouseupEvent = createMarkEvent('mouseup', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._markCallbacks[hit.data.id](mouseupEvent);
      }

      if (hitIsInLayer(hit)) {
        const mouseupEvent = createLayerEvent('mouseup', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._layerCallbacks[hit.data.id](mouseupEvent);
      }
    }
  }
}

class MousedragHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mousedrag',
      eventName: ['mousedown', 'mousemove', 'mouseup']
    });

    this._currentHits = {};
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (nativeEvent.eventName === 'mousedown') {
      this._handleMousedown(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'mousemove') {
      this._handleMousemove(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'mouseup') {
      this._handleMouseup(screenCoordinates, nativeEvent);
    }
  }

  _handleMousedown (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._currentHits[hitId] = hit;

      this._fireCallback(hit, screenCoordinates, nativeEvent, 'start');
    }
  }

  _handleMousemove (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    for (const hitId in this._currentHits) {
      const hit = this._currentHits[hitId];
      this._fireCallback(hit, screenCoordinates, nativeEvent, 'drag');
    }
  }

  _handleMouseup (screenCoordinates, nativeEvent) {
    for (const hitId in this._currentHits) {
      const hit = this._currentHits[hitId];
      this._fireCallback(hit, screenCoordinates, nativeEvent, 'end');
    }

    this._currentHits = {};
  }

  _fireCallback (hit, screenCoordinates, nativeEvent, dragType) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    if (hitIsMark(hit)) {
      const mousedragEvent = createMarkEvent('mousedrag', {
        screenCoordinates,
        localCoordinates,
        dragType
      }, hit, nativeEvent);

      this._markCallbacks[hit.data.id](mousedragEvent);
    }

    if (hitIsInLayer(hit)) {
      const mousedragEvent = createLayerEvent('mousedrag', {
        screenCoordinates,
        localCoordinates,
        dragType
      }, hit, nativeEvent);

      this._layerCallbacks[hit.data.id](mousedragEvent);
    }
  }
}

var MarkInteractionHandlers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClickHandler: ClickHandler,
  MouseoverHandler: MouseoverHandler,
  MouseoutHandler: MouseoutHandler,
  MousedownHandler: MousedownHandler,
  MouseupHandler: MouseupHandler,
  MousedragHandler: MousedragHandler
});

class SectionInteractionHandler extends BaseInteractionHandler {
  constructor (interactionManager, options) {
    super(interactionManager, options);
    this._callback = undefined;
  }

  addInteraction (callback) {
    this._addEventListener();
    this._callback = callback;
  }

  hasInteraction () {
    return this._callback !== undefined
  }

  removeInteraction () {
    if (this._callback) {
      this._callback = undefined;
      this._removeEventListener();
    }
  }

  getId () {
    return `${this.id()}-section-${this._interactionName}`
  }
}

// Taken from:
// https://stackoverflow.com/a/37474225/7237112

function getScrollLineHeight () {
  var r;
  var iframe = document.createElement('iframe');
  iframe.src = '#';
  document.body.appendChild(iframe);
  var iwin = iframe.contentWindow;
  var idoc = iwin.document;
  idoc.open();
  idoc.write('<!DOCTYPE html><html><head></head><body><span>a</span></body></html>');
  idoc.close();
  var span = idoc.body.firstElementChild;
  r = span.offsetHeight;
  document.body.removeChild(iframe);

  return r
}

class WheelHandler extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'wheel',
      eventName: 'wheel'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    nativeEvent.preventDefault();
    nativeEvent.stopPropagation();

    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);
      const delta = getDelta(nativeEvent);

      const wheelEvent = createSectionEvent('wheel', {
        screenCoordinates,
        localCoordinates,
        delta
      }, nativeEvent);

      this._callback(wheelEvent);
    }
  }
}

let scrollLineHeight;

function getDelta (nativeEvent) {
  let delta;

  // Legacy
  // IE pixels
  if ('wheelDelta' in nativeEvent && nativeEvent.wheelDelta !== 0) {
    delta = -nativeEvent.wheelDelta;
  }

  // Mozilla
  if ('detail' in nativeEvent && nativeEvent.detail !== 0) {
    delta = -nativeEvent.detail;
  }

  // Most other cases
  if ('deltaY' in nativeEvent && nativeEvent.deltaY !== 0) {
    delta = -nativeEvent.deltaY;
  }

  if (!scrollLineHeight) {
    scrollLineHeight = getScrollLineHeight();
  }

  return delta * (nativeEvent.deltaMode ? scrollLineHeight : 1) / 500
}

class ClickHandler$1 extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'click',
      eventName: 'click'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

      const clickEvent = createSectionEvent('click', {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);

      this._callback(clickEvent);
    }
  }
}

class MousedownHandler$1 extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mousedown',
      eventName: 'mousedown'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

      const mousedownEvent = createSectionEvent('mousedown', {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);

      this._callback(mousedownEvent);
    }
  }
}

class MouseupHandler$1 extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mouseup',
      eventName: 'mouseup'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

      const mouseupEvent = createSectionEvent('mouseup', {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);

      this._callback(mouseupEvent);
    }
  }
}

class MouseoverHandler$1 extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mouseover',
      eventName: 'mousemove'
    });

    this._mouseCurrentlyOverSection = false;
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      if (!this._mouseCurrentlyOverSection) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

        const mousedownEvent = createSectionEvent('mouseover', {
          screenCoordinates,
          localCoordinates
        }, nativeEvent);

        this._callback(mousedownEvent);
        this._mouseCurrentlyOverSection = true;
      }
    } else {
      if (this._mouseCurrentlyOverSection) {
        this._mouseCurrentlyOverSection = false;
      }
    }
  }
}

class MouseoutHandler$1 extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mouseout',
      eventName: 'mousemove'
    });

    this._mouseCurrentlyOverSection = false;
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      if (!this._mouseCurrentlyOverSection) {
        this._mouseCurrentlyOverSection = true;
      }
    } else {
      if (this._mouseCurrentlyOverSection) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

        const mouseoutEvent = createSectionEvent('mouseout', {
          screenCoordinates,
          localCoordinates
        }, nativeEvent);

        this._callback(mouseoutEvent);
        this._mouseCurrentlyOverSection = false;
      }
    }
  }
}

class MousemoveHandler extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'mouseover',
      eventName: 'mousemove'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

      const mousemoveEvent = createSectionEvent('mousemove', {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);

      this._callback(mousemoveEvent);
    }
  }
}

var SectionInteractionHandlers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WheelHandler: WheelHandler,
  ClickHandler: ClickHandler$1,
  MousedownHandler: MousedownHandler$1,
  MouseupHandler: MouseupHandler$1,
  MouseoverHandler: MouseoverHandler$1,
  MouseoutHandler: MouseoutHandler$1,
  MousemoveHandler: MousemoveHandler
});

class MouseInteractionManager extends BaseInteractionManager {
  constructor () {
    super();

    this._markInteractionInterface = new MarkInteractionInterface(this, MarkInteractionHandlers);
    this._sectionInteractionInterface = new SectionInteractionInterface(this, SectionInteractionHandlers);
  }
}

function numberOfTouches (screenCoordinates) {
  if (screenCoordinates.constructor === Object) return 1

  return screenCoordinates.length
}

class TouchdownHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchdown',
      eventName: 'touchstart'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];

      if (hitIsMark(hit)) {
        const touchdownEvent = createMarkEvent('touchdown', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._markCallbacks[hit.data.id](touchdownEvent);
      }

      if (hitIsInLayer(hit)) {
        const touchdownEvent = createLayerEvent('touchdown', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._layerCallbacks[hit.data.id](touchdownEvent);
      }
    }
  }
}

class TouchupHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchup',
      eventName: ['touchend', 'touchcancel']
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];

      if (hitIsMark(hit)) {
        const touchupEvent = createMarkEvent('touchup', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._markCallbacks[hit.data.id](touchupEvent);
      }

      if (hitIsInLayer(hit)) {
        const touchupEvent = createLayerEvent('touchup', {
          screenCoordinates,
          localCoordinates
        }, hit, nativeEvent);

        this._layerCallbacks[hit.data.id](touchupEvent);
      }
    }
  }
}

class TouchoverHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchover',
      eventName: ['touchstart', 'touchmove']
    });

    this._previousHits = {};
    this._currentHits = {};
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    if (nativeEvent.eventName === 'touchstart') {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'touchmove') {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }
  }

  _handleTouchstart (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._previousHits[hitId] = true;
    }
  }

  _handleTouchmove (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._currentHits[hitId] = true;

      if (!(hitId in this._previousHits)) {
        this._fireCallback(hit, screenCoordinates, nativeEvent);
      }
    }

    this._previousHits = this._currentHits;
    this._currentHits = {};
  }

  _fireCallback (hit, screenCoordinates, nativeEvent) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    if (hitIsMark(hit)) {
      const touchoverEvent = createMarkEvent('touchover', {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);

      this._markCallbacks[hit.data.id](touchoverEvent);
    }

    if (hitIsInLayer(hit)) {
      const touchoverEvent = createLayerEvent('touchover', {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);

      this._layerCallbacks[hit.data.id](touchoverEvent);
    }
  }
}

class TouchoutHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchout',
      eventName: ['touchstart', 'touchmove', 'touchend']
    });

    this._previousHits = {};
    this._currentHits = {};
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    if (nativeEvent.eventName === 'touchstart') {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'touchmove') {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'touchend') {
      this._handleTouchend();
    }
  }

  _handleTouchstart (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._previousHits[hitId] = hit;
    }
  }

  _handleTouchmove (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._currentHits[hitId] = hit;
    }

    for (const hitId in this._previousHits) {
      if (!(hitId in this._currentHits)) {
        const hit = this._previousHits[hitId];
        this._fireCallback(hit, screenCoordinates, nativeEvent);
      }
    }

    this._previousHits = this._currentHits;
    this._currentHits = {};
  }

  _handleTouchend () {
    this._previousHits = {};
    this._currentHits = {};
  }

  _fireCallback (hit, screenCoordinates, nativeEvent) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    if (hitIsMark(hit)) {
      const touchoutEvent = createMarkEvent('touchout', {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);

      this._markCallbacks[hit.data.id](touchoutEvent);
    }

    if (hitIsInLayer(hit)) {
      const touchoutEvent = createLayerEvent('touchout', {
        screenCoordinates,
        localCoordinates
      }, hit, nativeEvent);

      this._layerCallbacks[hit.data.id](touchoutEvent);
    }
  }
}

class TouchdragHandler extends MarkInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchdrag',
      eventName: ['touchstart', 'touchmove', 'touchend']
    });

    this._currentHits = {};
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    if (nativeEvent.eventName === 'touchstart') {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'touchmove') {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'touchend') {
      this._handleTouchend(screenCoordinates, nativeEvent);
    }
  }

  _handleTouchstart (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    const spatialIndex = this._spatialIndex;
    const hits = spatialIndex.queryMouseCoordinates(screenCoordinates);

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._currentHits[hitId] = hit;

      this._fireCallback(hit, screenCoordinates, nativeEvent, 'start');
    }
  }

  _handleTouchmove (screenCoordinates, nativeEvent) {
    if (!coordinatesAreInsideSection(screenCoordinates, this.section())) {
      return
    }

    for (const hitId in this._currentHits) {
      const hit = this._currentHits[hitId];
      this._fireCallback(hit, screenCoordinates, nativeEvent, 'drag');
    }
  }

  _handleTouchend (screenCoordinates, nativeEvent) {
    for (const hitId in this._currentHits) {
      const hit = this._currentHits[hitId];
      this._fireCallback(hit, screenCoordinates, nativeEvent, 'end');
    }

    this._currentHits = {};
  }

  _fireCallback (hit, screenCoordinates, nativeEvent, dragType) {
    const localCoordinates = getLocalCoordinates(screenCoordinates, this.interactionManager());

    if (hitIsMark(hit)) {
      const touchdragEvent = createMarkEvent('touchdrag', {
        screenCoordinates,
        localCoordinates,
        dragType
      }, hit, nativeEvent);

      this._markCallbacks[hit.data.id](touchdragEvent);
    }

    if (hitIsInLayer(hit)) {
      const touchdragEvent = createLayerEvent('touchdrag', {
        screenCoordinates,
        localCoordinates,
        dragType
      }, hit, nativeEvent);

      this._layerCallbacks[hit.data.id](touchdragEvent);
    }
  }
}

var MarkInteractionHandlers$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TouchdownHandler: TouchdownHandler,
  TouchupHandler: TouchupHandler,
  TouchoverHandler: TouchoverHandler,
  TouchoutHandler: TouchoutHandler,
  TouchdragHandler: TouchdragHandler
});

class TouchdownHandler$1 extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchdown',
      eventName: 'touchstart'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

      const touchdownEvent = createSectionEvent('touchdown', {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);

      this._callback(touchdownEvent);
    }
  }
}

class TouchmoveHandler extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchmove',
      eventName: 'touchmove'
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

      const touchmoveEvent = createSectionEvent('touchmove', {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);

      this._callback(touchmoveEvent);
    }
  }
}

class TouchupHandler$1 extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchup',
      eventName: ['touchend', 'touchcancel']
    });
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

      const touchupEvent = createSectionEvent('touchup', {
        screenCoordinates,
        localCoordinates
      }, nativeEvent);

      this._callback(touchupEvent);
    }
  }
}

class TouchoverHandler$1 extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchover',
      eventName: ['touchstart', 'touchmove']
    });

    this._fingerCurrentlyOverSection = false;
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    if (nativeEvent.eventName === 'touchstart') {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'touchmove') {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }
  }

  _handleTouchstart (screenCoordinates, nativeEvent) {
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      this._fingerCurrentlyOverSection = true;
    }
  }

  _handleTouchmove (screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      if (!this._fingerCurrentlyOverSection) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

        const touchoverEvent = createSectionEvent('touchover', {
          screenCoordinates,
          localCoordinates
        }, nativeEvent);

        this._callback(touchoverEvent);
        this._fingerCurrentlyOverSection = true;
      }
    } else {
      if (this._fingerCurrentlyOverSection) {
        this._fingerCurrentlyOverSection = false;
      }
    }
  }
}

class TouchoutHandler$1 extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'touchout',
      eventName: ['touchstart', 'touchmove', 'touchend']
    });

    this._fingerCurrentlyOverSection = false;
  }

  _handleEvent (screenCoordinates, nativeEvent) {
    if (numberOfTouches(screenCoordinates) !== 1) {
      return
    }

    if (nativeEvent.eventName === 'touchstart') {
      this._handleTouchstart(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'touchmove') {
      this._handleTouchmove(screenCoordinates, nativeEvent);
    }

    if (nativeEvent.eventName === 'touchend') {
      this._handleTouchend();
    }
  }

  _handleTouchstart (screenCoordinates, nativeEvent) {
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      this._fingerCurrentlyOverSection = true;
    }
  }

  _handleTouchmove (screenCoordinates, nativeEvent) {
    const interactionManager = this.interactionManager();
    const section = this.section();

    if (coordinatesAreInsideSection(screenCoordinates, section)) {
      if (!this._fingerCurrentlyOverSection) {
        this._fingerCurrentlyOverSection = true;
      }
    } else {
      if (this._fingerCurrentlyOverSection) {
        const localCoordinates = getLocalCoordinates(screenCoordinates, interactionManager);

        const touchoutEvent = createSectionEvent('touchout', {
          screenCoordinates,
          localCoordinates
        }, nativeEvent);

        this._callback(touchoutEvent);
        this._fingerCurrentlyOverSection = false;
      }
    }
  }

  _handleTouchend () {
    this._fingerCurrentlyOverSection = false;
  }
}

class PinchHandler extends SectionInteractionHandler {
  constructor (interactionManager) {
    super(interactionManager, {
      interactionName: 'pinch',
      eventName: ['touchstart', 'touchmove', 'touchend']
    });

    this._previousTouchDistance = undefined;
  }

  _handleEvent (screenCoordinatesArray, nativeEvent) {
    if (nativeEvent.type === 'touchstart') {
      this._handleTouchstart(screenCoordinatesArray, nativeEvent);
    }

    if (nativeEvent.type === 'touchmove') {
      this._handleTouchmove(screenCoordinatesArray, nativeEvent);
    }

    if (nativeEvent.type === 'touchend') {
      this._handleTouchend(screenCoordinatesArray, nativeEvent);
    }
  }

  _handleTouchstart (screenCoordinatesArray, nativeEvent) {
    if (numberOfTouches(screenCoordinatesArray) !== 2) {
      return
    }

    const section = this.section();

    if (allCoordinatesAreInsideSection(screenCoordinatesArray, section)) {
      this._previousTouchDistance = getDistance(screenCoordinatesArray);
    }
  }

  _handleTouchmove (screenCoordinatesArray, nativeEvent) {
    if (numberOfTouches(screenCoordinatesArray) !== 2) {
      return
    }

    if (this._previousTouchDistance === undefined) return

    const section = this.section();

    if (allCoordinatesAreInsideSection(screenCoordinatesArray, section)) {
      const sectionHeight = section.maxY - section.minY;

      const center = getCenter(screenCoordinatesArray);

      const touchDistance = getDistance(screenCoordinatesArray);
      const touchDelta = this._previousTouchDistance - touchDistance;
      const relativeTouchDelta = touchDelta / sectionHeight;

      this._previousTouchDistance = touchDistance;
      this._fireCallback(screenCoordinatesArray, nativeEvent, relativeTouchDelta, center);
    }
  }

  _handleTouchend (screenCoordinatesArray, nativeEvent) {
    this._previousTouchDistance = undefined;
  }

  _fireCallback (screenCoordinatesArray, nativeEvent, delta, center) {
    const screenCenter = center;
    const localCenter = getLocalCoordinates(screenCenter, this.interactionManager());
    const screenCoordinates = screenCoordinatesArray;
    const localCoordinates = screenCoordinatesArray.map(screenCoordinates => {
      return getLocalCoordinates(screenCoordinates, this.interactionManager())
    });

    const pinchEvent = createSectionEvent('pinch', {
      screenCenter,
      localCenter,
      screenCoordinates,
      localCoordinates,
      delta
    }, nativeEvent);

    this._callback(pinchEvent);
  }
}

function allCoordinatesAreInsideSection (screenCoordinatesArray, section) {
  return screenCoordinatesArray.every(screenCoordinates => {
    return coordinatesAreInsideSection(screenCoordinates, section)
  })
}

function getDistance (screenCoordinatesArray) {
  const [coords1, coords2] = screenCoordinatesArray;
  return Math.sqrt((coords2.x - coords1.x) ** 2 + (coords2.y - coords1.y) ** 2)
}

function getCenter (screenCoordinatesArray) {
  const [coords1, coords2] = screenCoordinatesArray;
  return { x: (coords2.x + coords1.x) / 2, y: (coords2.y + coords1.y) / 2 }
}

var SectionInteractionHandlers$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TouchdownHandler: TouchdownHandler$1,
  TouchmoveHandler: TouchmoveHandler,
  TouchupHandler: TouchupHandler$1,
  TouchoverHandler: TouchoverHandler$1,
  TouchoutHandler: TouchoutHandler$1,
  PinchHandler: PinchHandler
});

class TouchInteractionManager extends BaseInteractionManager {
  constructor () {
    super();

    this._markInteractionInterface = new MarkInteractionInterface(this, MarkInteractionHandlers$1);
    this._sectionInteractionInterface = new SectionInteractionInterface(this, SectionInteractionHandlers$1);
  }
}

function centroidPoint (mark) {
  return _centroidPoint(mark.positioning)
}

function _centroidPoint (positioning) {
  for (let i = 0; i < positioning.call.length; i++) {
    if (positioning.call[i] === 'arc') {
      return [positioning.args[i][0], positioning.args[i][1]]
    }
  }
}

function centroidPointLayer (layer) {
  const centroids = [];

  for (let i = 0; i < layer.positioning.length; i++) {
    centroids.push(_centroidPoint(layer.positioning[i]));
  }

  return centroids
}

function createBboxFromCentroid ([x, y], index) {
  return {
    minX: x,
    maxX: x,
    minY: y,
    maxY: y,
    index
  }
}

function indexPoint$1 (mark) {
  const centroid = centroidPoint(mark);
  const bbox = createBboxFromCentroid(centroid);

  Object.assign(bbox, { data: mark });

  return [bbox]
}

function indexPointLayer$1 (layer) {
  const centroids = centroidPointLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function interpolateQuadratic (x0, y0, x1, y1, x2, y2) {
  const points = [];

  for (let i = 1; i <= 5; i++) {
    const x = evalQuadratic(x0, x1, x2, i * 0.2);
    const y = evalQuadratic(y0, y1, y2, i * 0.2);

    points.push([x, y]);
  }

  return points
}

function interpolateCubic (x0, y0, x1, y1, x2, y2, x3, y3) {
  const points = [];

  for (let i = 1; i <= 10; i++) {
    const x = evalCubic(x0, x1, x2, x3, i * 0.2);
    const y = evalCubic(y0, y1, y2, y3, i * 0.2);

    points.push([x, y]);
  }

  return points
}

function interpolateEllipse (x, y, rx, ry, rot, a0, a1, ccw) {
  const points = [];

  if (a0 < a1) {
    const da = a1 - a0;
    const dai = da / 8;

    if (!ccw) {
      for (let i = 1; i <= 8; i++) {
        points.push([
          Math.cos(a0 + dai * i) * rx + x,
          Math.sin(a0 + dai * i) * ry + y
        ]);
      }
    }

    if (ccw) {
      for (let i = 7; i >= 0; i--) {
        points.push([
          Math.cos(a0 + dai * i) * rx + x,
          Math.sin(a0 + dai * i) * ry + y
        ]);
      }
    }
  }

  if (a0 > a1) {
    const da0 = TWO_PI$1 - a1;
    const da0i = da0 / 8;

    const da1i = a0 / 8;

    if (!ccw) {
      for (let i = 1; i <= 8; i++) {
        points.push([
          Math.cos(a1 + da0i * i) * rx + x,
          Math.sin(a1 + da0i * i) * ry + y
        ]);
      }

      for (let i = 1; i <= 8; i++) {
        points.push([
          Math.cos(da1i * i) * rx + x,
          Math.sin(da1i * i) * ry + y
        ]);
      }
    }

    if (ccw) {
      for (let i = 7; i >= 0; i--) {
        points.push([
          Math.cos(da1i * i) * rx + x,
          Math.sin(da1i * i) * ry + y
        ]);
      }

      for (let i = 7; i >= 0; i--) {
        points.push([
          Math.cos(a1 + da0i * i) * rx + x,
          Math.sin(a1 + da0i * i) * ry + y
        ]);
      }
    }
  }

  return points
}

const TWO_PI$1 = Math.PI * 2;

/* eslint-disable no-case-declarations */

function centroidPolygon (mark) {
  return _centroidPolygon(mark.positioning)
}

function _centroidPolygon (positioning) {
  const linearRings = toLinearRings(positioning);
  const centroidsAndAreas = linearRings.map(calculateLinearRingCentroidAndArea);

  return getMeanCentroidWeightedByArea(centroidsAndAreas)
}

function centroidPolygonLayer (layer) {
  return layer.positioning.map(_centroidPolygon)
}

function toLinearRings (positioning) {
  const linearRings = [];

  const submarks = positioning.submarks.length
    ? positioning.submarks
    : [0];

  for (let i = 0; i < submarks.length; i++) {
    const submarkStart = submarks[i];
    const submarkEnd = submarks[i + 1] || positioning.call.length;

    linearRings.push(toLinearRing(positioning, submarkStart, submarkEnd));
  }

  return linearRings
}

function toLinearRing (positioning, start, end) {
  let linearRing = [];

  let lastX;
  let lastY;

  let numberOfMoveTos = 0;

  for (let i = start; i < end; i++) {
    const call = positioning.call[i];
    const args = positioning.args[i];

    switch (call) {
      case 'moveTo':
        // This ignores holes
        numberOfMoveTos++;

        if (numberOfMoveTos === 2) {
          return linearRing
        }

        lastX = args[0];
        lastY = args[1];

        linearRing.push([lastX, lastY]);
        break
      case 'lineTo':
        lastX = args[0];
        lastY = args[1];

        linearRing.push([lastX, lastY]);
        break
      case 'quadraticCurveTo':
        linearRing = linearRing.concat(interpolateQuadratic(lastX, lastY, ...args));

        lastX = args[2];
        lastY = args[3];

        break
      case 'bezierCurveTo':
        linearRing = linearRing.concat(interpolateCubic(lastX, lastY, ...args));

        lastX = args[4];
        lastY = args[5];

        break
      case 'ellipse':
        linearRing = linearRing.concat(interpolateEllipse.apply(null, args));

        const endCoords = getEllipseEndCoords.apply(null, args);
        lastX = endCoords[0];
        lastY = endCoords[1];

        break
      case 'closePath':
        linearRing.push(linearRing[0]);

        break
    }
  }

  return linearRing
}

// https://stackoverflow.com/a/33852627/7237112
function calculateLinearRingCentroidAndArea (ring) {
  const last = ring.length - 1;
  if (ring[0][0] !== ring[last][0] || ring[0][1] !== ring[last][1]) {
    ring.push(ring[0]);
  }

  const nPts = ring.length;
  const off = ring[0];
  let twicearea = 0;
  let x = 0;
  let y = 0;
  let p1;
  let p2;
  let f;

  for (let i = 0, j = nPts - 1; i < nPts; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    f = (p1[0] - off[0]) * (p2[1] - off[1]) - (p2[0] - off[0]) * (p1[1] - off[1]);
    twicearea += f;
    x += (p1[0] + p2[0] - 2 * off[0]) * f;
    y += (p1[1] + p2[1] - 2 * off[1]) * f;
  }

  f = twicearea * 3;

  return {
    centroid: [x / f + off[0], y / f + off[1]],
    area: Math.abs(twicearea / 2)
  }
}

function getMeanCentroidWeightedByArea (centroidsAndAreas) {
  if (centroidsAndAreas.length === 1) return centroidsAndAreas[0].centroid

  let x = 0;
  let y = 0;
  let totalArea = 0;

  for (let i = 0; i < centroidsAndAreas.length; i++) {
    const { centroid, area } = centroidsAndAreas[i];

    x += centroid[0] * area;
    y += centroid[1] * area;
    totalArea += area;
  }

  return [x / totalArea, y / totalArea]
}

function indexRectangle$1 (mark) {
  const centroid = centroidPolygon(mark);
  const bbox = createBboxFromCentroid(centroid);

  Object.assign(bbox, { data: mark });

  return [bbox]
}

function indexRectangleLayer$1 (layer) {
  const centroids = centroidPolygonLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function indexPolygon$1 (mark) {
  const centroid = centroidPolygon(mark);
  const bbox = createBboxFromCentroid(centroid);

  Object.assign(bbox, { data: mark });

  return [bbox]
}

function indexPolygonLayer$1 (layer) {
  const centroids = centroidPolygonLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function indexLine$1 (mark) {
  const centroid = centroidPolygon(mark);
  const bbox = createBboxFromCentroid(centroid);

  Object.assign(bbox, { data: mark });

  return [bbox]
}

function indexLineLayer$1 (layer) {
  const centroids = centroidPolygonLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function indexArea$1 (mark) {
  const centroid = centroidPolygon(mark);
  const bbox = createBboxFromCentroid(centroid);

  Object.assign(bbox, { data: mark });

  return [bbox]
}

function indexAreaLayer$1 (layer) {
  const centroids = centroidPolygonLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

function centroidLabel (label) {
  const bbox = bboxLabel(label);
  return calculateLinearRingCentroidAndArea(bbox[0].rotatedBbox).centroid
}

function centroidLabelLayer (labelLayer) {
  const bboxes = bboxLabelLayer(labelLayer);
  return bboxes.map(b => calculateLinearRingCentroidAndArea(b.rotatedBbox).centroid)
}

function indexLabel$1 (mark) {
  const centroid = centroidLabel(mark);
  const bbox = createBboxFromCentroid(centroid);

  Object.assign(bbox, { data: mark });

  return [bbox]
}

function indexLabelLayer$1 (layer) {
  const centroids = centroidLabelLayer(layer);
  const bboxes = centroids.map(createBboxFromCentroid);

  layer.props.keys
    ? attachWithKeys(bboxes, { data: layer }, layer.props.keys)
    : attach(bboxes, { data: layer });

  return bboxes
}

const markIndexing$1 = {
  Point: indexPoint$1,
  Rectangle: indexRectangle$1,
  Polygon: indexPolygon$1,
  Line: indexLine$1,
  Label: indexLabel$1,
  Area: indexArea$1,
  Symbol: indexPolygon$1,
  FuncLine: indexLine$1
};

const layerIndexing$1 = {
  Point: indexPointLayer$1,
  Rectangle: indexRectangleLayer$1,
  Polygon: indexPolygonLayer$1,
  Line: indexLineLayer$1,
  Label: indexLabelLayer$1,
  Area: indexAreaLayer$1,
  Symbol: indexPolygon$1
};

class SelectManager {
  constructor () {
    this._selectableMarks = {};
    this._selectableLayers = {};

    this._markCallbacks = {};
    this._layerCallbacks = {};

    this._previousSelection = {};
    this._currentSelection = {};

    const getMark = function (markId) {
      return this._selectableMarks[markId]
    };

    const getLayer = function (layerId) {
      return this._selectableLayers[layerId]
    };

    this._spatialIndex = new SpatialIndex(this, getMark, getLayer);

    this._selectPolygon = { start: undefined, points: [] };
  }

  // Loading/indexing
  loadMark (mark, callbacks) {
    const indexingFunction = markIndexing$1[mark.type];
    const indexableMark = indexingFunction(mark);

    const markId = mark.id;

    this._selectableMarks[markId] = indexableMark;
    this._markCallbacks[markId] = callbacks;

    this._spatialIndex.indexMark(markId);
  }

  markIsLoaded ({ id }) {
    return id in this._selectableMarks
  }

  removeMark ({ id }) {
    this._spatialIndex.unindexMark(id);

    delete this._selectableMarks[id];
    delete this._markCallbacks[id];
  }

  loadLayer (layer, callbacks) {
    const indexingFunction = layerIndexing$1[layer.type];
    const indexableLayer = indexingFunction(layer);

    const layerId = layer.id;

    this._selectableLayers[layerId] = indexableLayer;
    this._layerCallbacks[layerId] = callbacks;

    this._spatialIndex.indexLayer(layerId);
  }

  layerIsLoaded ({ id }) {
    return id in this._selectableLayers
  }

  removeLayer ({ id }) {
    this._spatialIndex.unindexLayer(id);

    delete this._selectableLayers[id];
    delete this._layerCallbacks[id];
  }

  // Rectangle
  selectRectangle (rectangle) {
    const hits = this._spatialIndex.queryBoundingBox(rectangleToRBushBbox(rectangle));

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._currentSelection[hitId] = hit;

      this._fireSelectCallback(hit);
    }
  }

  updateSelectRectangle (rectangle) {
    this._previousSelection = this._currentSelection;
    this._currentSelection = {};

    const hits = this._spatialIndex.queryBoundingBox(rectangleToRBushBbox(rectangle));

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitId = getHitId(hit);

      this._currentSelection[hitId] = hit;

      if (!(hitId in this._previousSelection)) {
        this._fireSelectCallback(hit);
      }
    }

    for (const hitId in this._previousSelection) {
      if (!(hitId in this._currentSelection)) {
        const hit = this._previousSelection[hitId];

        this._fireDeselectCallback(hit);
      }
    }
  }

  resetSelectRectangle () {
    for (const hitId in this._currentSelection) {
      const hit = this._currentSelection[hitId];

      this._fireDeselectCallback(hit);
    }

    this._previousSelection = {};
    this._currentSelection = {};
  }

  // Polygon
  startSelectPolygon (startCoordinates) {
    this._selectPolygon.start = parseCoordinates(startCoordinates);
  }

  addPointToSelectPolygon (coordinates) {
    this._selectPolygon.points.push(parseCoordinates(coordinates));

    if (this._selectPolygon.points.length > 1) {
      const lastThreePointsPolygon = this._getLastThreePointsPolygon();
      const bbox = calculateBbox(lastThreePointsPolygon);

      const hits = this._spatialIndex.queryBoundingBox(bbox);

      for (let i = 0; i < hits.length; i++) {
        const hit = hits[i];
        const hitCentroid = [hit.minX, hit.minY];

        if (pointInPolygon(hitCentroid, lastThreePointsPolygon)) {
          const hitId = getHitId(hit);

          if (hitId in this._currentSelection) {
            this._fireDeselectCallback(hit);
            delete this._currentSelection[hitId];
          } else {
            this._fireSelectCallback(hit);
            this._currentSelection[hitId] = hit;
          }
        }
      }
    }
  }

  moveSelectPolygon (_delta) {
    this._previousSelection = this._currentSelection;
    this._currentSelection = {};

    const delta = parseCoordinates(_delta);

    const start = this._selectPolygon.start;
    const points = this._selectPolygon.points;

    this._selectPolygon.start = [start[0] + delta[0], start[1] + delta[1]];
    this._selectPolygon.points = points.map(point => [point[0] + delta[0], point[1] + delta[1]]);

    const polygon = this.getSelectPolygon();
    const bbox = calculateBbox(polygon.coordinates[0]);

    const hits = this._spatialIndex.queryBoundingBox(bbox);

    for (let i = 0; i < hits.length; i++) {
      const hit = hits[i];
      const hitCentroid = [hit.minX, hit.minY];

      if (pointInPolygon(hitCentroid, polygon.coordinates[0])) {
        const hitId = getHitId(hit);

        this._currentSelection[hitId] = hit;

        if (!(hitId in this._previousSelection)) {
          this._fireSelectCallback(hit);
        }
      }
    }

    for (const hitId in this._previousSelection) {
      if (!(hitId in this._currentSelection)) {
        const hit = this._previousSelection[hitId];

        this._fireDeselectCallback(hit);
      }
    }
  }

  getSelectPolygon () {
    if (this._selectPolygon.start) {
      return {
        type: 'Polygon',
        coordinates: [[
          this._selectPolygon.start,
          ...this._selectPolygon.points,
          this._selectPolygon.start
        ]]
      }
    }
  }

  resetSelectPolygon () {
    for (const hitId in this._currentSelection) {
      const hit = this._currentSelection[hitId];

      this._fireDeselectCallback(hit);
    }

    this._selectPolygon = { start: undefined, points: [] };
    this._currentSelection = {};
  }

  _fireSelectCallback (hit) {
    if (hitIsMark(hit)) {
      const selectEvent = createSelectMarkEvent('select', hit);
      const callback = this._markCallbacks[hit.data.id].onSelect;

      if (callback) callback(selectEvent);
    }

    if (hitIsInLayer(hit)) {
      const selectEvent = createSelectLayerEvent('select', hit);
      const callback = this._layerCallbacks[hit.data.id].onSelect;

      if (callback) callback(selectEvent);
    }
  }

  _fireDeselectCallback (hit) {
    if (hitIsMark(hit)) {
      const deselectEvent = createSelectMarkEvent('deselect', hit);
      const callback = this._markCallbacks[hit.data.id].onDeselect;

      if (callback) callback(deselectEvent);
    }

    if (hitIsInLayer(hit)) {
      const deselectEvent = createSelectLayerEvent('deselect', hit);
      const callback = this._layerCallbacks[hit.data.id].onDeselect;

      if (callback) callback(deselectEvent);
    }
  }

  _getLastThreePointsPolygon () {
    const points = this._selectPolygon.points;
    const lastPointIndex = points.length - 1;
    const start = this._selectPolygon.start;

    return [start, points[lastPointIndex - 1], points[lastPointIndex], start]
  }
}

function rectangleToRBushBbox (rectangle) {
  return {
    minX: Math.min(rectangle.x1, rectangle.x2),
    maxX: Math.max(rectangle.x1, rectangle.x2),
    minY: Math.min(rectangle.y1, rectangle.y2),
    maxY: Math.max(rectangle.y1, rectangle.y2)
  }
}

function parseCoordinates (coordinates) {
  if (is2dArray(coordinates)) return coordinates
  if (isXYObject(coordinates)) return [coordinates.x, coordinates.y]

  throw new Error(`Invalid input: ${coordinates}`)
}

function is2dArray (coordinates) {
  return coordinates.constructor === Array &&
    coordinates.length === 2 &&
    coordinates.every(c => c && c.constructor === Number)
}

function isXYObject (coordinates) {
  return 'x' in coordinates && 'y' in coordinates &&
    coordinates.x.constructor === Number &&
    coordinates.y.constructor === Number
}

function calculateBbox (coords) {
  const bbox = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity };

  for (let i = 0; i < coords.length; i++) {
    const [x, y] = coords[i];
    updateBbox(bbox, x, y);
  }

  return bbox
}

class InteractionManager {
  constructor () {
    if (primaryInput === 'mouse') {
      this._mouseInteractionManager = new MouseInteractionManager();
    }

    if (primaryInput === 'touch') {
      this._touchInteractionManager = new TouchInteractionManager();
    }

    this._selectManager = new SelectManager();
  }

  // Initialization
  setId (id) {
    this._forEachManager(manager => { manager.setId(id); });
  }

  linkEventManager (eventManager) {
    if (this._mouseInteractionManager) {
      this._mouseInteractionManager.linkEventManager(eventManager.mouse());
    }

    if (this._touchInteractionManager) {
      this._touchInteractionManager.linkEventManager(eventManager.touch());
    }
  }

  // Section context loading
  loadSection (sectionContext) {
    this._forEachManager(manager => { manager.loadSection(sectionContext); });
  }

  // Access sub managers
  mouse () {
    return this._mouseInteractionManager
  }

  touch () {
    return this._touchInteractionManager
  }

  select () {
    return this._selectManager
  }

  // Other
  getPrimaryInput () {
    return primaryInput
  }

  // Internal
  _forEachManager (callback) {
    if (this._mouseInteractionManager) callback(this._mouseInteractionManager);
    if (this._touchInteractionManager) callback(this._touchInteractionManager);
  }
}

function getOrientation (props) {
  return props.x
    ? 'x'
    : 'y'
}

// Marks
function streamArea (g, stream) {
  const orientation = getOrientation(g);

  if (orientation === 'x') {
    streamAreaX(g.x, g.y1, g.y2, stream);
  }

  if (orientation === 'y') {
    streamAreaY(g.x1, g.x2, g.y, stream);
  }
}
function streamLine (g, stream) {
  _streamLine(g.x, g.y, stream);
}
function streamPoint (g, stream) {
  stream.point(g.x, g.y);
}
function streamPolygon (g, stream) {
  _streamPolygon(g.x, g.y, stream);
}
function streamRectangle (g, stream) {
  _streamRectangle(g.x1, g.x2, g.y1, g.y2, stream);
}

// Layers
function streamAreaLayer (g, stream) {
  const orientation = getOrientation(g);

  if (orientation === 'x') {
    forEachIndex(g.x.length, i => {
      streamAreaX(g.x[i], g.y1[i], g.y2[i], stream);
      stream.markEnd();
    });
  }

  if (orientation === 'y') {
    forEachIndex(g.y.length, i => {
      streamAreaY(g.x1[i], g.x2[i], g.y[i], stream);
      stream.markEnd();
    });
  }
}
function streamLineLayer (g, stream) {
  forEachIndex(g.x.length, i => {
    _streamLine(g.x[i], g.y[i], stream);
    stream.markEnd();
  });
}
function streamPointLayer (g, stream) {
  forEachIndex(g.x.length, i => {
    stream.point(g.x[i], g.y[i]);
    stream.markEnd();
  });
}
function streamPolygonLayer (g, stream) {
  forEachIndex(g.x.length, i => {
    _streamPolygon(g.x[i], g.y[i], stream);
    stream.markEnd();
  });
}
function streamRectangleLayer (g, stream) {
  forEachIndex(g.x1.length, i => {
    _streamRectangle(
      g.x1[i], g.x2[i], g.y1[i], g.y2[i], stream
    );
    stream.markEnd();
  });
}

function _streamLine (x, y, stream, closed = 0) {
  stream.lineStart();
  streamXYArrays(x, y, stream, closed);
  stream.lineEnd();
}

function _streamPolygon (x, y, stream) {
  const closed = isClosed(x, y) ? 1 : 0;

  stream.polygonStart();
  _streamLine(x, y, stream, closed);
  stream.polygonEnd();
}

function _streamRectangle (x1, x2, y1, y2, stream) {
  stream.polygonStart();
  stream.lineStart();

  stream.point(x1, y1);
  stream.point(x2, y1);
  stream.point(x2, y2);
  stream.point(x1, y2);

  stream.lineEnd();
  stream.polygonEnd();
}

function streamAreaX (x, y1, y2, stream) {
  stream.areaStart();
  stream.lineStart();

  streamXYArrays(x, y2, stream);

  stream.lineEnd();
  stream.lineStart();

  reverseStreamXYArrays(x, y1, stream);

  stream.lineEnd();
  stream.areaEnd();
}

function streamAreaY (x1, x2, y, stream) {
  stream.areaStart();
  stream.lineStart();

  streamXYArrays(x2, y, stream);

  stream.lineEnd();
  stream.lineStart();

  reverseStreamXYArrays(x1, y, stream);

  stream.lineEnd();
  stream.areaEnd();
}

function streamXYArrays (x, y, stream, closed = 0) {
  let i = -1;
  const n = x.length - closed;
  while (++i < n) stream.point(x[i], y[i]);
}

function isClosed (x, y) {
  const lastIndex = x.length - 1;
  return x[0] === x[lastIndex] && y[0] === y[lastIndex]
}

function reverseStreamXYArrays (x, y, stream) {
  let i = x.length;
  while (--i > -1) stream.point(x[i], y[i]);
}

function forEachIndex (length, fn) {
  for (let i = 0; i < length; i++) fn(i);
}

function scale (scales) {
  const { x: scaleX, y: scaleY } = scales;
  return stream => new Scale(stream, scaleX, scaleY)
}

class Scale extends Transformer {
  constructor (stream, scaleX, scaleY) {
    super(stream);
    this.scaleX = scaleX;
    this.scaleY = scaleY;
  }

  point (x, y) { this.stream.point(this.scaleX(x), this.scaleY(y)); }
  moveTo (x, y) { this.stream.moveTo(this.scaleX(x), this.scaleY(y)); }
  lineTo (x, y) { this.stream.lineTo(this.scaleX(x), this.scaleY(y)); }

  quadraticCurveTo (cpx, cpy, x, y) {
    this.stream.quadraticCurveTo(
      this.scaleX(cpx),
      this.scaleY(cpy),
      this.scaleX(x),
      this.scaleY(y)
    );
  }

  bezierCurveTo (cp1x, cp1y, cp2x, cp2y, x, y) {
    this.stream.bezierCurveTo(
      this.scaleX(cp1x),
      this.scaleY(cp1y),
      this.scaleX(cp2x),
      this.scaleY(cp2y),
      this.scaleX(x),
      this.scaleY(y)
    );
  }

  arc (x, y, r, sAngle, eAngle, counterclockwise) {
    this.stream.arc(
      this.scaleX(x),
      this.scaleY(y),
      r,
      sAngle,
      eAngle,
      counterclockwise
    );
  }

  arcTo (x1, y1, x2, y2, r) {
    this.stream.arcTo(
      this.scaleX(x1),
      this.scaleY(y1),
      this.scaleX(x2),
      this.scaleY(y2),
      r
    );
  }

  ellipse (x, y, rx, ry, rotation, sAngle, eAngle, counterclockwise) {
    this.stream.ellipse(
      this.scaleX(x),
      this.scaleY(y),
      rx,
      ry,
      rotation,
      sAngle,
      eAngle,
      counterclockwise
    );
  }

  translate (x, y) {
    this.stream.translate(this.scaleX(x), this.scaleY(y));
  }
}

function round (decimals = 0) {
  const roundFn = createRoundFn(decimals);
  return scale({ x: roundFn, y: roundFn })
}

function createRoundFn (decimals) {
  const multiplier = Math.pow(10, decimals);
  return n => Math.round(n * multiplier) / multiplier
}

function transform (transformers) {
  const { x: transformX, y: transformY } = transformers;
  return stream => new Transform(stream, transformX, transformY)
}

class Transform extends Transformer {
  constructor (stream, transformX, transformY) {
    super(stream);
    this.transformX = transformX;
    this.transformY = transformY;
  }

  point (x, y) {
    this.stream.point(this.transformX(x, y), this.transformY(x, y));
  }

  moveTo (x, y) { this.stream.moveTo(this.transformX(x, y), this.transformY(x, y)); }
  lineTo (x, y) { this.stream.lineTo(this.transformX(x, y), this.transformY(x, y)); }

  quadraticCurveTo (cpx, cpy, x, y) {
    this.stream.quadraticCurveTo(
      this.transformX(cpx, cpy),
      this.transformY(cpx, cpy),
      this.transformX(x, y),
      this.transformY(x, y)
    );
  }

  bezierCurveTo (cp1x, cp1y, cp2x, cp2y, x, y) {
    this.stream.bezierCurveTo(
      this.transformX(cp1x, cp1y),
      this.transformY(cp1x, cp1y),
      this.transformX(cp2x, cp2y),
      this.transformY(cp2x, cp2y),
      this.transformX(x, y),
      this.transformY(x, y)
    );
  }

  arc (x, y, r, sAngle, eAngle, counterclockwise) {
    this.stream.arc(
      this.transformX(x, y),
      this.transformY(x, y),
      r,
      sAngle,
      eAngle,
      counterclockwise
    );
  }

  arcTo (x1, y1, x2, y2, r) {
    this.stream.arcTo(
      this.transformX(x1, y1),
      this.transformY(x1, y1),
      this.transformX(x2, y2),
      this.transformY(x2, y2),
      r
    );
  }

  ellipse (x, y, rx, ry, rotation, sAngle, eAngle, counterclockwise) {
    this.stream.ellipse(
      this.transformX(x, y),
      this.transformY(x, y),
      rx,
      ry,
      rotation,
      sAngle,
      eAngle,
      counterclockwise
    );
  }

  translate (x, y) {
    this.stream.translate(this.transformX(x, y), this.transformY(x, y));
  }
}

function createPipeline (props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    props.curve,
    outputSettings.round ? round(outputSettings.decimals) : null,
    context
  )
}

/**
 * An OutputSettings object.
 * @typedef {Object} OutputSettings
 * @property {bolean} [round=true] Whether the output should be rounded off.
 * @property {number} [decimals=0] Number of decimals used to round the output coordinates.
 */

const DEFAULT_SETTINGS = {
  round: true,
  decimals: 0
};

function parseOutputSettings (outputSettings) {
  const parsedOutputSettings = outputSettings || {};

  for (const settingName in DEFAULT_SETTINGS) {
    if (!(settingName in parsedOutputSettings)) {
      parsedOutputSettings[settingName] = DEFAULT_SETTINGS[settingName];
    }
  }

  return parsedOutputSettings
}

function propBypassesScaling (prop) {
  return prop.constructor === Function
}

function fallback (value, fallbackValue) {
  return isDefined(value) ? value : fallbackValue
}

function isDefined (prop) {
  return prop !== undefined
}

function repeat (value, length) {
  return Array(length).fill(value)
}

function getPositioningMethod (props) {
  return props.geometry
    ? 'geojson'
    : 'florence'
}

function parsePoint (props, section) {
  let { parsedProps, scales } = parsePositioning(props, section);
  parsedProps = parseAesthetics(props, parsedProps);

  return { props: parsedProps, scales }
}

function parsePositioning (props, section) {
  const positioningMethod = getPositioningMethod(props);

  if (positioningMethod === 'florence') {
    const bypassScalingX = propBypassesScaling(props.x);
    const bypassScalingY = propBypassesScaling(props.y);

    const parsedProps = {
      x: bypassScalingX ? props.x(section) : props.x,
      y: bypassScalingY ? props.y(section) : props.y
    };

    const scales = {
      x: bypassScalingX ? section.indirectScales.x : section.directScales.x,
      y: bypassScalingY ? section.indirectScales.y : section.directScales.y
    };

    return { parsedProps, scales }
  }

  if (positioningMethod === 'geojson') {
    const bypassScaling = propBypassesScaling(props.geometry);

    const parsedProps = {
      geometry: bypassScaling ? props.geometry(section) : props.geometry
    };

    const scales = bypassScaling ? section.indirectScales : section.directScales;

    return { parsedProps, scales }
  }
}

const parsePositioningPoint = parsePositioning;
const parsePositioningPointLayer = parsePositioning;

const parseAestheticsPoint = parseAesthetics;
const parseAestheticsPointLayer = parseAesthetics;

function parseAesthetics (props, parsedProps) {
  parsedProps = parsedProps ?? {};

  parsedProps.radius = fallback(props.radius, 3);
  return parseAesthetics$1(props, parsedProps)
}

function parsePolygon (props, section) {
  let { parsedProps, scales } = parsePositioning(props, section);
  parsedProps = parseAesthetics$1(props, parsedProps);

  return { props: parsedProps, scales }
}

const parsePositioningPolygon = parsePositioning;
const parsePositioningPolygonLayer = parsePositioning;

const parseAestheticsPolygon = parseAesthetics$1;
const parseAestheticsPolygonLayer = parseAesthetics$1;

function parseAesthetics$1 (props, parsedProps) {
  parsedProps = parsedProps ?? {};

  parsedProps.fill = fallback(props.fill, 'black');
  parsedProps.stroke = fallback(props.stroke, 'none');

  if (parsedProps.stroke !== 'none') {
    parsedProps.strokeWidth = fallback(props.strokeWidth, 1);
  }

  OPTIONAL_AESTHETICS.forEach(style => {
    if (props[style]) parsedProps[style] = props[style];
  });

  return parsedProps
}

const OPTIONAL_AESTHETICS = [
  'opacity', 'fillOpacity', 'strokeOpacity', 'lineJoin', 'miterLimit',
  'dashArray', 'dashOffset', 'keys', 'clip', 'asOnePath'
];

function parseArea (props, section) {
  const parsedProps = parsePositioningArea(props, section);
  return parseAesthetics$2(props, parsedProps)
}

function parseAreaLayer (props, section) {
  const parsedProps = parsePositioningAreaLayer(props, section);
  return parseAesthetics$2(props, parsedProps)
}

function parsePositioningArea (props, section) {
  const parsedProps = {};

  const orientation = getOrientation(props);

  if (orientation === 'x') {
    parsedProps.x = getCoordX(props.x, section);
    parsedProps.y1 = getCoordY(props.y1, section);
    parsedProps.y2 = getCoordY(props.y2, section);
  }

  if (orientation === 'y') {
    parsedProps.y = getCoordY(props.y, section);
    parsedProps.x1 = getCoordX(props.x1, section);
    parsedProps.x2 = getCoordX(props.x2, section);
  }

  return parsedProps
}

function parsePositioningAreaLayer (props, section) {
  const parsedProps = {};

  const orientation = getOrientation(props);

  if (orientation === 'x') {
    parsedProps.x = getCoordsX(props.x, section);
    parsedProps.y1 = getCoordsY(props.y1, section);
    parsedProps.y2 = getCoordsY(props.y2, section);
  }

  if (orientation === 'y') {
    parsedProps.y = getCoordsY(props.y, section);
    parsedProps.x1 = getCoordsX(props.x1, section);
    parsedProps.x2 = getCoordsX(props.x2, section);
  }

  return parsedProps
}

const parseAestheticsArea = parseAesthetics$2;
const parseAestheticsAreaLayer = parseAesthetics$2;

const getCoordX = coordGetter('scaleX');
const getCoordY = coordGetter('scaleY');

function coordGetter (scale) {
  return function (coord, section) {
    if (propBypassesScaling(coord)) {
      return coord(section)
    }

    return coord.map(section[scale])
  }
}

const getCoordsX = coordsGetter('scaleX');
const getCoordsY = coordsGetter('scaleY');

function coordsGetter (scale) {
  return function (coord, section) {
    if (propBypassesScaling(coord)) {
      return coord(section)
    }

    return nestedMap(coord, section[scale])
  }
}

function nestedMap (nestedArray, fn) {
  const result = [];

  for (let i = 0; i < nestedArray.length; i++) {
    result.push([]);

    for (let j = 0; j < nestedArray[i].length; j++) {
      result[i].push(fn(nestedArray[i][j]));
    }
  }

  return result
}

function parseAesthetics$2 (props, parsedProps) {
  parsedProps = parsedProps ?? {};

  parsedProps.curve = fallback(props.curve, curveLinear$1);
  return parseAesthetics$1(props, parsedProps)
}

function toRGBA (_color, opacity) {
  const color = _color in COLOR_NAMES
    ? COLOR_NAMES[_color]
    : _color;

  const colorTranslator = new ColorTranslator(color);
  colorTranslator.setA(colorTranslator.A * opacity);

  return colorTranslator.RGBA
}

// https://stackoverflow.com/a/1573141
const COLOR_NAMES = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  gold: '#ffd700',
  goldenrod: '#daa520',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  'indianred ': '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavender: '#e6e6fa',
  lavenderblush: '#fff0f5',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgrey: '#d3d3d3',
  lightgreen: '#90ee90',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370d8',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#d87093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  rebeccapurple: '#663399',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32'
};

function getFillStyle (props) {
  if (props.fill === 'none') return

  const opacity = isProvided(props.opacity) ? props.opacity : 1;
  const fillOpacity = isProvided(props.fillOpacity) ? props.fillOpacity : 1;

  return toRGBA(props.fill, opacity * fillOpacity)
}

function getStrokeStyle (props) {
  if (props.stroke === 'none') return

  const opacity = isProvided(props.opacity) ? props.opacity : 1;
  const strokeOpacity = isProvided(props.strokeOpacity) ? props.strokeOpacity : 1;

  return toRGBA(props.stroke, opacity * strokeOpacity)
}

function getFont (props) {
  return props.fontWeight === 'normal'
    ? `${props.fontSize}px ${props.fontFamily}`
    : `${props.fontWeight} ${props.fontSize}px ${props.fontFamily}`
}

function getAnchorPoint ({ anchorPoint }) {
  switch (anchorPoint) {
    case 'center':
      return { textAlign: 'center', textBaseline: 'middle' }
    case 'lb':
      return { textAlign: 'start', textBaseline: 'alphabetic' }
    case 'lt':
      return { textAlign: 'start', textBaseline: 'hanging' }
    case 'rt':
      return { textAlign: 'end', textBaseline: 'hanging' }
    case 'rb':
      return { textAlign: 'end', textBaseline: 'alphabetic' }
    case 'l':
      return { textAlign: 'start', textBaseline: 'middle' }
    case 'r':
      return { textAlign: 'end', textBaseline: 'middle' }
    case 'b':
      return { textAlign: 'center', textBaseline: 'alphabetic' }
    case 't':
      return { textAlign: 'center', textBaseline: 'hanging' }
    default: {
      return { textAlign: 'center', textBaseline: 'middle' }
    }
  }
}

const isProvided = prop => prop !== undefined;

const markStyler = {
  apply: applyStyling
};

const layerStyler = {
  create (props) {
    const keys = props.keys;

    const getAesthetics = batchAestheticGetter(
      props,
      AESTHETICS,
      keys
    );

    return function apply (context, i) {
      const aesthetics = getAesthetics(i);
      applyStyling(context, aesthetics);
    }
  },

  asOnePath (props) {
    return props.asOnePath && areAllStylesGlobal(props, AESTHETICS)
  }
};

const AESTHETICS = [
  'stroke', 'strokeOpacity', 'strokeWidth', 'fill', 'fillOpacity', 'opacity',
  'lineJoin', 'miterLimit', 'dashArray', 'dashOffset'
];

function applyStyling (context, aesthetics) {
  if (aesthetics.lineJoin) {
    context.lineJoin = aesthetics.lineJoin;

    if (aesthetics.lineJoin === 'miter' && aesthetics.miterLimit !== undefined) {
      context.miterLimit = aesthetics.miterLimit;
    }
  }

  if (aesthetics.dashArray) {
    context.setLineDash(aesthetics.dashArray.split(' ').map(x => parseInt(x)));

    if (aesthetics.dashOffset) {
      context.lineDashOffset = aesthetics.dashOffset;
    }
  }

  const strokeStyle = getStrokeStyle(aesthetics);
  const fillStyle = getFillStyle(aesthetics);

  if (fillStyle) {
    context.fillStyle = fillStyle;
    context.fill();
  }

  if (strokeStyle) {
    context.lineWidth = aesthetics.strokeWidth;
    context.strokeStyle = strokeStyle;
    context.stroke();
  }
}

/**
 * Creates an Area mark.
 *
 * Valid prop combinations for positioning include:
 *  - x, y1 and y2
 *  - y, x1 and x2
 *
 * @param {Object} props
 * @param {(Array|function)} [props.x] An array of x-coordinates, or a function that returns an array of original x-coordinates. Must be used with y1 and y2.
 * @param {(Array|function)} [props.y] An array of y-coordinates, or a function that returns an array of original y-coordinates. Must be used with x1 and x2.
 * @param {(Array|function)} [props.y1] An array of y-coordinates, or a function that returns an array of original y-coordinates. Must be used with x and y2.
 * @param {(Array|function)} [props.y2] An array of y-coordinates, or a function that returns an array of original y-coordinates. Must be used with x and y1.
 * @param {(Array|function)} [props.x1] An array of x-coordinates, or a function that returns an array of original x-coordinates. Must be used with y and x2.
 * @param {(Array|function)} [props.x2] An array of x-coordinates, or a function that returns an array of original x-coordinates. Must be used with y and x1.
 * @param {Object} [props.curve=d3shape.curveLinear] A d3-shape curve.
 * @param {string} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {string} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number} [props.strokeWidth=1] The stroke width in pixels.
 * @param {number} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {number} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {number} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {string} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {string} [props.lineJoin='bevel'] Controls how lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {number} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {string} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {number} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Mark} A Mark object.
 */
function createArea (_props, section, outputSettings) {
  const props = parseArea(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning(props, section, outputSettings);

  return new Mark(
    positioning,
    props,
    section,
    markStyler,
    'Area'
  )
}

function getPositioning (props, section, outputSettings) {
  const markRecorder = recorderMark();

  const pipeline = createPipeline(
    props, section, section.indirectScales, markRecorder, outputSettings
  );

  streamArea(props, pipeline);

  return markRecorder.result()
}

/**
 * Creates an Area layer.
 *
 * Valid prop combinations for positioning include:
 *  - x, y1 and y2
 *  - y, x1 and x2
 *
 * @param {Object} props
 * @param {(Array.<Array>|function)} [props.x] A nested array of x-coordinates, or a function that returns a nested array of original x-coordinates. Must be used with y1 and y2.
 * @param {(Array.<Array>|function)} [props.y] A nested array of y-coordinates, or a function that returns a nested array of original y-coordinates. Must be used with x1 and x2.
 * @param {(Array.<Array>|function)} [props.y1] A nested array of y-coordinates, or a function that returns a nested array of original y-coordinates. Must be used with x and y2.
 * @param {(Array.<Array>|function)} [props.y2] A nested array of y-coordinates, or a function that returns a nested array of original y-coordinates. Must be used with x and y1.
 * @param {(Array.<Array>|function)} [props.x1] A nested array of x-coordinates, or a function that returns a nested array of original x-coordinates. Must be used with y and x2.
 * @param {(Array.<Array>|function)} [props.x2] A nested array of x-coordinates, or a function that returns a nested array of original x-coordinates. Must be used with y and x1.
 * @param {Object} [props.curve=d3shape.curveLinear] A d3-shape curve.
 * @param {(string|string[]|function)} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {(string|string[]|function)} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {(number|number[]|function)} [props.strokeWidth=1] The stroke width in pixels.
 * @param {(number|number[]|function)} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {(number|number[]|function)} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {(number|number[]|function)} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {(string|string[]|function)} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {(string|string[]|function)} [props.lineJoin='bevel'] How lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {(number|number[]|function)} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {(string|string[]|function)} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {(number|number[]|function)} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string[]} [props.keys] An array of unique keys. Must be strings.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {boolean} [props.asOnePath=false] If true, draws whole layer as one path.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Layer} A Layer object.
 */
function createAreaLayer (_props, section, outputSettings) {
  const props = parseAreaLayer(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$1(props, section, outputSettings);

  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    'Area'
  )
}

function getPositioning$1 (props, section, outputSettings) {
  const layerRecorder = recorderLayer();

  const pipeline = createPipeline(
    props, section, section.indirectScales, layerRecorder, outputSettings
  );

  streamAreaLayer(props, pipeline);

  return layerRecorder.result()
}

function validateProps (props, schema) {
  if (schema.custom) {
    schema.custom(props, 'mark');
  }

  if (schema.positioning) {
    validatePositioning(props, schema.positioning);
  }

  validateNonPositioning(props, schema.other);
}

function validatePropsLayer (props, schema) {
  if (schema.custom) {
    schema.custom(props, 'layer');
  }

  let length;

  if (schema.positioning) {
    length = validatePositioning(props, schema.positioning, true);
  }

  validateNonPositioning(props, schema.other, true, length);
  validateLayerSpecificProps(props, length);
}

function validatePositioning (props, positioning, layer) {
  const definedPositioningProps = new Set();
  let length;

  for (const propName of positioning.props) {
    if (!isMissing(props[propName])) definedPositioningProps.add(propName);
  }

  if (positioning.validCombinations !== 'any') {
    if (!positioning.validCombinations.some(combination => eqSet(definedPositioningProps, combination))) {
      throw new Error(`Invalid combination of positioning props: "${[...definedPositioningProps]}"`)
    }
  }

  if (definedPositioningProps.has('geometry')) {
    const { allowedGeometryTypes } = positioning;

    if (!layer && ![Object, Function].includes(props.geometry.constructor)) {
      throw new Error(`geometry: expected Object or Function, received "${props.geometry.constructor.name}"`)
    }

    if (layer && ![Array, Function].includes(props.geometry.constructor)) {
      throw new Error(`geometry: expected Array or Function, received "${props.geometry.constructor.name}"`)
    }

    if (props.geometry.constructor !== Function) {
      layer
        ? props.geometry.forEach(geometry => validateGeometry(geometry, allowedGeometryTypes))
        : validateGeometry(props.geometry, allowedGeometryTypes);
    }

    if (layer && props.geometry.constructor !== Function) { length = props.geometry.length; }
  } else {
    const { nonGeometryFormat } = positioning;

    length = layer
      ? validateNonGeometryLayer(props, definedPositioningProps, nonGeometryFormat)
      : validateNonGeometry(props, definedPositioningProps, nonGeometryFormat);
  }

  return length
}

function validateNonPositioning (props, other, layer, length) {
  const parsedOtherPropMetadata = parseOtherPropMetadata(other);

  for (const propName in parsedOtherPropMetadata) {
    const { required, type, validator } = parsedOtherPropMetadata[propName];
    const propValue = props[propName];

    const propIsMissing = isMissing(propValue);

    checkRequired(propName, propIsMissing, required);

    if (!propIsMissing) {
      layer
        ? checkTypesLayer(propName, propValue, type)
        : checkTypes(propName, propValue, type);

      if (validator) {
        layer
          ? applyValidator(validator, propName, propValue)
          : validator(propName, propValue);
      }

      if (layer && propValue.constructor === Array) {
        if (length === undefined) {
          length = propValue.length;
        }

        if (propValue.length !== length) {
          throw new Error(`${propName}: should be same length "${length}" as other props, but is of length "${propValue.length}"`)
        }
      }
    }
  }
}

function eqSet (as, bs) {
  if (as.size !== bs.size) return false
  for (const a of as) if (!bs.has(a)) return false
  return true
}

function validateGeometry (geometry, allowedTypes) {
  if (!allowedTypes.has(geometry.type)) {
    throw new Error(`geometry: expected one of types "${[...allowedTypes]}", received "${geometry.type}"`)
  }
}

function validateNonGeometry (props, definedProps, format) {
  if (format === 'array') ensureSameLength([...definedProps].map(propName => props[propName]));
}

function validateNonGeometryLayer (props, definedProps, format) {
  const definedPropsArr = Array.from(definedProps);
  const length = ensureSameLength(definedPropsArr.map(propName => props[propName]));

  if (length && format === 'array') {
    for (let i = 0; i < length; i++) {
      const arrays = definedPropsArr.map(propName => props[propName][i]);

      ensureSameLength(arrays);
    }
  }

  return length
}

function ensureSameLength (arrays) {
  let length;

  for (const array of arrays) {
    if (array.constructor === Function) continue
    if (array.constructor !== Array) throw new Error(`Expected Array or Function, received "${array.constructor.name}"`)

    if (length === undefined) {
      length = array.length;
    } else {
      if (length !== array.length) throw new Error('Positioning props must be of same length')
    }
  }

  return length
}

function checkRequired (propName, propValue, required) {
  if (required === true && isMissing(propValue)) {
    throw new Error(`${propName}: missing required value`)
  }
}

function checkTypes (propName, propValue, types) {
  if (isMissing(propValue)) return

  if (!types.includes(propValue.constructor)) {
    throw new Error(`${propName}: expected one of types "${types.map(t => t.name)}", received "${propValue.constructor.name}"`)
  }
}

function checkTypesLayer (propName, propValue, types) {
  switch (propValue.constructor) {
    case Array: return propValue.forEach(v => checkTypes(propName, v, types))
    case Function: return
    default: return checkTypes(propName, propValue, types)
  }
}

function isMissing (propValue) {
  return propValue === undefined || propValue === null
}

function applyValidator (validator, propName, propValue) {
  if (propName === 'curve') return validator(propName, propValue)

  switch (propValue.constructor) {
    case Array: return propValue.forEach(v => validator(propName, v))
    case Function: return
    default: validator(propName, propValue);
  }
}

function validateLayerSpecificProps (props, length) {
  if (!isMissing(props.keys)) validateKeys(props.keys, length);
}

function validateKeys (keys, length) {
  if (keys.constructor !== Array) throw new Error('keys: should be array')
  if (keys.length !== length) throw new Error('keys: should be of same length as positioning props')
  if (new Set(keys).size !== keys.length) throw new Error('keys: should be unique')
  if (!keys.every(key => key.constructor === String)) throw new Error('keys: should all be strings')
}

const colorValidator = (propName, value) => {
  if (value === 'none') return

  try {
    toRGBA(value);
  } catch {
    throw new Error(`${propName}: received invalid color: "${value}"`)
  }
};

const ratioValidator = (propName, value) => {
  if (value < 0 || value > 1) {
    throw new Error(`${propName}: value must be between 0 and 1, received "${value}"`)
  }
};

const ALLOWED_CLIP_VALUES = new Set(['padding', 'outer']);

const clipValidator = (propName, value) => {
  if (!ALLOWED_CLIP_VALUES.has(value)) {
    throw new Error(`${propName}: expected "padding" or "outer", received "${value}"`)
  }
};

const ALLOWED_LINEJOIN_VALUES = new Set(['bevel', 'round', 'miter']);

const lineJoinValidator = (propName, value) => {
  if (!ALLOWED_LINEJOIN_VALUES.has(value)) {
    throw new Error(`${propName}: expected "bevel", "round" or "miter", received "${value}"`)
  }
};

const positiveFiniteValidator = (propName, value) => {
  if (value <= 0 || !isFinite(value)) {
    throw new Error(`${propName}: value must be finite and over 0, received "${value}"`)
  }
};

const ALLOWED_LINECAP_VALUES = new Set(['butt', 'round', 'square']);

const lineCapValidator = (propName, value) => {
  if (!ALLOWED_LINECAP_VALUES.has(value)) {
    throw new Error(`${propName}: expected "butt", "round" or "square", received "${value}"`)
  }
};

const dashArrayValidator = (propName, value) => {
  if (!value.split(' ').map(v => +v).every(v => !isNaN(v))) {
    throw new Error(`${propName}: invalid dash array "${value}"`)
  }
};

const finiteValidator = (propName, value) => {
  if (!isFinite(value)) {
    throw new Error(`${propName}: expected finite number, received "${value}"`)
  }
};

const ALLOWED_ANCHOR_POINT_VALUES = new Set(['center', 'l', 'r', 'b', 't', 'lt', 'lb', 'rt', 'rb']);

const anchorPointValidator = (propName, value) => {
  if (!ALLOWED_ANCHOR_POINT_VALUES.has(value)) {
    throw new Error(`${propName}: invalid anchor point value "${value}"`)
  }
};

const ALLOWED_FONT_WEIGHT_VALUES = new Set(['normal', 'bold', 'bolder', 'lighter']);

const fontWeightValidator = (propName, value) => {
  if (value.constructor === String) {
    if (!ALLOWED_FONT_WEIGHT_VALUES.has(value)) {
      throw new Error(`${propName}: invalid font weight value "${value}"`)
    }
  }

  if (value.constructor === Number) {
    positiveFiniteValidator(propName, value);
  }
};

const ALLOWED_SHAPE_VALUES = new Set([
  'circle',
  'square',
  'cross',
  'cross-sharp',
  'diamond',
  'triangle-up',
  'triangle-down',
  'triangle-right',
  'triangle-left',
  'star4',
  'star5',
  'star',
  'star6',
  'star8',
  'pentagon',
  'hexagon',
  'heptagon',
  'septagon',
  'octagon',
  'nonagon',
  'decagon'
]);

const shapeValidator = (propName, value) => {
  if (value.constructor === String) {
    if (!ALLOWED_SHAPE_VALUES.has(value)) {
      throw new Error(`shape: invalid shape name "${value}"`)
    }
  }

  if (value.constructor === Object) {
    if (!['Polygon', 'MultiPolygon'].includes(value.type)) {
      throw new Error(`shape: expected one of types "Polygon,MultiPolygon", received "${value.type}"`)
    }
  }
};

const OTHER_PROPS_METADATA = {
  radius: { type: [Number], validator: positiveFiniteValidator },
  fill: { type: [String], validator: colorValidator },
  stroke: { type: [String], validator: colorValidator },
  strokeWidth: { type: [Number], validator: positiveFiniteValidator },
  opacity: { type: [Number], validator: ratioValidator },
  fillOpacity: { type: [Number], validator: ratioValidator },
  strokeOpacity: { type: [Number], validator: ratioValidator },
  lineJoin: { type: [String], validator: lineJoinValidator },
  lineCap: { type: [String], validator: lineCapValidator },
  miterLimit: { type: [Number], validator: positiveFiniteValidator },
  dashArray: { type: [String], validator: dashArrayValidator },
  dashOffset: { type: [Number], validator: finiteValidator },
  text: { type: [String] },
  rotate: { type: [Number], validator: finiteValidator },
  anchorPoint: { type: [String], validator: anchorPointValidator },
  fontSize: { type: [Number], validator: positiveFiniteValidator },
  fontFamily: { type: [String] },
  fontWeight: { type: [Number, String], validator: fontWeightValidator },
  curve: { type: [Function] },
  shape: { type: [String, Object], validator: shapeValidator },
  clip: { type: [String], validator: clipValidator },
  _resampleIntervals: { type: [Boolean] }
};

function parseOtherPropMetadata (propNames) {
  const parsedPropMetadata = {};

  propNames.forEach(propName => {
    parsedPropMetadata[propName] = OTHER_PROPS_METADATA[propName];
  });

  return parsedPropMetadata
}

const schema = {
  positioning: {
    props: ['x', 'y', 'x1', 'x2', 'y1', 'y2'],
    validCombinations: [new Set(['x', 'y1', 'y2']), new Set(['y', 'x1', 'x2'])],
    nonGeometryFormat: 'array'
  },

  other: [
    'curve',
    'fill',
    'stroke',
    'strokeWidth',
    'opacity',
    'fillOpacity',
    'strokeOpacity',
    'lineJoin',
    'miterLimit',
    'dashArray',
    'dashOffset',
    'clip'
  ]
};

/**
 * Validates Area props.
 * @param {Object} props See {@link createArea}
 */
function validateArea (props) {
  validateProps(props, schema);
}

/**
 * Validates AreaLayer props.
 * @param {Object} props See {@link createAreaLayer}
 */
function validateAreaLayer (props) {
  validatePropsLayer(props, schema);
}

// Inspired by https://github.com/d3/d3-geo/blob/master/src/stream.js
function streamGeometry (geometry, stream, i) {
  streamGeometryType[geometry.type](
    geometry.coordinates,
    stream,
    i
  );
}

function streamGeometries (geometries, stream) {
  let i = -1;

  while (++i < geometries.length) {
    const geometry = geometries[i];
    streamGeometryType[geometry.type](
      geometry.coordinates,
      stream,
      i
    );
    stream.markEnd();
  }
}

const streamGeometryType = {
  Point (c, stream, i) {
    stream.point(c[0], c[1]);
  },
  LineString (c, stream, i) {
    streamLineString(c, stream);
  },
  Polygon (c, stream, i) {
    streamPolygon$1(c, stream);
  },
  MultiLineString (c, stream, i) {
    let j = -1;

    while (++j < c.length) {
      stream.submarkStart();
      streamLineString(c[j], stream);
    }
  },
  MultiPolygon (c, stream, i) {
    let j = -1;

    while (++j < c.length) {
      stream.submarkStart();
      streamPolygon$1(c[j], stream);
    }
  }
};

function streamLineString (c, stream, closed = 0) {
  stream.lineStart();
  streamCoordArray(c, stream, closed);
  stream.lineEnd();
}

function streamPolygon$1 (c, stream) {
  let i = -1;
  stream.polygonStart();
  while (++i < c.length) streamLineString(c[i], stream, 1);
  stream.polygonEnd();
}

function streamCoordArray (c, stream, closed = 0) {
  let i = -1;
  const n = c.length - closed;
  while (++i < n) stream.point(c[i][0], c[i][1]);
}

function createPipeline$1 (props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    curveLinear,
    context
  )
}

function curveLinear (context) {
  return new CurveLinear(context)
}

// https://github.com/d3/d3-geo/blob/master/src/path/context.js
// TODO enable curves for polygons?
function CurveLinear (context) {
  this._context = context;
}

CurveLinear.prototype = {
  polygonStart () {
    this._line = 0;
  },
  polygonEnd () {
    this._line = NaN;
  },
  lineStart () {
    this._point = 0;
  },
  lineEnd () {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point (x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break
      }
      default: {
        this._context.lineTo(x, y);
      }
    }
  }
};

function createPipeline$2 (props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? polarConnector(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    section.coordinateSystem ? null : curveLinear,
    context
  )
}

function polarConnector (coordinateSystem) {
  return context => new PolarConnector(coordinateSystem, context)
}

class PolarConnector {
  constructor (coordinateSystem, context) {
    this._coordinateSystem = coordinateSystem;
    this._context = context;
    this._overallDirectionIsClockwise = overallDirectionIsClockwise(coordinateSystem);
  }

  polygonStart () {
    this._line = 0;
    this._arc = 0;
  }

  polygonEnd () {
    this._line = NaN;
  }

  lineStart () {
    this._point = 0;
  }

  lineEnd () {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  }

  point (theta, r) {
    const x = this._coordinateSystem.x(theta, r);
    const y = this._coordinateSystem.y(theta, r);

    const adjustedTheta = adjustTheta(theta, this._coordinateSystem);

    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        this._lastTheta = adjustedTheta;
        break
      }
      default: {
        this._handlePolarSegment(x, y, adjustedTheta, r);
        this._lastTheta = adjustedTheta;
      }
    }
  }

  _handlePolarSegment (x, y, theta, r) {
    if (this._lastTheta === theta) {
      this._context.lineTo(x, y);
    } else {
      const { midX, midY, halfWidth, halfHeight } = this._coordinateSystem;
      const ccw = getCcw(this._arc, this._overallDirectionIsClockwise);

      this._context.ellipse(
        midX,
        midY,
        halfWidth * r,
        halfHeight * r,
        0,
        this._lastTheta,
        theta,
        ccw
      );

      this._arc = 1;
    }
  }
}

const TWO_PI$2 = Math.PI * 2;

function adjustTheta (theta, { flipX, flipY }) {
  if (!flipY && !flipX) return theta
  if (flipY && !flipX) return TWO_PI$2 - theta
  if (!flipY && flipX) return Math.PI - theta
  return Math.PI + theta
}

function overallDirectionIsClockwise ({ flipX, flipY }) {
  if (!flipY && !flipX) return true
  if (flipY && !flipX) return false
  if (!flipY && flipX) return false
  return true
}

function getCcw (arc, overallDirectionIsClockwise) {
  if (arc === 0 && overallDirectionIsClockwise) return 0
  if (arc === 1 && overallDirectionIsClockwise) return 1
  if (arc === 0 && !overallDirectionIsClockwise) return 1
  return 0
}

function createPipeline$3 (props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem && !props._resampleIntervals ? transform(section.coordinateSystem) : null,
    section.coordinateSystem && props._resampleIntervals ? polarConnector(section.coordinateSystem) : props.curve,
    outputSettings.round ? round(outputSettings.decimals) : null,
    context
  )
}

function parseLine (props, section) {
  const { parsedProps, scales } = parsePositioning(props, section);
  parseAesthetics$3(props, parsedProps);

  return { props: parsedProps, scales }
}

const parsePositioningLine = parsePositioning;
const parsePositioningLineLayer = parsePositioning;

const parseAestheticsLine = parseAesthetics$3;
const parseAestheticsLineLayer = parseAesthetics$3;

function parseAesthetics$3 (props, parsedProps) {
  parsedProps = parsedProps ?? {};

  parsedProps.curve = fallback(props.curve, curveLinear$1);
  parsedProps.strokeWidth = fallback(props.strokeWidth, 3);
  parsedProps.stroke = fallback(props.stroke, 'black');

  OPTIONAL_AESTHETICS$1.forEach(style => {
    if (props[style]) parsedProps[style] = props[style];
  });

  return parsedProps
}

const OPTIONAL_AESTHETICS$1 = [
  'opacity', 'lineCap', 'lineJoin', 'miterLimit',
  'dashArray', 'dashOffset', 'opacity', 'keys', 'clip', 'asOnePath',
  '_resampleIntervals'
];

const markStyler$1 = {
  apply: applyStyling$1
};

const layerStyler$1 = {
  create (props) {
    const keys = props.keys;

    const getAesthetics = batchAestheticGetter(
      props,
      AESTHETICS$1,
      keys
    );

    return function apply (context, i) {
      const aesthetics = getAesthetics(i);
      applyStyling$1(context, aesthetics);
    }
  },

  asOnePath (props) {
    return props.asOnePath && areAllStylesGlobal(props, AESTHETICS$1)
  }
};

const AESTHETICS$1 = [
  'stroke', 'strokeWidth', 'opacity',
  'lineCap', 'lineJoin', 'miterLimit', 'dashArray', 'dashOffset'
];

function applyStyling$1 (context, aesthetics) {
  if (aesthetics.lineCap) {
    context.lineCap = aesthetics.lineCap;
  }

  if (aesthetics.lineJoin) {
    context.lineJoin = aesthetics.lineJoin;

    if (aesthetics.lineJoin === 'miter' && aesthetics.miterLimit !== undefined) {
      context.miterLimit = aesthetics.miterLimit;
    }
  }

  if (aesthetics.dashArray) {
    context.setLineDash(aesthetics.dashArray.split(' ').map(x => parseInt(x)));

    if (aesthetics.dashOffset) {
      context.lineDashOffset = aesthetics.dashOffset;
    }
  }

  const strokeStyle = getStrokeStyle(aesthetics);

  context.lineWidth = aesthetics.strokeWidth;
  context.strokeStyle = strokeStyle;
  context.fillStyle = 'none';
  context.stroke();
}

/**
 * Creates a Line mark.
 *
 * Valid prop combinations for positioning include:
 *  - x and y
 *  - geometry
 *
 * @param {object} props
 * @param {Array|function} props.x An array of x-coordinates, or a function that returns an array of original x-coordinates.
 * @param {Array|function} props.y An array of y-coordinates, or a function that returns an array of original y-coordinates.
 * @param {Object} [props.geometry] A GeoJSON LineString or MultiLineString geometry.
 * @param {Object} [props.curve=d3shape.curveLinear] A d3-shape curve.
 * @param {string} [props.stroke='black'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number} [props.strokeWidth=3] The stroke width in pixels.
 * @param {number} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {string} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {string} [props.lineJoin='bevel'] Controls how lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {number} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {string} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {number} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {boolean} [props._resampleIntervals=false] Resamples line intervals if parent section has coordinate system other than cartesian.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Mark} A Mark object.
 */
function createLine (_props, section, outputSettings) {
  const { props, scales } = parseLine(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$2(props, section, scales, outputSettings);

  return new Mark(
    positioning,
    props,
    section,
    markStyler$1,
    'Line'
  )
}

function getPositioning$2 (props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const markRecorder = recorderMark();

  const pipeline = createPipeline$3(props, section, scales, markRecorder, outputSettings);

  if (positioningMethod === 'florence') {
    streamLine(props, pipeline);
  }

  if (positioningMethod === 'geojson') {
    streamGeometry(props.geometry, pipeline);
  }

  return markRecorder.result()
}

function parseFuncLine (props, section) {
  const parsedProps = parsePositioningFuncLine(props, section);
  return parseAesthetics$3(props, parsedProps)
}

function parsePositioningFuncLine (props, section) {
  const parsedProps = {
    func: props.func,
    x: fallback(props.x, getDomainX(section)),
    resolution: fallback(props.resolution, 3)
  };

  return parsedProps
}

const parseAestheticsFuncLine = parseAesthetics$3;

function getDomainX ({ scaleX, rangeX }) {
  return scaleX && scaleX.constructor === Function && scaleX.domain
    ? scaleX.domain()
    : rangeX
}

/**
 * Creates a FuncLine mark.
 *
 * @param {Object} props
 * @param {function} props.func The function to draw.
 * @param {Array} [props.x] An array of length 2, indicating the x-domain over which to draw the function.
 * @param {number} [props.resolution=3] The interpolation resolution in pixels. Lower means more detail but slower performance.
 * @param {string} [props.stroke='black'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number} [props.strokeWidth=3] The stroke width in pixels.
 * @param {number} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {string} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {string} [props.lineJoin='bevel'] Controls how lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {number} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {string} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {number} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Mark} A Mark object.
 */
function createFuncLine (_props, section, outputSettings) {
  const props = parseFuncLine(_props, section);

  const lineCoordinates = generateLineCoordinates(props, section);
  const lineProps = mergeProps(lineCoordinates, props);

  const funcLine = createLine(lineProps, section, outputSettings);
  funcLine.type = 'FuncLine';

  return funcLine
}

function generateLineCoordinates (props, section) {
  const rangeX = section.ranges.rangeX;
  const numberOfPoints = Math.abs(rangeX[0] - rangeX[1]) / props.resolution;

  return interpolatePoints(props.func, props.x, numberOfPoints)
}

function interpolatePoints (func, domainX, numberOfPoints) {
  const points = { x: [], y: [] };
  const delta = (domainX[1] - domainX[0]) / numberOfPoints;

  for (let i = 0; i <= numberOfPoints; i++) {
    const x = domainX[0] + delta * i;
    const y = func(x);

    points.x.push(x);
    points.y.push(y);
  }

  return points
}

const POSITIONING_PROPS = new Set(['func', 'x', 'resolution']);

function mergeProps (lineCoordinates, props) {
  const mergedProps = Object.assign(lineCoordinates, {});

  for (const propName in props) {
    if (!POSITIONING_PROPS.has(propName)) {
      mergedProps[propName] = props[propName];
    }
  }

  mergedProps.curve = curveLinear$1;

  return mergedProps
}

const schema$1 = {
  other: [
    'curve',
    'stroke',
    'strokeWidth',
    'opacity',
    'lineJoin',
    'miterLimit',
    'lineCap',
    'dashArray',
    'dashOffset',
    'clip',
    '_resampleIntervals'
  ],

  custom (props) {
    validateFunc(props.func);
    validateX(props.x);
    positiveFiniteValidator('resolution', props.resolution);
  }
};

/**
 * Validates FuncLine props.
 * @param {Object} props See {@link createFuncLine}
 */
function validateFuncLine (props) {
  validateProps(props, schema$1);
}

function validateFunc (func) {
  if (func.constructor !== Function) {
    throw new Error(`func: must be a Function, received "${func.constructor.name}"`)
  }
}

function validateX (x) {
  if (x.constructor !== Array || x.length !== 2 || !x.every(v => v.constructor === Number)) {
    throw new Error(`x: invalid domain "${JSON.stringify(x)}"`)
  }
}

function createMarkPipeline (props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    labelConnector(props),
    context
  )
}

function createLayerPipeline (props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    labelLayerConnector(props),
    context
  )
}

function labelConnector (props) {
  return function (context) {
    return {
      point (x, y) {
        context.translate(x, y);

        if (props.rotate) {
          context.rotate(props.rotate);
        }
      }
    }
  }
}

function labelLayerConnector (props) {
  const keys = props.keys;
  const getRotate = aestheticGetter(props.rotate, keys);

  let currentLabel = 0;

  return function (context) {
    return {
      point (x, y) {
        const rotate = getRotate(currentLabel);

        context.translate(x, y);

        if (rotate) {
          context.rotate(rotate);
        }

        currentLabel++;
      }
    }
  }
}

function parseLabel (props, section) {
  let { parsedProps, scales } = parsePositioning(props, section);
  parsedProps = parseAesthetics$4(props, parsedProps);

  return { props: parsedProps, scales }
}

const parsePositioningLabel = parsePositioning;
const parsePositioningLabelLayer = parsePositioning;

const parseAestheticsLabel = parseAesthetics$4;
const parseAestheticsLabelLayer = parseAesthetics$4;

function parseAesthetics$4 (props, parsedProps) {
  parsedProps = parsedProps ?? {};

  parsedProps.text = fallback(props.text, 'Text');
  if (props.rotate) parsedProps.rotate = props.rotate;
  parsedProps.anchorPoint = fallback(props.anchorPoint, 'center');
  parsedProps.fontSize = fallback(props.fontSize, 16);
  parsedProps.fontFamily = fallback(props.fontFamily, 'Helvetica');
  parsedProps.fontWeight = fallback(props.fontWeight, 'normal');

  return parseAesthetics$1(props, parsedProps)
}

const markStyler$2 = {
  apply (context, props) {
    const font = getFont(props);
    const anchorPoint = getAnchorPoint(props);
    const strokeStyle = getStrokeStyle(props);
    const fillStyle = getFillStyle(props);

    applyStyling$2(
      context,
      font,
      anchorPoint,
      fillStyle,
      props.text,
      strokeStyle,
      props.strokeWidth
    );
  }
};

const layerStyler$2 = {
  create (props) {
    const keys = props.keys;

    const getAesthetics = batchAestheticGetter(
      props,
      AESTHETICS$2,
      keys
    );

    const getText = aestheticGetter(props.text, keys);

    return function apply (context, i) {
      const text = getText(i);
      const aesthetics = getAesthetics(i);
      const font = getFont(aesthetics);
      const anchorPoint = getAnchorPoint(aesthetics);
      const strokeStyle = getStrokeStyle(aesthetics);
      const fillStyle = getFillStyle(aesthetics);

      applyStyling$2(
        context,
        font,
        anchorPoint,
        fillStyle,
        text,
        strokeStyle,
        aesthetics.strokeWidth
      );
    }
  },

  asOnePath () { return false }
};

const AESTHETICS$2 = [
  'fontWeight', 'fontSize', 'fontFamily', 'stroke', 'strokeOpacity',
  'strokeWidth', 'fill', 'fillOpacity', 'opacity', 'anchorPoint'
];

function applyStyling$2 (context, font, anchorPoint, fillStyle, text, strokeStyle, strokeWidth) {
  context.font = font;
  context.textBaseline = anchorPoint.textBaseline;
  context.textAlign = anchorPoint.textAlign;

  if (fillStyle) {
    context.fillStyle = fillStyle;
    context.fillText(text, 0, 0);
  }

  if (strokeStyle) {
    context.lineWidth = strokeWidth;
    context.strokeStyle = strokeStyle;
    context.strokeText(text, 0, 0);
  }

  context.setTransform(1, 0, 0, 1, 0, 0);
}

/**
 * Creates a Label mark.
 *
 * Valid prop combinations for positioning include:
 *  - x and y
 *  - geometry
 *
 * @param {Object} props
 * @param {*} [props.x] A x-coordinate, or a function that returns an original x-coordinate.
 * @param {*} [props.y] A y-coordinate, or a function that returns an original y-coordinate.
 * @param {Object} [props.geometry] A GeoJSON Point geometry.
 * @param {string} [props.text='Text'] The text that the label should display.
 * @param {number} [props.rotate=0] The text rotation around the anchor point in radians.
 * @param {string} [props.anchorPoint='center'] Can be 'center', 'lt', 'lb', 'rt', 'rb', 'l', 'r', 't', or 'b'.
 * @param {number} [props.fontSize=16] The font size in pixels.
 * @param {string} [props.fontFamily='Helvetica'] The font family.
 * @param {(string|number)} [props.fontWeight='normal'] The font weight.
 * @param {string} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {string} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number} [props.strokeWidth=1] The stroke width in pixels.
 * @param {number} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {number} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {number} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Mark} A Mark object.
 */
function createLabel (_props, section, outputSettings) {
  const { props, scales } = parseLabel(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$3(props, section, scales, outputSettings);

  return new Mark(
    positioning,
    props,
    section,
    markStyler$2,
    'Label'
  )
}

function getPositioning$3 (props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const markRecorder = recorderLabel();

  const pipeline = createMarkPipeline(props, section, scales, markRecorder, outputSettings);

  if (positioningMethod === 'florence') {
    streamPoint(props, pipeline);
  }

  if (positioningMethod === 'geojson') {
    streamGeometry(props.geometry, pipeline);
  }

  return markRecorder.result()
}

/**
 * Creates a Label layer.
 *
 * Valid prop combinations for positioning include:
 *  - x and y
 *  - geometry
 *
 * @param {Object} props
 * @param {Array|function} [props.x] An array of x-coordinates, or a function that returns an array of original x-coordinates.
 * @param {Array|function} [props.y] An array of y-coordinates, or a function that returns an array of original y-coordinates.
 * @param {Object[]} [props.geometry] An array of GeoJSON Point geometries.
 * @param {string|string[]|function} [props.text='Text'] The text that the label should display.
 * @param {number|number[]|function} [props.rotate=0] The text rotation around the anchor point in radians.
 * @param {string|string[]|function} [props.anchorPoint='center'] Can be 'center', 'lt', 'lb', 'rt', 'rb', 'l', 'r', 't', or 'b'.
 * @param {number|number[]|function} [props.fontSize=16] The font size in pixels.
 * @param {string|string[]|function} [props.fontFamily='Helvetica'] The font family.
 * @param {string|string[]|function} [props.fontWeight='normal'] The font weight.
 * @param {string|string[]|function} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {string|string[]|function} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number|number[]|function} [props.strokeWidth=1] The stroke width in pixels.
 * @param {number|number[]|function} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {number|number[]|function} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {number|number[]|function} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {string[]} [props.keys] An array of unique keys. Must be strings.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Layer} A Layer object.
 */
function createLabelLayer (_props, section, outputSettings) {
  const { props, scales } = parseLabel(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$4(props, section, scales, outputSettings);

  return new Layer(
    positioning,
    props,
    section,
    layerStyler$2,
    'Label'
  )
}

function getPositioning$4 (props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const layerRecorder = recorderLabelLayer();

  const pipeline = createLayerPipeline(props, section, scales, layerRecorder, outputSettings);

  if (positioningMethod === 'florence') {
    streamPointLayer(props, pipeline);
  }

  if (positioningMethod === 'geojson') {
    streamGeometries(props.geometry, pipeline);
  }

  return layerRecorder.result()
}

const schema$2 = {
  positioning: {
    props: ['x', 'y', 'geometry'],
    validCombinations: [new Set(['x', 'y']), new Set(['geometry'])],
    nonGeometryFormat: 'value',
    allowedGeometryTypes: new Set(['Point'])
  },

  other: [
    'text',
    'rotate',
    'anchorPoint',
    'fontSize',
    'fontFamily',
    'fontWeight',
    'fill',
    'stroke',
    'strokeWidth',
    'opacity',
    'fillOpacity',
    'strokeOpacity',
    'clip'
  ]
};

/**
 * Validates Label props.
 * @param {Object} props See {@link createLabel}
 */
function validateLabel (props) {
  validateProps(props, schema$2);
}

/**
 * Validates LabelLayer props.
 * @param {Object} props See {@link createLabelLabel}
 */
function validateLabelLayer (props) {
  validatePropsLayer(props, schema$2);
}

/**
 * Creates a Line layer.
 *
 * Valid prop combinations for positioning include:
 *  - x and y
 *  - geometry
 *
 * @param {object} props
 * @param {(Array.<Array>|function)} props.x An array of x-coordinates, or a function that returns an array of original x-coordinates.
 * @param {(Array.<Array>|function)} props.y An array of y-coordinates, or a function that returns an array of original y-coordinates.
 * @param {Object[]} [props.geometry] An array of GeoJSON LineString or MultiLineString geometries.
 * @param {Object} [props.curve=d3shape.curveLinear] A d3-shape curve.
 * @param {(string|string[]|function)} [props.stroke='black'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {(number|number[]|function)} [props.strokeWidth=3] The stroke width in pixels.
 * @param {(number|number[]|function)} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {(string|string[]|function)} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {(string|string[]|function)} [props.lineJoin='bevel'] Controls how lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {(number|number[]|function)} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {(string|string[]|function)} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {(number|number[]|function)} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string[]} [props.keys] An array of unique keys. Must be strings.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {boolean} [props.asOnePath=false] If true, draws whole layer as one path.
 * @param {boolean} [props._resampleIntervals=false] Resamples line intervals if parent section has coordinate system other than cartesian.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Layer} A Layer object.
 */
function createLineLayer (_props, section, outputSettings) {
  const { props, scales } = parseLine(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$5(props, section, scales, outputSettings);

  return new Layer(
    positioning,
    props,
    section,
    layerStyler$1,
    'Line'
  )
}

function getPositioning$5 (props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const layerRecorder = recorderLayer();

  const pipeline = createPipeline$3(props, section, scales, layerRecorder, outputSettings);

  if (positioningMethod === 'florence') {
    streamLineLayer(props, pipeline);
  }

  if (positioningMethod === 'geojson') {
    streamGeometries(props.geometry, pipeline);
  }

  return layerRecorder.result()
}

const schema$3 = {
  positioning: {
    props: ['x', 'y', 'geometry'],
    validCombinations: [new Set(['x', 'y']), new Set(['geometry'])],
    nonGeometryFormat: 'array',
    allowedGeometryTypes: new Set(['LineString', 'MultiLineString'])
  },

  other: [
    'curve',
    'stroke',
    'strokeWidth',
    'opacity',
    'lineJoin',
    'miterLimit',
    'lineCap',
    'dashArray',
    'dashOffset',
    'clip',
    '_resampleIntervals'
  ]
};

/**
 * Validates Line props.
 * @param {Object} props See {@link createLine}
 */
function validateLine (props) {
  validateProps(props, schema$3);
}

/**
 * Validates LineLayer props.
 * @param {Object} props See {@link createLineLayer}
 */
function validateLineLayer (props) {
  validatePropsLayer(props, schema$3);
}

function createMarkPipeline$1 (props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    outputSettings.round ? round(outputSettings.decimals) : null,
    pointConnector(props),
    context
  )
}

function createLayerPipeline$1 (props, section, scales, context, outputSettings) {
  return chain(
    scale(scales),
    section.coordinateSystem ? transform(section.coordinateSystem) : null,
    round(outputSettings.decimals),
    pointLayerConnector(props),
    context
  )
}

const TAU = 2 * Math.PI;

function pointConnector (props) {
  return function (context) {
    return {
      point (x, y) {
        context.arc(x, y, props.radius, 0, TAU);
      }
    }
  }
}

function pointLayerConnector (props) {
  const keys = props.keys;
  const getRadius = aestheticGetter(props.radius, keys);

  let currentPoint = 0;

  return function (context) {
    return {
      point (x, y) {
        const radius = getRadius(currentPoint);
        context.moveTo(x + radius, y);
        context.arc(x, y, radius, 0, TAU);

        currentPoint++;
      }
    }
  }
}

/**
 * Creates a Point mark.
 *
 * Valid prop combinations for positioning include:
 *  - x and y
 *  - geometry
 *
 * @param {Object} props
 * @param {Object} props.x A x-coordinate, or a function that returns an original x-coordinate.
 * @param {Object} props.y A y-coordinate, or a function that returns an original y-coordinate.
 * @param {Object} [props.geometry] A GeoJSON Point geometry.
 * @param {number} [props.radius=3] The radius of the point in pixels.
 * @param {string} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {string} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number} [props.strokeWidth=1] The stroke width in pixels.
 * @param {number} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {number} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {number} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {string} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {string} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {number} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Mark} A Mark object.
 */
function createPoint (_props, section, context, outputSettings) {
  const { props, scales } = parsePoint(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$6(props, section, scales, outputSettings);

  return new Mark(
    positioning,
    props,
    section,
    markStyler,
    'Point'
  )
}

function getPositioning$6 (props, section, scales, outputSettings) {
  const markRecorder = recorderMark();
  stream(props, section, scales, markRecorder, outputSettings);

  return markRecorder.result()
}

function stream (props, section, scales, context, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const pipeline = createMarkPipeline$1(props, section, scales, context, outputSettings);

  if (positioningMethod === 'florence') {
    streamPoint(props, pipeline);
  }

  if (positioningMethod === 'geojson') {
    streamGeometry(props.geometry, pipeline);
  }
}

/**
 * Creates a Point layer.
 *
 * Valid prop combinations for positioning include:
 *  - x and y
 *  - geometry
 *
 * @param {Object} props
 * @param {Array|function} props.x An array of x-coordinates, or a function that returns an array of original x-coordinates.
 * @param {Array|function} props.y An array of y-coordinates, or a function that returns an array of original y-coordinates.
 * @param {Object[]} [props.geometry] An array of GeoJSON Point geometries.
 * @param {number|number[]|function} [props.radius=3] The radius of the point in pixels.
 * @param {string|string[]|function} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {string|string[]|function} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number|number[]|function} [props.strokeWidth=1] The stroke width in pixels.
 * @param {number|number[]|function} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {number|number[]|function} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {number|number[]|function} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {(string|string[]|function)} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {(string|string[]|function)} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {(number|number[]|function)} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string[]} [props.keys] An array of unique keys. Must be strings.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {boolean} [props.asOnePath=false] If true, draws whole layer as one path. Currently only works for canvas.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Layer} A Layer object.
 */
function createPointLayer (_props, section, outputSettings) {
  const { props, scales } = parsePoint(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$7(props, section, scales, outputSettings);

  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    'Point'
  )
}

function getPositioning$7 (props, section, scales, outputSettings) {
  const layerRecorder = recorderLayer();
  stream$1(props, section, scales, layerRecorder, outputSettings);

  return layerRecorder.result()
}

function stream$1 (props, section, scales, context, outputSettings) {
  const positioningMethod = getPositioningMethod(props);

  const pipeline = createLayerPipeline$1(props, section, scales, context, outputSettings);

  if (positioningMethod === 'florence') {
    streamPointLayer(props, pipeline);
  }

  if (positioningMethod === 'geojson') {
    streamGeometries(props.geometry, pipeline);
  }
}

const schema$4 = {
  positioning: {
    props: ['x', 'y', 'geometry'],
    validCombinations: [new Set(['x', 'y']), new Set(['geometry'])],
    nonGeometryFormat: 'value',
    allowedGeometryTypes: new Set(['Point'])
  },

  other: [
    'radius',
    'fill',
    'stroke',
    'strokeWidth',
    'opacity',
    'fillOpacity',
    'strokeOpacity',
    'lineJoin',
    'miterLimit',
    'dashArray',
    'dashOffset',
    'clip'
  ]
};

/**
 * Validates Point props.
 * @param {Object} props See {@link createPoint}
 */
function validatePoint (props) {
  validateProps(props, schema$4);
}

/**
 * Validates PointLayer props.
 * @param {Object} props See {@link createPointLayer}
 */
function validatePointLayer (props) {
  validatePropsLayer(props, schema$4);
}

/**
 * Creates a Polygon mark.
 *
 * Valid prop combinations for positioning include:
 *  - x and y
 *  - geometry
 *
 * @param {Object} props
 * @param {(Array|function)} [props.x] An array of x-coordinates, or a function that returns an array of original x-coordinates.
 * @param {(Array|function)} [props.y] An array of y-coordinates, or a function that returns an array of original y-coordinates.
 * @param {Object} [props.geometry] A GeoJSON Polygon or MultiPolygon geometry.
 * @param {string} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {string} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number} [props.strokeWidth=1] The stroke width in pixels.
 * @param {number} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {number} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {number} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {string} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {string} [props.lineJoin='bevel'] Controls how lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {number} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {string} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {number} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Mark} A Mark object.
 */
function createPolygon (_props, section, outputSettings) {
  const { props, scales } = parsePolygon(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$8(props, section, scales, outputSettings);

  return new Mark(
    positioning,
    props,
    section,
    markStyler,
    'Polygon'
  )
}

function getPositioning$8 (props, section, scales, outputSettings) {
  const markRecorder = recorderMark();
  stream$2(props, section, scales, markRecorder, outputSettings);

  return markRecorder.result()
}

function stream$2 (props, section, scales, context, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const pipeline = createPipeline$1(props, section, scales, context, outputSettings);

  if (positioningMethod === 'florence') {
    streamPolygon(props, pipeline);
  }

  if (positioningMethod === 'geojson') {
    streamGeometry(props.geometry, pipeline);
  }
}

/**
 * Creates a Polygon layer.
 *
 * Valid prop combinations for positioning include:
 *  - x and y
 *  - geometry
 *
 * @param {Object} props
 * @param {(Array.<Array>|function)} [props.x] A nested array of x-coordinates, or a function that returns a nested array of original x-coordinates.
 * @param {(Array.<Array>|function)} [props.y] A nested array of y-coordinates, or a function that returns a nested array of original y-coordinates.
 * @param {Object[]} [props.geometry] An array of GeoJSON Polygon or MultiPolygon geometries.
 * @param {(string|string[]|function)} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {(string|string[]|function)} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {(number|number[]|function)} [props.strokeWidth=1] The stroke width in pixels.
 * @param {(number|number[]|function)} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {(number|number[]|function)} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {(number|number[]|function)} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {(string|string[]|function)} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {(string|string[]|function)} [props.lineJoin='bevel'] How lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {(number|number[]|function)} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {(string|string[]|function)} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {(number|number[]|function)} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string[]} [props.keys] An array of unique keys. Must be strings.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {boolean} [props.asOnePath=false] If true, draws whole layer as one path.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Layer} A Layer object.
 */
function createPolygonLayer (_props, section, context, outputSettings) {
  const { props, scales } = parsePolygon(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$9(props, section, scales, outputSettings);

  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    'Polygon'
  )
}

function getPositioning$9 (props, section, scales, outputSettings) {
  const positioningMethod = getPositioningMethod(props);
  const layerRecorder = recorderLayer();

  const pipeline = createPipeline$1(props, section, scales, layerRecorder, outputSettings);

  if (positioningMethod === 'florence') {
    streamPolygonLayer(props, pipeline);
  }

  if (positioningMethod === 'geojson') {
    streamGeometries(props.geometry, pipeline);
  }

  return layerRecorder.result()
}

const schema$5 = {
  positioning: {
    props: ['x', 'y', 'geometry'],
    validCombinations: [new Set(['x', 'y']), new Set(['geometry'])],
    nonGeometryFormat: 'array',
    allowedGeometryTypes: new Set(['Polygon', 'MultiPolygon'])
  },

  other: [
    'fill',
    'stroke',
    'strokeWidth',
    'opacity',
    'fillOpacity',
    'strokeOpacity',
    'lineJoin',
    'miterLimit',
    'dashArray',
    'dashOffset',
    'clip'
  ]
};

/**
 * Validates Polygon props.
 * @param {Object} props See {@link createPolygon}
 */
function validatePolygon (props) {
  validateProps(props, schema$5);
}

/**
 * Validates PolygonLayer props.
 * @param {Object} props See {@link createPolygonLayer}
 */
function validatePolygonLayer (props) {
  validatePropsLayer(props, schema$5);
}

const parseRectangle = parser(parsePositioning$1);
const parseRectangleLayer = parser(parsePositioningLayer);

function parsePositioning$1 ({ x1, x2, y1, y2 }, section) {
  const rangeX = section.scaleX.range();
  const rangeY = section.scaleY.range();

  return {
    x1: isDefined(x1) ? getCoordX$1(x1, section) : rangeX[0],
    x2: isDefined(x2) ? getCoordX$1(x2, section) : rangeX[1],
    y1: isDefined(y1) ? getCoordY$1(y1, section) : rangeY[0],
    y2: isDefined(y2) ? getCoordY$1(y2, section) : rangeY[1]
  }
}

const parsePositioningRectangle = parsePositioning$1;
const parsePositioningRectangleLayer = parsePositioningLayer;

const parseAestheticsRectangle = parseAesthetics$1;
const parseAestheticsRectangleLayer = parseAesthetics$1;

function parsePositioningLayer (props, section) {
  const length = getLength(props);
  const { x1, x2, y1, y2 } = props;

  const rangeX = section.scaleX.range();
  const rangeY = section.scaleY.range();

  return {
    x1: isDefined(x1) ? getCoordsX$1(x1, section) : repeat(rangeX[0], length),
    x2: isDefined(x2) ? getCoordsX$1(x2, section) : repeat(rangeX[1], length),
    y1: isDefined(y1) ? getCoordsY$1(y1, section) : repeat(rangeY[0], length),
    y2: isDefined(y2) ? getCoordsY$1(y2, section) : repeat(rangeY[1], length)
  }
}

function parser (positioningFn) {
  return function (props, section) {
    const parsedProps = positioningFn(props, section);
    parseAesthetics$1(props, parsedProps);

    return parsedProps
  }
}

const getCoordX$1 = coordGetter$1('scaleX');
const getCoordY$1 = coordGetter$1('scaleY');

function coordGetter$1 (scale) {
  return function (coord, section) {
    if (propBypassesScaling(coord)) {
      return coord(section)
    }

    return section[scale](coord)
  }
}

const getCoordsX$1 = coordsGetter$1('scaleX');
const getCoordsY$1 = coordsGetter$1('scaleY');

function coordsGetter$1 (scale) {
  return function (coord, section) {
    if (propBypassesScaling(coord)) {
      return coord(section)
    }

    return coord.map(section[scale])
  }
}

const LENGTH_PROPS = ['x1', 'x2', 'y1', 'y2', 'key'];

function getLength (props) {
  for (const propName of LENGTH_PROPS) {
    const prop = props[propName];

    if (prop && prop.constructor === Array) {
      return prop.length
    }
  }
}

/**
 * Creates a Rectangle mark.
 *
 * Any positioning prop (i.e. x1, x2 etc) can be left out, in which case it will be replaced
 * by the corresponding padded extent of the parent section. So for example, leaving out all of them
 * will simply draw a rectangle the size of the padded area of the parent section.
 *
 * @param {Object} props
 * @param {*} [props.x1] A x-coordinate, or a function that returns an original x-coordinate.
 * @param {*} [props.x2] A x-coordinate, or a function that returns an original x-coordinate.
 * @param {*} [props.y1] A y-coordinate, or a function that returns an original y-coordinate.
 * @param {*} [props.y2] A y-coordinate, or a function that returns an original y-coordinate.
 * @param {string} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {string} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number} [props.strokeWidth=1] The stroke width in pixels.
 * @param {number} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {number} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {number} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {string} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {string} [props.lineJoin='bevel'] Controls how lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {number} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {string} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {number} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Mark} A Mark object.
 */
function createRectangle (_props, section, outputSettings) {
  const props = parseRectangle(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$a(props, section, outputSettings);

  return new Mark(
    positioning,
    props,
    section,
    markStyler,
    'Rectangle'
  )
}

function getPositioning$a (props, section, outputSettings) {
  const markRecorder = recorderMark();

  const pipeline = createPipeline$2(props, section, section.indirectScales, markRecorder, outputSettings);

  streamRectangle(props, pipeline);

  return markRecorder.result()
}

/**
 * Creates a Rectangle layer.
 *
 * Three out of four positioning props (i.e. x1, x2 etc) can be left out, in which case it will be replaced
 * by the corresponding padded extent of the parent section. So for example, only x1 can be defined, and the
 * remaining props will be stretched to the padded extents of the parent section.
 *
 * @param {Object} props
 * @param {(Array|function)} [props.x1] An array of x-coordinates, or a function that returns an array of original x-coordinates.
 * @param {(Array|function)} [props.x2] An array of x-coordinates, or a function that returns an array of original x-coordinates.
 * @param {(Array|function)} [props.y1] An array of y-coordinates, or a function that returns an array of original y-coordinates.
 * @param {(Array|function)} [props.y2] An array of y-coordinates, or a function that returns an array of original y-coordinates.
 * @param {(string|string[]|function)} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {(string|string[]|function)} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {(number|number[]|function)} [props.strokeWidth=1] The stroke width in pixels.
 * @param {(number|number[]|function)} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {(number|number[]|function)} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {(number|number[]|function)} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {(string|string[]|function)} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {(string|string[]|function)} [props.lineJoin='bevel'] How lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {(number|number[]|function)} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {(string|string[]|function)} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {(number|number[]|function)} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string[]} [props.keys] An array of unique keys. Must be strings.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {boolean} [props.asOnePath=false] If true, draws whole layer as one path.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Layer} A Layer object.
 */
function createRectangleLayer (_props, section, outputSettings) {
  const props = parseRectangleLayer(_props, section);
  outputSettings = parseOutputSettings(outputSettings);

  const positioning = getPositioning$b(props, section, outputSettings);

  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    'Rectangle'
  )
}

function getPositioning$b (props, section, outputSettings) {
  const layerRecorder = recorderLayer();

  const pipeline = createPipeline$2(props, section, section.indirectScales, layerRecorder, outputSettings);

  streamRectangleLayer(props, pipeline);

  return layerRecorder.result()
}

const schema$6 = {
  positioning: {
    props: ['x1', 'x2', 'y1', 'y2'],
    validCombinations: 'any',
    nonGeometryFormat: 'value'
  },

  other: [
    'fill',
    'stroke',
    'strokeWidth',
    'opacity',
    'fillOpacity',
    'strokeOpacity',
    'lineJoin',
    'miterLimit',
    'dashArray',
    'dashOffset',
    'clip'
  ],

  custom: (props, what) => {
    if (what === 'layer') {
      if (
        isMissing(props.x1) &&
        isMissing(props.x2) &&
        isMissing(props.y1) &&
        isMissing(props.y2)
      ) {
        throw new Error('Rectangle layer requires at least one positioning prop to be defined')
      }
    }
  }
};

/**
 * Validates Rectangle props.
 * @param {Object} props See {@link createRectangle}
 */
function validateRectangle (props) {
  validateProps(props, schema$6);
}

/**
 * Validates RectangleLayer props.
 * @param {Object} props See {@link createRectangleLayer}
 */
function validateRectangleLayer (props) {
  validatePropsLayer(props, schema$6);
}

function parseSymbol (props, section) {
  const parsedProps = parsePositioning$2(props);
  parseAesthetics$5(props, parsedProps);

  return parsedProps
}

const parsePositioningSymbol = parseSymbol;
const parsePositioningSymbolLayer = parseSymbol;

const parseAestheticsSymbol = parseAesthetics$5;
const parseAestheticsSymbolLayer = parseAesthetics$5;

function parsePositioning$2 (props, section) {
  return {
    x: props.x,
    y: props.y
  }
}

function parseAesthetics$5 (props, parsedProps) {
  parsedProps = parsedProps ?? {};

  parsedProps.shape = fallback(props.shape, 'circle');
  parsedProps.radius = fallback(props.radius, 3);

  return parseAesthetics$1(props, parsedProps)
}

function createScales ({ scaleX, scaleY }, { rangeX, rangeY }, { addInvert } = {}) {
  return {
    x: createScale(scaleX, rangeX, addInvert),
    y: createScale(scaleY, rangeY, addInvert)
  }
}

function createScale (scale, range, addInvert) {
  if (scale.constructor === Array) {
    return scaleLinear().domain(scale).range(range)
  }

  const newScale = scale.copy().range(range);

  if (addInvert) {
    newScale.invert = createInvertMethod(newScale);
  }

  return newScale
}

/*
 * Taken from react-vis:
 * https://github.com/uber/react-vis/blob/master/src/utils/scales-utils.js#L161
 *
 * By default, d3.scaleBand and d3.scalePoint do not have an .invert method, which is why
 * we are doing this. There are some PRs open for this, though, so hopefully we can
 * get rid of this in the future:
 * - https://github.com/d3/d3-scale/pull/151
 * - https://github.com/d3/d3-scale/pull/60
 */
function createInvertMethod (scale) {
  if (scale.invert) {
    return scale.invert
  }

  return function invert (value) {
    const [lower, upper] = scale.range();
    const start = Math.min(lower, upper);
    const stop = Math.max(lower, upper);

    const flipped = upper < lower;

    const domain = scale.domain();
    const lastIndex = domain.length - 1;

    if (value < start + scale.padding() * scale.step()) {
      return domain[0]
    }

    if (value > stop - scale.padding() * scale.step()) {
      return domain[lastIndex]
    }

    let index;

    if (isPointScale(scale)) {
      index = Math.round((value - start - scale.padding() * scale.step()) / scale.step());
    }

    if (isBandScale(scale)) {
      index = Math.floor((value - start - scale.padding() * scale.step()) / scale.step());
      if (index > lastIndex) index = lastIndex;
    }

    return domain[flipped ? lastIndex - index : index]
  }
}

function isPointScale (scale) {
  return !('paddingInner' in scale)
}

function isBandScale (scale) {
  return 'paddingInner' in scale
}

/**
 * Cartesian coordinate system factory.
 *
 * @return {function} A function that generates a cartesian coordinate system.
 */
function cartesian () {
  return function (props, sectionData) {
    const { ranges } = sectionData;
    const scales = parseScales(props, DEFAULT_DOMAINS);

    const { x: scaleX, y: scaleY } = createScales(scales, DEFAULT_RANGES);
    const directScales = createScales(scales, ranges, { addInvert: true });
    const indirectScales = createScales(DEFAULT_DOMAINS, ranges);

    const inverseTotalTransformation = ([x, y]) => ([
      directScales.x.invert(x),
      directScales.y.invert(y)
    ]);

    return {
      ...sectionData,
      type: 'cartesian',
      scaleX,
      scaleY,
      directScales,
      indirectScales,
      inverseTotalTransformation,
      bwx: scaleX.bandwidth,
      bwy: scaleY.bandwidth,
      px: getPixelMethod(ranges.rangeX),
      py: getPixelMethod(ranges.rangeY),
      pxAt: indirectScales.x.invert,
      pyAt: indirectScales.y.invert
    }
  }
}

function parseScales (props, defaultDomains) {
  return {
    scaleX: props.scaleX ?? defaultDomains.scaleX,
    scaleY: props.scaleY ?? defaultDomains.scaleY
  }
}

const DEFAULT_RANGES = {
  rangeX: [0, 1],
  rangeY: [0, 1]
};

const DEFAULT_DOMAINS = {
  scaleX: [0, 1],
  scaleY: [0, 1]
};

function getPixelMethod ([a, b]) {
  const factor = b - a;
  if (factor === 0) return () => 0
  return v => v / factor
}

function parseSection (props, parentSection) {
  const positioning = getPositioning$c(props, parentSection);

  return {
    ...positioning,
    coordinates: fallback(props.coordinates, cartesian()),
    scaleX: props.scaleX,
    scaleY: props.scaleY,
    flipX: fallback(props.flipX, false),
    flipY: fallback(props.flipY, false),
    padding: fallback(props.padding, 0),
    zoomIdentity: props.zoomIdentity,
    clip: fallback(props.clip, 'padding'),
    id: props.id
  }
}

function getPositioning$c (props, parentSection) {
  if (!parentSection) {
    return {
      x1: props.x1,
      x2: props.x2,
      y1: props.y1,
      y2: props.y2
    }
  }

  const positioning = parsePositioning$1(props, parentSection);

  const { x, y } = parentSection.indirectScales;

  return {
    x1: x(positioning.x1),
    x2: x(positioning.x2),
    y1: y(positioning.y1),
    y2: y(positioning.y2)
  }
}

/**
 * A padding object.
 * @typedef {Object} Padding
 * @property {number} [left=0] Left padding in pixels.
 * @property {number} [right=0] Right padding in pixels.
 * @property {number} [top=0] Top padding in pixels.
 * @property {number} [bottom=0] Bottom padding in pixels.
 *
 */

function parsePadding (_padding) {
  const padding = _padding === undefined
    ? 0
    : _padding;

  if (padding.constructor === Number) {
    return { left: padding, right: padding, top: padding, bottom: padding }
  }

  if (padding.constructor === Object) {
    return Object.assign(
      parsePadding(0),
      padding
    )
  }

  throw invalidPaddingError
}

const invalidPaddingError = new Error('Invalid padding specification');

function applyPadding (range, offsetMin, offsetMax) {
  warnIfPaddingSmallerThanRange(range, offsetMin, offsetMax);

  if (range[0] < range[1]) {
    return [range[0] + offsetMin, range[1] - offsetMax]
  } else {
    return [range[0] - offsetMax, range[1] + offsetMin]
  }
}

function warnIfPaddingSmallerThanRange (range, min, max) {
  if (Math.abs(range[0] - range[1]) < (min + max)) {
    console.warn('Padding cannot exceed width or height');
  }
}

function getRanges (props, padding) {
  const { flipX, flipY, zoomIdentity } = props;
  let { rangeX, rangeY } = initRanges(props);
  const { left, right, top, bottom } = padding;

  rangeX = applyFlip(rangeX, flipX);
  rangeX = applyPadding(rangeX, left, right);

  if (zoomIdentity) {
    validateZoomFactor(zoomIdentity.kx);
    rangeX = applyZoom(rangeX, zoomIdentity.kx, zoomIdentity.x);
  }

  rangeY = applyFlip(rangeY, flipY);
  rangeY = applyPadding(rangeY, top, bottom);

  if (zoomIdentity) {
    validateZoomFactor(zoomIdentity.ky);
    rangeY = applyZoom(rangeY, zoomIdentity.ky, zoomIdentity.y);
  }

  return { rangeX, rangeY }
}

function initRanges (props) {
  return {
    rangeX: [props.x1, props.x2],
    rangeY: [props.y1, props.y2]
  }
}

function applyFlip (range, flip) {
  return flip
    ? [range[1], range[0]]
    : range
}

function applyZoom (range, k, translate) {
  return [
    range[0] * k + translate,
    range[1] * k + translate
  ]
}

function validateZoomFactor (k) {
  if (k < 0) throw new Error('Zoom factors have to be positive')
}

let idCounter = 0;

function getId$2 () {
  return 'sc' + idCounter++
}

/**
 * Creates a Section.
 *
 * For more on how positioning works, see the {@link createRectangle} documentation.
 *
 * @param {Object} props
 * @param {*} [props.x1] A x-coordinate, or a function that returns an original x-coordinate.
 * @param {*} [props.x2] A x-coordinate, or a function that returns an original x-coordinate.
 * @param {*} [props.y1] A y-coordinate, or a function that returns an original y-coordinate.
 * @param {*} [props.y2] A y-coordinate, or a function that returns an original y-coordinate.
 * @param {function} [props.coordinates=cartesian()] Defines alternative coordinate systems. Defaults to cartesian.
 * @param {function|number[]} [props.scaleX] A d3 scaling function or an array of two numbers indicating the desired domain.
 * @param {function|number[]} [props.scaleY] A d3 scaling function or an array of two numbers indicating the desired domain.
 * @param {boolean} [props.flipX=false] Flips the coordinate system in the x-dimension.
 * @param {boolean} [props.flipY=false] Flips the coordinate system in the y-dimension.
 * @param {number|object} [props.padding=0] A number representing padding in pixels on all sides, or a {@link Padding} object.
 * @param {object} [props.zoomIdentity] A {@link ZoomIdentity} object.
 * @param {string} [props.clip='padding'] Sets the clipping mode for the section contents.
 * @param {string} [props.id] Allows providing a custom id. Mostly used for testing.
 * @param {Section} [parentSection]
 *
 * @return {Section}
 */
function createSection (_props, parentSection) {
  if (parentSection && parentSection.type !== 'cartesian') {
    throw new Error('Cannot nest section inside other section with polar coordinates')
  }

  const props = parseSection(_props, parentSection);
  const id = props.id ? props.id : getId$2();

  const padding = parsePadding(props.padding);
  const zoomIdentity = parseZoomIdentity(props.zoomIdentity);
  const ranges = getRanges(props, padding);

  const bbox = clampBbox(getBbox$3(props), parentSection);
  const paddedBbox = clampBbox(getPaddedBbox(bbox, padding), parentSection);

  return props.coordinates(props, {
    id,
    padding,
    zoomIdentity,
    ranges,
    bbox,
    paddedBbox,
    clip: props.clip
  })
}

/**
 * A Section object created by {@link createSection} or {@link createPointSection}.
 * @typedef Section
 */

/**
 * A ZoomIdentity object.
 * @typedef {object} ZoomIdentity
 * @property {number} [x=0] Pixel value of x-translate.
 * @property {number} [y=0] Pixel value of y-translate.
 * @property {number} [kx=1] Zoom factor in x-dimension.
 * @property {number} [ky=1] Zoom factor in y-dimension.
 */

function parseZoomIdentity (zoomIdentity) {
  return Object.assign({ x: 0, y: 0, kx: 1, ky: 1 }, zoomIdentity)
}

function getBbox$3 ({ x1, x2, y1, y2 }) {
  return {
    minX: Math.min(x1, x2),
    maxX: Math.max(x1, x2),
    minY: Math.min(y1, y2),
    maxY: Math.max(y1, y2)
  }
}

function getPaddedBbox (
  { minX, maxX, minY, maxY },
  { left, right, top, bottom }
) {
  return {
    minX: minX + left,
    maxX: maxX - right,
    minY: minY + top,
    maxY: maxY - bottom
  }
}

function clampBbox (bbox, parentSection) {
  if (!parentSection) return bbox

  const parentBbox = parentSection.clip === 'padding'
    ? parentSection.paddedBbox
    : parentSection.bbox;

  return {
    minX: Math.max(bbox.minX, parentBbox.minX),
    maxX: Math.min(bbox.maxX, parentBbox.maxX),
    minY: Math.max(bbox.minY, parentBbox.minY),
    maxY: Math.min(bbox.maxY, parentBbox.maxY)
  }
}

/**
 * Creates a Section.
 *
 * @param {Object} props
 * @param {*} [props.x] X-coordinate.
 * @param {*} [props.y] Y-coordinate.
 * @param {number} [props.width] The width in pixels.
 * @param {number} [props.height] The height in pixels.
 * @param {function} [props.coordinates=cartesian()] Defines alternative coordinate systems. Defaults to cartesian.
 * @param {function|number[]} [props.scaleX] A d3 scaling function or an array of two numbers indicating the desired domain.
 * @param {function|number[]} [props.scaleY] A d3 scaling function or an array of two numbers indicating the desired domain.
 * @param {boolean} [props.flipX=false] Flips the coordinate system in the x-dimension.
 * @param {boolean} [props.flipY=false] Flips the coordinate system in the y-dimension.
 * @param {number|object} [props.padding=0] A number representing padding in pixels on all sides, or a {@link Padding} object.
 * @param {object} [props.zoomIdentity] A {@link ZoomIdentity} object.
 * @param {string} [props.clip='padding'] Sets the clipping mode for the section contents.
 * @param {string} [props.id] Allows providing a custom id. Mostly used for testing.
 * @param {Section} [parentSection]
 *
 * @return {Section}
 */
function createPointSection (props, parentSection) {
  const sectionPositioning = getSectionPositioning(props, parentSection);
  const mergedProps = mergeProps$1(sectionPositioning, props);

  return createSection(mergedProps)
}

function getSectionPositioning (props, parentSection) {
  const dx = props.width / 2;
  const dy = props.height / 2;

  if (!parentSection) {
    const { x, y } = props;

    return {
      x1: x - dx,
      x2: x + dx,
      y1: y - dy,
      y2: y + dy
    }
  }

  const pointPositioningContext = circle();
  const { scales } = parsePositioning(props, parentSection);

  stream(props, parentSection, scales, pointPositioningContext, parseOutputSettings());
  const { cx, cy } = pointPositioningContext.result();

  return {
    x1: cx - dx,
    x2: cx + dx,
    y1: cy - dy,
    y2: cy + dy
  }
}

function mergeProps$1 (sectionPositioning, props) {
  for (const propName in props) {
    if (!(propName in sectionPositioning)) {
      sectionPositioning[propName] = props[propName];
    }
  }

  return sectionPositioning
}

var shapes = {
  square: [
    [-1, -1], [1, -1], [1, 1], [-1, 1], [-1, -1]
  ],
  cross: [
    [-0.5, -1], [0.5, -1], [0.5, -0.5], [1, -0.5], [1, 0.5], [0.5, 0.5], [0.5, 1], [-0.5, 1], [-0.5, 0.5], [-1, 0.5], [-1, -0.5], [-0.5, -0.5], [-0.5, -1]
  ],
  'cross-sharp': [
    [0, -1], [0.2, -0.2], [1, 0], [0.2, 0.2], [0, 1], [-0.2, 0.2], [-1, 0], [-0.2, -0.2], [0, -1]
  ],
  diamond: [
    [0, -1], [1, 0], [0, 1], [-1, 0], [0, -1]
  ],
  'triangle-up': [
    [0, -1], [1, 1], [-1, 1], [0, -1]
  ],
  'triangle-down': [
    [1, -1], [0, 1], [-1, -1], [1, -1]
  ],
  'triangle-right': [
    [-1, -1], [1, 0], [-1, 1], [-1, -1]
  ],
  'triangle-left': [
    [1, -1], [-1, 0], [1, 1], [1, -1]
  ],
  star4: [
    [0, 0.71], [1, 1], [0.71, 0], [1, -1], [0, -0.71], [-1, -1], [-0.71, 0], [-1, 1], [0, 0.71]
  ],
  star5: [
    [0, 0.5], [0.6, 0.8], [0.5, 0.1], [1, -0.3], [0.3, -0.4], [0, -1], [-0.3, -0.4], [-1, -0.3], [-0.5, 0.1], [-0.6, 0.8], [0, 0.5]
  ],
  star: [
    [0, 0.5], [0.6, 0.8], [0.5, 0.1], [1, -0.3], [0.3, -0.4], [0, -1], [-0.3, -0.4], [-1, -0.3], [-0.5, 0.1], [-0.6, 0.8], [0, 0.5]
  ],
  star6: [
    [0, 0.58], [0.5, 1], [0.43, 0.29], [1, 0], [0.43, -0.29], [0.5, -1], [0, -0.58], [-0.5, -1], [-0.43, -0.29], [-1, 0], [-0.43, 0.29], [-0.5, 1], [0, 0.58]
  ],
  star8: [
    [0, 0.54], [0.41, 1], [0.38, 0.38], [1, 0.41], [0.54, 0], [1, -0.41], [0.38, -0.38], [0.41, -1], [0, -0.54], [-0.41, -1], [-0.38, -0.38], [-1, -0.41], [-0.54, 0], [-1, 0.41], [-0.38, 0.38], [-0.41, 1], [0, 0.54]
  ],
  pentagon: [
    [-1, -0.24], [0, -1], [1, -0.24], [0.62, 1], [-0.62, 1], [-1, -0.24]
  ],
  hexagon: [
    [-1, 0], [-0.57, -1], [0.57, -1], [1, 0], [0.57, 1], [-0.57, 1], [-1, 0]
  ],
  heptagon: [
    [-1, 0.29], [-0.8, -0.6], [0, -1], [0.8, -0.6], [1, 0.29], [0.45, 1], [-0.45, 1], [-1, 0.29]
  ],
  septagon: [
    [-1, 0.29], [-0.8, -0.6], [0, -1], [0.8, -0.6], [1, 0.29], [0.45, 1], [-0.45, 1], [-1, 0.29]
  ],
  octagon: [
    [-1, -0.41], [-0.41, -1], [0.41, -1], [1, -0.41], [1, 0.41], [0.41, 1], [-0.41, 1], [-1, 0.41], [-1, -0.41]
  ],
  nonagon: [
    [0.35, -1], [0.88, -0.55], [1, 0.15], [0.65, 0.76], [0, 1], [-0.65, 0.76], [-1, 0.15], [-0.88, -0.55], [-0.35, -1], [0.35, -1]
  ],
  decagon: [
    [-1, 0], [-0.81, -0.62], [-0.31, -1], [0.31, -1], [0.81, -0.62], [1, 0], [0.81, 0.62], [0.31, 1], [-0.31, 1], [-0.81, 0.62], [-1, 0]
  ]
};

/**
 * Creates a Symbol mark.
 *
 * @param {Object} props
 * @param {Object} props.x A x-coordinate, or a function that returns an original x-coordinate.
 * @param {Object} props.y A y-coordinate, or a function that returns an original y-coordinate.
 * @param {(string|Object)} [props.shape='circle'] Shape of symbol. Can be a string name, or a GeoJSON geometry scaled to a bounding box of [-1, 1] in x and y dimensions.
 * @param {number} [props.radius=3] The radius of the point in pixels.
 * @param {string} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {string} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {number} [props.strokeWidth=1] The stroke width in pixels.
 * @param {number} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {number} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {number} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {string} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {string} [props.lineJoin='bevel'] Controls how lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {number} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {string} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {number} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Mark} A Mark object.
 */
function createSymbol (_props, section, outputSettings) {
  const props = parseSymbol(_props);

  if (props.shape === 'circle') {
    return createPoint(props, section)
  }

  const pointSection = createPointSection({
    x: props.x,
    y: props.y,
    width: props.radius * 2,
    height: props.radius * 2,
    scaleX: [-1, 1],
    scaleY: [-1, 1]
  }, section);

  const geometry = shapeToGeometry(props.shape);
  const polygonProps = mergeProps$2({ geometry }, props);

  const symbol = createPolygon(polygonProps, pointSection, outputSettings);
  symbol.type = 'Symbol';

  return symbol
}

function shapeToGeometry (shape) {
  return shape in shapes
    ? asPolygon(shapes[shape])
    : shape
}

function asPolygon (coordinates) {
  return {
    type: 'Polygon',
    coordinates: [coordinates]
  }
}

const NOT_ALLOWED_PROPS = new Set(['x', 'y', 'shape', 'radius']);

function mergeProps$2 (newProps, props) {
  for (const propName in props) {
    if (!NOT_ALLOWED_PROPS.has(propName)) {
      newProps[propName] = props[propName];
    }
  }

  return newProps
}

/**
 * Creates an Area layer.
 *
 * @param {Object} props
 * @param {Array|function} props.x An array of x-coordinates, or a function that returns an array of original x-coordinates.
 * @param {Array|function} props.y An array of y-coordinates, or a function that returns an array of original y-coordinates.
 * @param {(string|Object|Array.<(string|Object)>|function)} [props.shape='circle'] Shape of symbol. Can be a string name, or a GeoJSON geometry scaled to a bounding box of [-1, 1] in x and y dimensions.
 * @param {(number|number[]|function)} [props.radius=3] The radius of the point in pixels.
 * @param {(string|string[]|function)} [props.fill='black'] The fill color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {(string|string[]|function)} [props.stroke='none'] The stroke color. Can be in named, hex, rgb, rgba, hsl or hsla format, or 'none'.
 * @param {(number|number[]|function)} [props.strokeWidth=1] The stroke width in pixels.
 * @param {(number|number[]|function)} [props.opacity=1] The overall opacity. Must be a value between 0 and 1.
 * @param {(number|number[]|function)} [props.fillOpacity=1] The fill opacity. Must be a value between 0 and 1.
 * @param {(number|number[]|function)} [props.strokeOpacity=1] The stroke opacity. Must be a value between 0 and 1.
 * @param {(string|string[]|function)} [props.lineCap='butt'] Controls the endings of line strokes. Can be 'butt', 'round' or 'square'.
 * @param {(string|string[]|function)} [props.lineJoin='bevel'] How lines are joined. Can be 'bevel', 'round' or 'miter'.
 * @param {(number|number[]|function)} [props.miterLimit=10] Sets limit in pixels for miter lineJoins.
 * @param {(string|string[]|function)} [props.dashArray] String of numbers representing pixels, separated by spaces, used to create dash patterns.
 * @param {(number|number[]|function)} [props.dashOffset] Pixel value to offset dash patterns.
 * @param {string[]} [props.keys] An array of unique keys. Must be strings.
 * @param {string} [props.clip] Overrides the clipping mode of the parent section. Can be 'padding' or 'outer'.
 * @param {boolean} [props.asOnePath=false] If true, draws whole layer as one path.
 * @param {Section} section
 * @param {OutputSettings} [outputSettings]
 *
 * @return {Layer} A Layer object.
 */
function createSymbolLayer (_props, section, outputSettings) {
  const props = parseSymbol(_props);
  outputSettings = parseOutputSettings(outputSettings);

  const pointPositioningContext = circleLayer();
  const { scales: pointScales } = parsePositioning(_props, section);

  stream$1(props, section, pointScales, pointPositioningContext, outputSettings);
  const coordinates = pointPositioningContext.result();

  const layerRecorder = recorderLayer();
  streamSymbolLayer(coordinates, props, section, layerRecorder, outputSettings);
  const positioning = layerRecorder.result();

  return new Layer(
    positioning,
    props,
    section,
    layerStyler,
    'Symbol'
  )
}

function streamSymbolLayer (coordinates, props, section, context, outputSettings) {
  const keys = props.keys;
  const getShape = aestheticGetter(props.shape, keys);
  const getRadius = aestheticGetter(props.radius, keys);

  for (let i = 0; i < coordinates.length; i++) {
    const shape = getShape(i);
    const radius = getRadius(i);

    if (shape === 'circle') {
      streamCircle(coordinates[i], radius, context);
      context.markEnd();
    }

    if (shape !== 'circle') {
      const geometry = shapeToGeometry(shape);
      const scales = {
        x: createScale$1(coordinates[i].cx, radius),
        y: createScale$1(coordinates[i].cy, radius)
      };

      const pipeline = createPipeline$1(props, {}, scales, context, outputSettings);
      streamGeometry(geometry, pipeline, i);
      pipeline.markEnd();
    }
  }
}

const TAU$1 = Math.PI * 2;

function streamCircle (c, radius, context, i) {
  context.moveTo(c.cx + radius, c.cy);
  context.arc(c.cx, c.cy, radius, 0, TAU$1);
}

function createScale$1 (c, r) {
  return scaleLinear().domain([0, 1]).range([c, r + c])
}

const schema$7 = {
  positioning: {
    props: ['x', 'y'],
    validCombinations: [new Set(['x', 'y'])],
    nonGeometryFormat: 'value'
  },

  other: [
    'shape',
    'radius',
    'fill',
    'stroke',
    'strokeWidth',
    'opacity',
    'fillOpacity',
    'strokeOpacity',
    'lineJoin',
    'miterLimit',
    'dashArray',
    'dashOffset',
    'clip'
  ]
};

/**
 * Validates Symbol props.
 * @param {Object} props See {@link createSymbol}
 */
function validateSymbol (props) {
  validateProps(props, schema$7);
}

/**
 * Validates SymbolLayer props.
 * @param {Object} props See {@link createSymbolLayer}
 */
function validateSymbolLayer (props) {
  validatePropsLayer(props, schema$7);
}

/**
 * Polar coordinate system factory.
 *
 * @param {object} [options]
 * @param {number} [startAngle=-Math.PI / 2] Start angle of polar coordinates. Defaults to top.
 * @param {number} [endAngle=1.5 * Math.PI] End angle of polar coordinates. Defaults to top.
 *
 * @return {function} A function that generates a polar coordinate system.
 */
function polar (options) {
  options = parseOptions(options);

  return function (props, sectionData) {
    const scales = parseScales(props, DEFAULT_DOMAINS);
    const polarRanges = getPolarRanges(DEFAULT_RANGES, options);

    const directScales = createScales(scales, polarRanges, { addInvert: true });
    const { x: scaleX, y: scaleY } = createScales(scales, DEFAULT_RANGES);
    const indirectScales = createScales(DEFAULT_DOMAINS, polarRanges);

    const { ranges } = sectionData;
    const coordinateSystem = createCoordinateSystem(ranges);

    const inverseTotalTransformation = ([x, y]) => ([
      directScales.x.invert(coordinateSystem.invertX(x, y)),
      directScales.y.invert(coordinateSystem.invertY(x, y))
    ]);

    return {
      ...sectionData,
      type: 'polar',
      scaleX,
      scaleY,
      directScales,
      indirectScales,
      coordinateSystem,
      inverseTotalTransformation,
      bwx: scaleX.bandwidth,
      bwy: scaleY.bandwidth
    }
  }
}

const TWO_PI$3 = Math.PI * 2;
const HALF_PI$1 = Math.PI / 2;

function parseOptions (options) {
  const DEFAULT_OPTIONS = {
    startAngle: -HALF_PI$1,
    endAngle: TWO_PI$3 - HALF_PI$1
  };

  if (!options) return DEFAULT_OPTIONS

  return Object.assign(DEFAULT_OPTIONS, options)
}

function getPolarRanges (ranges, options) {
  return {
    rangeX: [options.startAngle, options.endAngle],
    rangeY: ranges.rangeY
  }
}

function createCoordinateSystem (ranges) {
  const { rangeX, rangeY } = ranges;

  const halfWidth = getHalfDist(rangeX);
  const halfHeight = getHalfDist(rangeY);
  const midX = getMid(rangeX, halfWidth);
  const midY = getMid(rangeY, halfHeight);

  const scales = createScales(
    { scaleX: [-1, 1], scaleY: [-1, 1] },
    ranges
  );

  return {
    midX,
    midY,
    halfWidth,
    halfHeight,
    flipX: rangeX[0] > rangeX[1],
    flipY: rangeY[0] > rangeY[1],
    x: (theta, r) => scales.x(r * Math.cos(theta)),
    y: (theta, r) => scales.y(r * Math.sin(theta)),
    invertX: createInvertX(scales),
    invertY: createInvertY(scales)
  }
}

function getHalfDist (range) {
  return Math.abs(range[0] - range[1]) / 2
}

function getMid ([a, b], extent) {
  return a < b ? a + extent : b + extent
}

function createInvertX (scales) {
  return (x, y) => {
    const scaledBackX = scales.x.invert(x);
    const scaledBackY = scales.y.invert(y);

    const theta = Math.atan(scaledBackY / scaledBackX);

    const quadrant = getQuadrant$1(scaledBackX, scaledBackY);

    switch (quadrant) {
      case 1: return theta
      case 2: return theta + Math.PI
      case 3: return theta + Math.PI
      case 4: return theta + TWO_PI$3
    }
  }
}

function createInvertY (scales) {
  return (x, y) => {
    const scaledBackX = scales.x.invert(x);
    const scaledBackY = scales.y.invert(y);
    return Math.sqrt(scaledBackX ** 2 + scaledBackY ** 2)
  }
}

function getQuadrant$1 (x, y) {
  if (x >= 0 && y >= 0) return 1
  if (x < 0 && y >= 0) return 2
  if (x < 0 && y < 0) return 3
  if (x >= 0 && y < 0) return 4
}

export { EventManager, InteractionManager, SpatialIndex, bboxLabel, bboxLabelLayer, bboxLine, bboxLineLayer, bboxPoint, bboxPointLayer, bboxPolygon, bboxPolygonLayer, bboxToClipArgs, bboxToClipRect, calculateLinearRingCentroidAndArea, cartesian, centroidLabel, centroidLabelLayer, centroidPolygon as centroidLine, centroidPolygonLayer as centroidLineLayer, centroidPoint, centroidPointLayer, centroidPolygon, centroidPolygonLayer, chain, createArea, createAreaLayer, createFuncLine, createLabel, createLabelLayer, createLine, createLineLayer, createPoint, createPointLayer, createPointSection, createPolygon, createPolygonLayer, createRectangle, createRectangleLayer, createSection, createSymbol, createSymbolLayer, createTransformer, fitScales, getClipId, getClipPathURL, getClipType, getGridCells, parseAestheticsArea, parseAestheticsAreaLayer, parseAestheticsFuncLine, parseAestheticsLabel, parseAestheticsLabelLayer, parseAestheticsLine, parseAestheticsLineLayer, parseAestheticsPoint, parseAestheticsPointLayer, parseAestheticsPolygon, parseAestheticsPolygonLayer, parseAestheticsRectangle, parseAestheticsRectangleLayer, parseAestheticsSymbol, parseAestheticsSymbolLayer, parsePositioningArea, parsePositioningAreaLayer, parsePositioningFuncLine, parsePositioningLabel, parsePositioningLabelLayer, parsePositioningLine, parsePositioningLineLayer, parsePositioningPoint, parsePositioningPointLayer, parsePositioningPolygon, parsePositioningPolygonLayer, parsePositioningRectangle, parsePositioningRectangleLayer, parsePositioningSymbol, parsePositioningSymbolLayer, polar, recorderLabel, recorderLabelLayer, recorderLayer, recorderMark, round, scale, split, streamArea, streamAreaLayer, streamGeometries, streamGeometry, streamLine, streamLineLayer, streamPoint, streamPointLayer, streamPolygon, streamPolygonLayer, streamRectangle, streamRectangleLayer, svgPositioning, svgStyled, transform, validateArea, validateAreaLayer, validateFuncLine, validateLabel, validateLabelLayer, validateLine, validateLineLayer, validatePoint, validatePointLayer, validatePolygon, validatePolygonLayer, validateRectangle, validateRectangleLayer, validateSymbol, validateSymbolLayer, x2, x2s, y2, y2s };
