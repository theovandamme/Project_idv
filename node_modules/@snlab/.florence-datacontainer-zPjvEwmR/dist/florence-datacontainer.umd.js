(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global['florence-datacontainer'] = factory());
}(this, (function () { 'use strict';

  // Should be no imports here!
  var _a; // SOme things that should be evaluated before all else...


  var hasSymbol = typeof Symbol !== "undefined";
  var hasMap = typeof Map !== "undefined";
  var hasSet = typeof Set !== "undefined";
  /**
   * The sentinel value returned by producers to replace the draft with undefined.
   */

  var NOTHING = hasSymbol ? Symbol("immer-nothing") : (_a = {}, _a["immer-nothing"] = true, _a);
  /**
   * To let Immer treat your class instances as plain immutable objects
   * (albeit with a custom prototype), you must define either an instance property
   * or a static property on each of your custom classes.
   *
   * Otherwise, your class instance will never be drafted, which means it won't be
   * safe to mutate in a produce callback.
   */

  var DRAFTABLE = hasSymbol ? Symbol("immer-draftable") : "__$immer_draftable";
  var DRAFT_STATE = hasSymbol ? Symbol("immer-state") : "__$immer_state";
  var iteratorSymbol = hasSymbol ? Symbol.iterator : "@@iterator";

  /* istanbul ignore next */
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } }
    };

    return extendStatics(d, b);
  }; // Ugly hack to resolve #502 and inherit built in Map / Set


  function __extends(d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = ( // @ts-ignore
    __.prototype = b.prototype, new __());
  }

  var Archtype;

  (function (Archtype) {
    Archtype[Archtype["Object"] = 0] = "Object";
    Archtype[Archtype["Array"] = 1] = "Array";
    Archtype[Archtype["Map"] = 2] = "Map";
    Archtype[Archtype["Set"] = 3] = "Set";
  })(Archtype || (Archtype = {}));

  var ProxyType;

  (function (ProxyType) {
    ProxyType[ProxyType["ProxyObject"] = 0] = "ProxyObject";
    ProxyType[ProxyType["ProxyArray"] = 1] = "ProxyArray";
    ProxyType[ProxyType["ES5Object"] = 2] = "ES5Object";
    ProxyType[ProxyType["ES5Array"] = 3] = "ES5Array";
    ProxyType[ProxyType["Map"] = 4] = "Map";
    ProxyType[ProxyType["Set"] = 5] = "Set";
  })(ProxyType || (ProxyType = {}));

  /** Returns true if the given value is an Immer draft */

  function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
  }
  /** Returns true if the given value can be drafted by Immer */

  function isDraftable(value) {
    if (!value) { return false; }
    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);
  }
  function isPlainObject(value) {
    if (!value || typeof value !== "object") { return false; }
    var proto = Object.getPrototypeOf(value);
    return !proto || proto === Object.prototype;
  }
  var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== "undefined" ? function (obj) {
    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
  } :
  /* istanbul ignore next */
  Object.getOwnPropertyNames;
  function each(obj, iter) {
    if (getArchtype(obj) === Archtype.Object) {
      ownKeys(obj).forEach(function (key) {
        return iter(key, obj[key], obj);
      });
    } else {
      obj.forEach(function (entry, index) {
        return iter(index, entry, obj);
      });
    }
  }
  function isEnumerable(base, prop) {
    var desc = Object.getOwnPropertyDescriptor(base, prop);
    return desc && desc.enumerable ? true : false;
  }
  function getArchtype(thing) {
    /* istanbul ignore next */
    if (!thing) { die(); }

    if (thing[DRAFT_STATE]) {
      switch (thing[DRAFT_STATE].type) {
        case ProxyType.ES5Object:
        case ProxyType.ProxyObject:
          return Archtype.Object;

        case ProxyType.ES5Array:
        case ProxyType.ProxyArray:
          return Archtype.Array;

        case ProxyType.Map:
          return Archtype.Map;

        case ProxyType.Set:
          return Archtype.Set;
      }
    }

    return Array.isArray(thing) ? Archtype.Array : isMap(thing) ? Archtype.Map : isSet(thing) ? Archtype.Set : Archtype.Object;
  }
  function has(thing, prop) {
    return getArchtype(thing) === Archtype.Map ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
  }
  function get(thing, prop) {
    // @ts-ignore
    return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];
  }
  function set(thing, propOrOldValue, value) {
    switch (getArchtype(thing)) {
      case Archtype.Map:
        thing.set(propOrOldValue, value);
        break;

      case Archtype.Set:
        thing.delete(propOrOldValue);
        thing.add(value);
        break;

      default:
        thing[propOrOldValue] = value;
    }
  }
  function is(x, y) {
    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
    if (x === y) {
      return x !== 0 || 1 / x === 1 / y;
    } else {
      return x !== x && y !== y;
    }
  }
  function isMap(target) {
    return hasMap && target instanceof Map;
  }
  function isSet(target) {
    return hasSet && target instanceof Set;
  }
  function latest(state) {
    return state.copy || state.base;
  }
  function shallowCopy(base, invokeGetters) {
    if (invokeGetters === void 0) {
      invokeGetters = false;
    }

    if (Array.isArray(base)) { return base.slice(); }
    var clone = Object.create(Object.getPrototypeOf(base));
    ownKeys(base).forEach(function (key) {
      if (key === DRAFT_STATE) {
        return; // Never copy over draft state.
      }

      var desc = Object.getOwnPropertyDescriptor(base, key);
      var value = desc.value;

      if (desc.get) {
        if (!invokeGetters) {
          throw new Error("Immer drafts cannot have computed properties");
        }

        value = desc.get.call(base);
      }

      if (desc.enumerable) {
        clone[key] = value;
      } else {
        Object.defineProperty(clone, key, {
          value: value,
          writable: true,
          configurable: true
        });
      }
    });
    return clone;
  }
  function freeze(obj, deep) {
    if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }
    var type = getArchtype(obj);

    if (type === Archtype.Set) {
      obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
    } else if (type === Archtype.Map) {
      obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;
    }

    Object.freeze(obj);
    if (deep) { each(obj, function (_, value) {
      return freeze(value, true);
    }); }
  }

  function dontMutateFrozenCollections() {
    throw new Error("This object has been frozen and should not be mutated");
  }

  function createHiddenProperty(target, prop, value) {
    Object.defineProperty(target, prop, {
      value: value,
      enumerable: false,
      writable: true
    });
  }
  /* istanbul ignore next */

  function die() {
    throw new Error("Illegal state, please file a bug");
  }

  /** Each scope represents a `produce` call. */

  var ImmerScope =
  /** @class */
  function () {
    function ImmerScope(parent, immer) {
      this.drafts = [];
      this.parent = parent;
      this.immer = immer; // Whenever the modified draft contains a draft from another scope, we
      // need to prevent auto-freezing so the unowned draft can be finalized.

      this.canAutoFreeze = true;
    }

    ImmerScope.prototype.usePatches = function (patchListener) {
      if (patchListener) {
        this.patches = [];
        this.inversePatches = [];
        this.patchListener = patchListener;
      }
    };

    ImmerScope.prototype.revoke = function () {
      this.leave();
      this.drafts.forEach(revoke); // @ts-ignore

      this.drafts = null;
    };

    ImmerScope.prototype.leave = function () {
      if (this === ImmerScope.current) {
        ImmerScope.current = this.parent;
      }
    };

    ImmerScope.enter = function (immer) {
      var scope = new ImmerScope(ImmerScope.current, immer);
      ImmerScope.current = scope;
      return scope;
    };

    return ImmerScope;
  }();

  function revoke(draft) {
    var state = draft[DRAFT_STATE];
    if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) { state.revoke(); }else { state.revoked = true; }
  }

  function processResult(immer, result, scope) {
    var baseDraft = scope.drafts[0];
    var isReplaced = result !== undefined && result !== baseDraft;
    immer.willFinalize(scope, result, isReplaced);

    if (isReplaced) {
      if (baseDraft[DRAFT_STATE].modified) {
        scope.revoke();
        throw new Error("An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft."); // prettier-ignore
      }

      if (isDraftable(result)) {
        // Finalize the result in case it contains (or is) a subset of the draft.
        result = finalize(immer, result, scope);
        if (!scope.parent) { maybeFreeze(immer, result); }
      }

      if (scope.patches) {
        scope.patches.push({
          op: "replace",
          path: [],
          value: result
        });
        scope.inversePatches.push({
          op: "replace",
          path: [],
          value: baseDraft[DRAFT_STATE].base
        });
      }
    } else {
      // Finalize the base draft.
      result = finalize(immer, baseDraft, scope, []);
    }

    scope.revoke();

    if (scope.patches) {
      scope.patchListener(scope.patches, scope.inversePatches);
    }

    return result !== NOTHING ? result : undefined;
  }

  function finalize(immer, draft, scope, path) {
    var state = draft[DRAFT_STATE];

    if (!state) {
      if (Object.isFrozen(draft)) { return draft; }
      return finalizeTree(immer, draft, scope);
    } // Never finalize drafts owned by another scope.


    if (state.scope !== scope) {
      return draft;
    }

    if (!state.modified) {
      maybeFreeze(immer, state.base, true);
      return state.base;
    }

    if (!state.finalized) {
      state.finalized = true;
      finalizeTree(immer, state.draft, scope, path); // We cannot really delete anything inside of a Set. We can only replace the whole Set.

      if (immer.onDelete && state.type !== ProxyType.Set) {
        // The `assigned` object is unreliable with ES5 drafts.
        if (immer.useProxies) {
          var assigned = state.assigned;
          each(assigned, function (prop, exists) {
            if (!exists) { immer.onDelete(state, prop); }
          });
        } else {
          var base = state.base,
              copy_1 = state.copy;
          each(base, function (prop) {
            if (!has(copy_1, prop)) { immer.onDelete(state, prop); }
          });
        }
      }

      if (immer.onCopy) {
        immer.onCopy(state);
      } // At this point, all descendants of `state.copy` have been finalized,
      // so we can be sure that `scope.canAutoFreeze` is accurate.


      if (immer.autoFreeze && scope.canAutoFreeze) {
        freeze(state.copy, false);
      }

      if (path && scope.patches) {
        generatePatches(state, path, scope.patches, scope.inversePatches);
      }
    }

    return state.copy;
  }

  function finalizeTree(immer, root, scope, rootPath) {
    var state = root[DRAFT_STATE];

    if (state) {
      if (state.type === ProxyType.ES5Object || state.type === ProxyType.ES5Array) {
        // Create the final copy, with added keys and without deleted keys.
        state.copy = shallowCopy(state.draft, true);
      }

      root = state.copy;
    }

    each(root, function (key, value) {
      return finalizeProperty(immer, scope, root, state, root, key, value, rootPath);
    });
    return root;
  }

  function finalizeProperty(immer, scope, root, rootState, parentValue, prop, childValue, rootPath) {
    if (childValue === parentValue) {
      throw Error("Immer forbids circular references");
    } // In the `finalizeTree` method, only the `root` object may be a draft.


    var isDraftProp = !!rootState && parentValue === root;
    var isSetMember = isSet(parentValue);

    if (isDraft(childValue)) {
      var path = rootPath && isDraftProp && !isSetMember && // Set objects are atomic since they have no keys.
      !has(rootState.assigned, prop) // Skip deep patches for assigned keys.
      ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.

      childValue = finalize(immer, childValue, scope, path);
      set(parentValue, prop, childValue); // Drafts from another scope must prevent auto-freezing.

      if (isDraft(childValue)) {
        scope.canAutoFreeze = false;
      }
    } // Unchanged draft properties are ignored.
    else if (isDraftProp && is(childValue, get(rootState.base, prop))) {
        return;
      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.
      // TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?
      // especially the passing on of root and rootState doesn't make sense...
      else if (isDraftable(childValue)) {
          each(childValue, function (key, grandChild) {
            return finalizeProperty(immer, scope, root, rootState, childValue, key, grandChild, rootPath);
          });
          if (!scope.parent) { maybeFreeze(immer, childValue); }
        }

    if (isDraftProp && immer.onAssign && !isSetMember) {
      immer.onAssign(rootState, prop, childValue);
    }
  }

  function maybeFreeze(immer, value, deep) {
    if (deep === void 0) {
      deep = false;
    }

    if (immer.autoFreeze && !isDraft(value)) {
      freeze(value, deep);
    }
  }

  /**
   * Returns a new draft of the `base` object.
   *
   * The second argument is the parent draft-state (used internally).
   */

  function createProxy(base, parent) {
    var isArray = Array.isArray(base);
    var state = {
      type: isArray ? ProxyType.ProxyArray : ProxyType.ProxyObject,
      // Track which produce call this is associated with.
      scope: parent ? parent.scope : ImmerScope.current,
      // True for both shallow and deep changes.
      modified: false,
      // Used during finalization.
      finalized: false,
      // Track which properties have been assigned (true) or deleted (false).
      assigned: {},
      // The parent draft state.
      parent: parent,
      // The base state.
      base: base,
      // The base proxy.
      draft: null,
      // Any property proxies.
      drafts: {},
      // The base copy with any updated values.
      copy: null,
      // Called by the `produce` function.
      revoke: null,
      isManual: false
    }; // the traps must target something, a bit like the 'real' base.
    // but also, we need to be able to determine from the target what the relevant state is
    // (to avoid creating traps per instance to capture the state in closure,
    // and to avoid creating weird hidden properties as well)
    // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)
    // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb

    var target = state;
    var traps = objectTraps;

    if (isArray) {
      target = [state];
      traps = arrayTraps;
    } // TODO: optimization: might be faster, cheaper if we created a non-revocable proxy
    // and administrate revoking ourselves


    var _a = Proxy.revocable(target, traps),
        revoke = _a.revoke,
        proxy = _a.proxy;

    state.draft = proxy;
    state.revoke = revoke;
    return proxy;
  }
  /**
   * Object drafts
   */

  var objectTraps = {
    get: function (state, prop) {
      if (prop === DRAFT_STATE) { return state; }
      var drafts = state.drafts; // Check for existing draft in unmodified state.

      if (!state.modified && has(drafts, prop)) {
        return drafts[prop];
      }

      var value = latest(state)[prop];

      if (state.finalized || !isDraftable(value)) {
        return value;
      } // Check for existing draft in modified state.


      if (state.modified) {
        // Assigned values are never drafted. This catches any drafts we created, too.
        if (value !== peek(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).
        // @ts-ignore

        drafts = state.copy;
      }

      return drafts[prop] = state.scope.immer.createProxy(value, state);
    },
    has: function (state, prop) {
      return prop in latest(state);
    },
    ownKeys: function (state) {
      return Reflect.ownKeys(latest(state));
    },
    set: function (state, prop
    /* strictly not, but helps TS */
    , value) {
      if (!state.modified) {
        var baseValue = peek(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to
        // never be undefined, so we can avoid the `in` operator. Lastly, truthy
        // values may be drafts, but falsy values are never drafts.

        var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;
        if (isUnchanged) { return true; }
        prepareCopy(state);
        markChanged(state);
      }

      state.assigned[prop] = true; // @ts-ignore

      state.copy[prop] = value;
      return true;
    },
    deleteProperty: function (state, prop) {
      // The `undefined` check is a fast path for pre-existing keys.
      if (peek(state.base, prop) !== undefined || prop in state.base) {
        state.assigned[prop] = false;
        prepareCopy(state);
        markChanged(state);
      } else if (state.assigned[prop]) {
        // if an originally not assigned property was deleted
        delete state.assigned[prop];
      } // @ts-ignore


      if (state.copy) { delete state.copy[prop]; }
      return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor: function (state, prop) {
      var owner = latest(state);
      var desc = Reflect.getOwnPropertyDescriptor(owner, prop);

      if (desc) {
        desc.writable = true;
        desc.configurable = state.type !== ProxyType.ProxyArray || prop !== "length";
      }

      return desc;
    },
    defineProperty: function () {
      throw new Error("Object.defineProperty() cannot be used on an Immer draft"); // prettier-ignore
    },
    getPrototypeOf: function (state) {
      return Object.getPrototypeOf(state.base);
    },
    setPrototypeOf: function () {
      throw new Error("Object.setPrototypeOf() cannot be used on an Immer draft"); // prettier-ignore
    }
  };
  /**
   * Array drafts
   */

  var arrayTraps = {};
  each(objectTraps, function (key, fn) {
    // @ts-ignore
    arrayTraps[key] = function () {
      arguments[0] = arguments[0][0];
      return fn.apply(this, arguments);
    };
  });

  arrayTraps.deleteProperty = function (state, prop) {
    if (isNaN(parseInt(prop))) {
      throw new Error("Immer only supports deleting array indices"); // prettier-ignore
    }

    return objectTraps.deleteProperty.call(this, state[0], prop);
  };

  arrayTraps.set = function (state, prop, value) {
    if (prop !== "length" && isNaN(parseInt(prop))) {
      throw new Error("Immer only supports setting array indices and the 'length' property"); // prettier-ignore
    }

    return objectTraps.set.call(this, state[0], prop, value, state[0]);
  };
  /**
   * Map drafts
   */
  // Access a property without creating an Immer draft.


  function peek(draft, prop) {
    var state = draft[DRAFT_STATE];
    var desc = Reflect.getOwnPropertyDescriptor(state ? latest(state) : draft, prop);
    return desc && desc.value;
  }

  function markChanged(state) {
    if (!state.modified) {
      state.modified = true;

      if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) {
        var copy_1 = state.copy = shallowCopy(state.base);
        each(state.drafts, function (key, value) {
          // @ts-ignore
          copy_1[key] = value;
        });
        state.drafts = undefined;
      }

      if (state.parent) {
        markChanged(state.parent);
      }
    }
  }

  function prepareCopy(state) {
    if (!state.copy) {
      state.copy = shallowCopy(state.base);
    }
  }

  function willFinalizeES5(scope, result, isReplaced) {
    scope.drafts.forEach(function (draft) {
      draft[DRAFT_STATE].finalizing = true;
    });

    if (!isReplaced) {
      if (scope.patches) {
        markChangesRecursively(scope.drafts[0]);
      } // This is faster when we don't care about which attributes changed.


      markChangesSweep(scope.drafts);
    } // When a child draft is returned, look for changes.
    else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {
        markChangesSweep(scope.drafts);
      }
  }
  function createES5Proxy(base, parent) {
    var isArray = Array.isArray(base);
    var draft = clonePotentialDraft(base);
    each(draft, function (prop) {
      proxyProperty(draft, prop, isArray || isEnumerable(base, prop));
    });
    var state = {
      type: isArray ? ProxyType.ES5Array : ProxyType.ES5Object,
      scope: parent ? parent.scope : ImmerScope.current,
      modified: false,
      finalizing: false,
      finalized: false,
      assigned: {},
      parent: parent,
      base: base,
      draft: draft,
      copy: null,
      revoked: false,
      isManual: false
    };
    createHiddenProperty(draft, DRAFT_STATE, state);
    return draft;
  } // Access a property without creating an Immer draft.

  function peek$1(draft, prop) {
    var state = draft[DRAFT_STATE];

    if (state && !state.finalizing) {
      state.finalizing = true;
      var value = draft[prop];
      state.finalizing = false;
      return value;
    }

    return draft[prop];
  }

  function get$1(state, prop) {
    assertUnrevoked(state);
    var value = peek$1(latest(state), prop);
    if (state.finalizing) { return value; } // Create a draft if the value is unmodified.

    if (value === peek$1(state.base, prop) && isDraftable(value)) {
      prepareCopy$1(state); // @ts-ignore

      return state.copy[prop] = state.scope.immer.createProxy(value, state);
    }

    return value;
  }

  function set$1(state, prop, value) {
    assertUnrevoked(state);
    state.assigned[prop] = true;

    if (!state.modified) {
      if (is(value, peek$1(latest(state), prop))) { return; }
      markChangedES5(state);
      prepareCopy$1(state);
    } // @ts-ignore


    state.copy[prop] = value;
  }

  function markChangedES5(state) {
    if (!state.modified) {
      state.modified = true;
      if (state.parent) { markChangedES5(state.parent); }
    }
  }

  function prepareCopy$1(state) {
    if (!state.copy) { state.copy = clonePotentialDraft(state.base); }
  }

  function clonePotentialDraft(base) {
    var state = base && base[DRAFT_STATE];

    if (state) {
      state.finalizing = true;
      var draft = shallowCopy(state.draft, true);
      state.finalizing = false;
      return draft;
    }

    return shallowCopy(base);
  } // property descriptors are recycled to make sure we don't create a get and set closure per property,
  // but share them all instead


  var descriptors = {};

  function proxyProperty(draft, prop, enumerable) {
    var desc = descriptors[prop];

    if (desc) {
      desc.enumerable = enumerable;
    } else {
      descriptors[prop] = desc = {
        configurable: true,
        enumerable: enumerable,
        get: function () {
          return get$1(this[DRAFT_STATE], prop);
        },
        set: function (value) {
          set$1(this[DRAFT_STATE], prop, value);
        }
      };
    }

    Object.defineProperty(draft, prop, desc);
  }

  function assertUnrevoked(state) {
    if (state.revoked === true) { throw new Error("Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + JSON.stringify(latest(state))); }
  } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.

  function markChangesSweep(drafts) {
    // The natural order of drafts in the `scope` array is based on when they
    // were accessed. By processing drafts in reverse natural order, we have a
    // better chance of processing leaf nodes first. When a leaf node is known to
    // have changed, we can avoid any traversal of its ancestor nodes.
    for (var i = drafts.length - 1; i >= 0; i--) {
      var state = drafts[i][DRAFT_STATE];

      if (!state.modified) {
        switch (state.type) {
          case ProxyType.ES5Array:
            if (hasArrayChanges(state)) { markChangedES5(state); }
            break;

          case ProxyType.ES5Object:
            if (hasObjectChanges(state)) { markChangedES5(state); }
            break;
        }
      }
    }
  }

  function markChangesRecursively(object) {
    if (!object || typeof object !== "object") { return; }
    var state = object[DRAFT_STATE];
    if (!state) { return; }
    var base = state.base,
        draft = state.draft,
        assigned = state.assigned,
        type = state.type;

    if (type === ProxyType.ES5Object) {
      // Look for added keys.
      // TODO: looks quite duplicate to hasObjectChanges,
      // probably there is a faster way to detect changes, as sweep + recurse seems to do some
      // unnecessary work.
      // also: probably we can store the information we detect here, to speed up tree finalization!
      each(draft, function (key) {
        if (key === DRAFT_STATE) { return; } // The `undefined` check is a fast path for pre-existing keys.

        if (base[key] === undefined && !has(base, key)) {
          assigned[key] = true;
          markChangedES5(state);
        } else if (!assigned[key]) {
          // Only untouched properties trigger recursion.
          markChangesRecursively(draft[key]);
        }
      }); // Look for removed keys.

      each(base, function (key) {
        // The `undefined` check is a fast path for pre-existing keys.
        if (draft[key] === undefined && !has(draft, key)) {
          assigned[key] = false;
          markChangedES5(state);
        }
      });
    } else if (type === ProxyType.ES5Array) {
      if (hasArrayChanges(state)) {
        markChangedES5(state);
        assigned.length = true;
      }

      if (draft.length < base.length) {
        for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }
      } else {
        for (var i = base.length; i < draft.length; i++) { assigned[i] = true; }
      } // Minimum count is enough, the other parts has been processed.


      var min = Math.min(draft.length, base.length);

      for (var i = 0; i < min; i++) {
        // Only untouched indices trigger recursion.
        if (assigned[i] === undefined) { markChangesRecursively(draft[i]); }
      }
    }
  }

  function hasObjectChanges(state) {
    var base = state.base,
        draft = state.draft; // Search for added keys and changed keys. Start at the back, because
    // non-numeric keys are ordered by time of definition on the object.

    var keys = Object.keys(draft);

    for (var i = keys.length - 1; i >= 0; i--) {
      var key = keys[i];
      var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.

      if (baseValue === undefined && !has(base, key)) {
        return true;
      } // Once a base key is deleted, future changes go undetected, because its
      // descriptor is erased. This branch detects any missed changes.
      else {
          var value = draft[key];
          var state_1 = value && value[DRAFT_STATE];

          if (state_1 ? state_1.base !== baseValue : !is(value, baseValue)) {
            return true;
          }
        }
    } // At this point, no keys were added or changed.
    // Compare key count to determine if keys were deleted.


    return keys.length !== Object.keys(base).length;
  }

  function hasArrayChanges(state) {
    var draft = state.draft;
    if (draft.length !== state.base.length) { return true; } // See #116
    // If we first shorten the length, our array interceptors will be removed.
    // If after that new items are added, result in the same original length,
    // those last items will have no intercepting property.
    // So if there is no own descriptor on the last position, we know that items were removed and added
    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check
    // the last one

    var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)

    if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters

    return false;
  }

  var DraftMap = function (_super) {
    if (!_super) {
      /* istanbul ignore next */
      throw new Error("Map is not polyfilled");
    }

    __extends(DraftMap, _super); // Create class manually, cause #502


    function DraftMap(target, parent) {
      this[DRAFT_STATE] = {
        type: ProxyType.Map,
        parent: parent,
        scope: parent ? parent.scope : ImmerScope.current,
        modified: false,
        finalized: false,
        copy: undefined,
        assigned: undefined,
        base: target,
        draft: this,
        isManual: false,
        revoked: false
      };
      return this;
    }

    var p = DraftMap.prototype; // TODO: smaller build size if we create a util for Object.defineProperty

    Object.defineProperty(p, "size", {
      get: function () {
        return latest(this[DRAFT_STATE]).size;
      },
      enumerable: true,
      configurable: true
    });

    p.has = function (key) {
      return latest(this[DRAFT_STATE]).has(key);
    };

    p.set = function (key, value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);

      if (latest(state).get(key) !== value) {
        prepareCopy$2(state);
        state.scope.immer.markChanged(state);
        state.assigned.set(key, true);
        state.copy.set(key, value);
        state.assigned.set(key, true);
      }

      return this;
    };

    p.delete = function (key) {
      if (!this.has(key)) {
        return false;
      }

      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareCopy$2(state);
      state.scope.immer.markChanged(state);
      state.assigned.set(key, false);
      state.copy.delete(key);
      return true;
    };

    p.clear = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareCopy$2(state);
      state.scope.immer.markChanged(state);
      state.assigned = new Map();
      return state.copy.clear();
    };

    p.forEach = function (cb, thisArg) {
      var _this = this;

      var state = this[DRAFT_STATE];
      latest(state).forEach(function (_value, key, _map) {
        cb.call(thisArg, _this.get(key), key, _this);
      });
    };

    p.get = function (key) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      var value = latest(state).get(key);

      if (state.finalized || !isDraftable(value)) {
        return value;
      }

      if (value !== state.base.get(key)) {
        return value; // either already drafted or reassigned
      } // despite what it looks, this creates a draft only once, see above condition


      var draft = state.scope.immer.createProxy(value, state);
      prepareCopy$2(state);
      state.copy.set(key, draft);
      return draft;
    };

    p.keys = function () {
      return latest(this[DRAFT_STATE]).keys();
    };

    p.values = function () {
      var _a;

      var _this = this;

      var iterator = this.keys();
      return _a = {}, _a[iteratorSymbol] = function () {
        return _this.values();
      }, _a.next = function () {
        var r = iterator.next();
        /* istanbul ignore next */

        if (r.done) { return r; }

        var value = _this.get(r.value);

        return {
          done: false,
          value: value
        };
      }, _a;
    };

    p.entries = function () {
      var _a;

      var _this = this;

      var iterator = this.keys();
      return _a = {}, _a[iteratorSymbol] = function () {
        return _this.entries();
      }, _a.next = function () {
        var r = iterator.next();
        /* istanbul ignore next */

        if (r.done) { return r; }

        var value = _this.get(r.value);

        return {
          done: false,
          value: [r.value, value]
        };
      }, _a;
    };

    p[iteratorSymbol] = function () {
      return this.entries();
    };

    return DraftMap;
  }(Map);

  function proxyMap(target, parent) {
    // @ts-ignore
    return new DraftMap(target, parent);
  }

  function prepareCopy$2(state) {
    if (!state.copy) {
      state.assigned = new Map();
      state.copy = new Map(state.base);
    }
  }

  var DraftSet = function (_super) {
    if (!_super) {
      /* istanbul ignore next */
      throw new Error("Set is not polyfilled");
    }

    __extends(DraftSet, _super); // Create class manually, cause #502


    function DraftSet(target, parent) {
      this[DRAFT_STATE] = {
        type: ProxyType.Set,
        parent: parent,
        scope: parent ? parent.scope : ImmerScope.current,
        modified: false,
        finalized: false,
        copy: undefined,
        base: target,
        draft: this,
        drafts: new Map(),
        revoked: false,
        isManual: false
      };
      return this;
    }

    var p = DraftSet.prototype;
    Object.defineProperty(p, "size", {
      get: function () {
        return latest(this[DRAFT_STATE]).size;
      },
      enumerable: true,
      configurable: true
    });

    p.has = function (value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value

      if (!state.copy) {
        return state.base.has(value);
      }

      if (state.copy.has(value)) { return true; }
      if (state.drafts.has(value) && state.copy.has(state.drafts.get(value))) { return true; }
      return false;
    };

    p.add = function (value) {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);

      if (state.copy) {
        state.copy.add(value);
      } else if (!state.base.has(value)) {
        prepareCopy$3(state);
        state.scope.immer.markChanged(state);
        state.copy.add(value);
      }

      return this;
    };

    p.delete = function (value) {
      if (!this.has(value)) {
        return false;
      }

      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareCopy$3(state);
      state.scope.immer.markChanged(state);
      return state.copy.delete(value) || (state.drafts.has(value) ? state.copy.delete(state.drafts.get(value)) :
      /* istanbul ignore next */
      false);
    };

    p.clear = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareCopy$3(state);
      state.scope.immer.markChanged(state);
      return state.copy.clear();
    };

    p.values = function () {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareCopy$3(state);
      return state.copy.values();
    };

    p.entries = function entries() {
      var state = this[DRAFT_STATE];
      assertUnrevoked(state);
      prepareCopy$3(state);
      return state.copy.entries();
    };

    p.keys = function () {
      return this.values();
    };

    p[iteratorSymbol] = function () {
      return this.values();
    };

    p.forEach = function forEach(cb, thisArg) {
      var iterator = this.values();
      var result = iterator.next();

      while (!result.done) {
        cb.call(thisArg, result.value, result.value, this);
        result = iterator.next();
      }
    };

    return DraftSet;
  }(Set);

  function proxySet(target, parent) {
    // @ts-ignore
    return new DraftSet(target, parent);
  }

  function prepareCopy$3(state) {
    if (!state.copy) {
      // create drafts for all entries to preserve insertion order
      state.copy = new Set();
      state.base.forEach(function (value) {
        if (isDraftable(value)) {
          var draft = state.scope.immer.createProxy(value, state);
          state.drafts.set(value, draft);
          state.copy.add(draft);
        } else {
          state.copy.add(value);
        }
      });
    }
  }

  function generatePatches(state, basePath, patches, inversePatches) {
    switch (state.type) {
      case ProxyType.ProxyObject:
      case ProxyType.ES5Object:
      case ProxyType.Map:
        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);

      case ProxyType.ES5Array:
      case ProxyType.ProxyArray:
        return generateArrayPatches(state, basePath, patches, inversePatches);

      case ProxyType.Set:
        return generateSetPatches(state, basePath, patches, inversePatches);
    }
  }

  function generateArrayPatches(state, basePath, patches, inversePatches) {
    var _a, _b;

    var base = state.base,
        assigned = state.assigned,
        copy = state.copy;
    /* istanbul ignore next */

    if (!copy) { die(); } // Reduce complexity by ensuring `base` is never longer.

    if (copy.length < base.length) {
      _a = [copy, base], base = _a[0], copy = _a[1];
      _b = [inversePatches, patches], patches = _b[0], inversePatches = _b[1];
    }

    var delta = copy.length - base.length; // Find the first replaced index.

    var start = 0;

    while (base[start] === copy[start] && start < base.length) {
      ++start;
    } // Find the last replaced index. Search from the end to optimize splice patches.


    var end = base.length;

    while (end > start && base[end - 1] === copy[end + delta - 1]) {
      --end;
    } // Process replaced indices.


    for (var i = start; i < end; ++i) {
      if (assigned[i] && copy[i] !== base[i]) {
        var path = basePath.concat([i]);
        patches.push({
          op: "replace",
          path: path,
          value: copy[i]
        });
        inversePatches.push({
          op: "replace",
          path: path,
          value: base[i]
        });
      }
    }

    var replaceCount = patches.length; // Process added indices.

    for (var i = end + delta - 1; i >= end; --i) {
      var path = basePath.concat([i]);
      patches[replaceCount + i - end] = {
        op: "add",
        path: path,
        value: copy[i]
      };
      inversePatches.push({
        op: "remove",
        path: path
      });
    }
  } // This is used for both Map objects and normal objects.


  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
    var base = state.base,
        copy = state.copy;
    each(state.assigned, function (key, assignedValue) {
      var origValue = get(base, key);
      var value = get(copy, key);
      var op = !assignedValue ? "remove" : has(base, key) ? "replace" : "add";
      if (origValue === value && op === "replace") { return; }
      var path = basePath.concat(key);
      patches.push(op === "remove" ? {
        op: op,
        path: path
      } : {
        op: op,
        path: path,
        value: value
      });
      inversePatches.push(op === "add" ? {
        op: "remove",
        path: path
      } : op === "remove" ? {
        op: "add",
        path: path,
        value: origValue
      } : {
        op: "replace",
        path: path,
        value: origValue
      });
    });
  }

  function generateSetPatches(state, basePath, patches, inversePatches) {
    var base = state.base,
        copy = state.copy;
    var i = 0;
    base.forEach(function (value) {
      if (!copy.has(value)) {
        var path = basePath.concat([i]);
        patches.push({
          op: "remove",
          path: path,
          value: value
        });
        inversePatches.unshift({
          op: "add",
          path: path,
          value: value
        });
      }

      i++;
    });
    i = 0;
    copy.forEach(function (value) {
      if (!base.has(value)) {
        var path = basePath.concat([i]);
        patches.push({
          op: "add",
          path: path,
          value: value
        });
        inversePatches.unshift({
          op: "remove",
          path: path,
          value: value
        });
      }

      i++;
    });
  }

  function applyPatches(draft, patches) {
    patches.forEach(function (patch) {
      var path = patch.path,
          op = patch.op;
      /* istanbul ignore next */

      if (!path.length) { die(); }
      var base = draft;

      for (var i = 0; i < path.length - 1; i++) {
        base = get(base, path[i]);
        if (!base || typeof base !== "object") { throw new Error("Cannot apply patch, path doesn't resolve: " + path.join("/")); } // prettier-ignore
      }

      var type = getArchtype(base);
      var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411

      var key = path[path.length - 1];

      switch (op) {
        case "replace":
          switch (type) {
            case Archtype.Map:
              return base.set(key, value);

            /* istanbul ignore next */

            case Archtype.Set:
              throw new Error('Sets cannot have "replace" patches.');

            default:
              // if value is an object, then it's assigned by reference
              // in the following add or remove ops, the value field inside the patch will also be modifyed
              // so we use value from the cloned patch
              // @ts-ignore
              return base[key] = value;
          }

        case "add":
          switch (type) {
            case Archtype.Array:
              return base.splice(key, 0, value);

            case Archtype.Map:
              return base.set(key, value);

            case Archtype.Set:
              return base.add(value);

            default:
              return base[key] = value;
          }

        case "remove":
          switch (type) {
            case Archtype.Array:
              return base.splice(key, 1);

            case Archtype.Map:
              return base.delete(key);

            case Archtype.Set:
              return base.delete(patch.value);

            default:
              return delete base[key];
          }

        default:
          throw new Error("Unsupported patch operation: " + op);
      }
    });
    return draft;
  }

  function deepClonePatchValue(obj) {
    if (!obj || typeof obj !== "object") { return obj; }
    if (Array.isArray(obj)) { return obj.map(deepClonePatchValue); }
    if (isMap(obj)) { return new Map(Array.from(obj.entries()).map(function (_a) {
      var k = _a[0],
          v = _a[1];
      return [k, deepClonePatchValue(v)];
    })); }
    if (isSet(obj)) { return new Set(Array.from(obj).map(deepClonePatchValue)); }
    var cloned = Object.create(Object.getPrototypeOf(obj));

    for (var key in obj) { cloned[key] = deepClonePatchValue(obj[key]); }

    return cloned;
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
      return r;
  }

  /* istanbul ignore next */

  function verifyMinified() {}

  var configDefaults = {
    useProxies: typeof Proxy !== "undefined" && typeof Proxy.revocable !== "undefined" && typeof Reflect !== "undefined",
    autoFreeze: typeof process !== "undefined" ? process.env.NODE_ENV !== "production" :
    /* istanbul ignore next */
    verifyMinified.name === "verifyMinified",
    onAssign: null,
    onDelete: null,
    onCopy: null
  };

  var Immer =
  /** @class */
  function () {
    function Immer(config) {
      var _this = this;

      this.useProxies = false;
      this.autoFreeze = false;
      each(configDefaults, function (key, value) {
        var _a, _b; // @ts-ignore


        _this[key] = (_b = (_a = config) === null || _a === void 0 ? void 0 : _a[key], _b !== null && _b !== void 0 ? _b : value);
      });
      this.setUseProxies(this.useProxies);
      this.produce = this.produce.bind(this);
      this.produceWithPatches = this.produceWithPatches.bind(this);
    }
    /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */


    Immer.prototype.produce = function (base, recipe, patchListener) {
      var _this = this; // curried invocation


      if (typeof base === "function" && typeof recipe !== "function") {
        var defaultBase_1 = recipe;
        recipe = base;
        var self_1 = this;
        return function curriedProduce(base) {
          var arguments$1 = arguments;

          var _this = this;

          if (base === void 0) {
            base = defaultBase_1;
          }

          var args = [];

          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments$1[_i];
          }

          return self_1.produce(base, function (draft) {
            return recipe.call.apply(recipe, __spreadArrays([_this, draft], args));
          }); // prettier-ignore
        };
      } // prettier-ignore


      {
        if (typeof recipe !== "function") {
          throw new Error("The first or second argument to `produce` must be a function");
        }

        if (patchListener !== undefined && typeof patchListener !== "function") {
          throw new Error("The third argument to `produce` must be a function or undefined");
        }
      }
      var result; // Only plain objects, arrays, and "immerable classes" are drafted.

      if (isDraftable(base)) {
        var scope_1 = ImmerScope.enter(this);
        var proxy = this.createProxy(base, undefined);
        var hasError = true;

        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          // finally instead of catch + rethrow better preserves original stack
          if (hasError) { scope_1.revoke(); }else { scope_1.leave(); }
        }

        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then(function (result) {
            scope_1.usePatches(patchListener);
            return processResult(_this, result, scope_1);
          }, function (error) {
            scope_1.revoke();
            throw error;
          });
        }

        scope_1.usePatches(patchListener);
        return processResult(this, result, scope_1);
      } else {
        result = recipe(base);
        if (result === NOTHING) { return undefined; }
        if (result === undefined) { result = base; }
        maybeFreeze(this, result, true);
        return result;
      }
    };

    Immer.prototype.produceWithPatches = function (arg1, arg2, arg3) {
      var _this = this;

      if (typeof arg1 === "function") {
        return function (state) {
          var arguments$1 = arguments;

          var args = [];

          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments$1[_i];
          }

          return _this.produceWithPatches(state, function (draft) {
            return arg1.apply(void 0, __spreadArrays([draft], args));
          });
        };
      } // non-curried form

      /* istanbul ignore next */


      if (arg3) { die(); }
      var patches, inversePatches;
      var nextState = this.produce(arg1, arg2, function (p, ip) {
        patches = p;
        inversePatches = ip;
      });
      return [nextState, patches, inversePatches];
    };

    Immer.prototype.createDraft = function (base) {
      if (!isDraftable(base)) {
        throw new Error("First argument to `createDraft` must be a plain object, an array, or an immerable object"); // prettier-ignore
      }

      var scope = ImmerScope.enter(this);
      var proxy = this.createProxy(base, undefined);
      proxy[DRAFT_STATE].isManual = true;
      scope.leave();
      return proxy;
    };

    Immer.prototype.finishDraft = function (draft, patchListener) {
      var state = draft && draft[DRAFT_STATE];

      if (!state || !state.isManual) {
        throw new Error("First argument to `finishDraft` must be a draft returned by `createDraft`"); // prettier-ignore
      }

      if (state.finalized) {
        throw new Error("The given draft is already finalized"); // prettier-ignore
      }

      var scope = state.scope;
      scope.usePatches(patchListener);
      return processResult(this, undefined, scope);
    };
    /**
     * Pass true to automatically freeze all copies created by Immer.
     *
     * By default, auto-freezing is disabled in production.
     */


    Immer.prototype.setAutoFreeze = function (value) {
      this.autoFreeze = value;
    };
    /**
     * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
     * always faster than using ES5 proxies.
     *
     * By default, feature detection is used, so calling this is rarely necessary.
     */


    Immer.prototype.setUseProxies = function (value) {
      this.useProxies = value;
    };

    Immer.prototype.applyPatches = function (base, patches) {
      // If a patch replaces the entire state, take that replacement as base
      // before applying patches
      var i;

      for (i = patches.length - 1; i >= 0; i--) {
        var patch = patches[i];

        if (patch.path.length === 0 && patch.op === "replace") {
          base = patch.value;
          break;
        }
      }

      if (isDraft(base)) {
        // N.B: never hits if some patch a replacement, patches are never drafts
        return applyPatches(base, patches);
      } // Otherwise, produce a copy of the base state.


      return this.produce(base, function (draft) {
        return applyPatches(draft, patches.slice(i + 1));
      });
    };

    Immer.prototype.createProxy = function (value, parent) {
      // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft
      var draft = isMap(value) ? proxyMap(value, parent) : isSet(value) ? proxySet(value, parent) : this.useProxies ? createProxy(value, parent) : createES5Proxy(value, parent);
      var scope = parent ? parent.scope : ImmerScope.current;
      scope.drafts.push(draft);
      return draft;
    };

    Immer.prototype.willFinalize = function (scope, thing, isReplaced) {
      if (!this.useProxies) { willFinalizeES5(scope, thing, isReplaced); }
    };

    Immer.prototype.markChanged = function (state) {
      if (this.useProxies) {
        markChanged(state);
      } else {
        markChangedES5(state);
      }
    };

    return Immer;
  }();

  var immer = new Immer();
  /**
   * The `produce` function takes a value and a "recipe function" (whose
   * return value often depends on the base state). The recipe function is
   * free to mutate its first argument however it wants. All mutations are
   * only ever applied to a __copy__ of the base state.
   *
   * Pass only a function to create a "curried producer" which relieves you
   * from passing the recipe function every time.
   *
   * Only plain objects and arrays are made mutable. All other objects are
   * considered uncopyable.
   *
   * Note: This function is __bound__ to its `Immer` instance.
   *
   * @param {any} base - the initial state
   * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
   * @param {Function} patchListener - optional function that will be called with all the patches produced here
   * @returns {any} a new state, or the initial state if nothing was modified
   */

  var produce = immer.produce;
  /**
   * Like `produce`, but `produceWithPatches` always returns a tuple
   * [nextState, patches, inversePatches] (instead of just the next state)
   */

  var produceWithPatches = immer.produceWithPatches.bind(immer);
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is disabled in production.
   */

  var setAutoFreeze = immer.setAutoFreeze.bind(immer);
  /**
   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is
   * always faster than using ES5 proxies.
   *
   * By default, feature detection is used, so calling this is rarely necessary.
   */

  var setUseProxies = immer.setUseProxies.bind(immer);
  /**
   * Apply an array of Immer patches to the first argument.
   *
   * This function is a producer, which means copy-on-write is in effect.
   */

  var applyPatches$1 = immer.applyPatches.bind(immer);
  /**
   * Create an Immer draft from the given base state, which may be a draft itself.
   * The draft can be modified until you finalize it with the `finishDraft` function.
   */

  var createDraft = immer.createDraft.bind(immer);
  /**
   * Finalize an Immer draft from a `createDraft` call, returning the base state
   * (if no changes were made) or a modified copy. The draft must *not* be
   * mutated afterwards.
   *
   * Pass a function as the 2nd argument to generate Immer patches based on the
   * changes that were made.
   */

  var finishDraft = immer.finishDraft.bind(immer);

  function isColumnOriented (data) {
    if (data.constructor === Object) {
      const columns = Object.keys(data).map(key => data[key]);
      return columns.every(column => column.constructor === Array)
    }

    return false
  }

  function isRowOriented (data) {
    if (data.constructor === Array) {
      return data.every(row => row.constructor === Object)
    }

    return false
  }

  function isGeoJSON (data) {
    const hasCorrectType = data.type === 'FeatureCollection';
    const hasCorrectFeatures = data.features && data.features.length > 0;

    return hasCorrectType && hasCorrectFeatures
  }

  function checkFormatColumnData (data) {
    checkFormat(data, { internal: false });
  }

  function checkFormatInternal (data) {
    checkFormat(data, { internal: true });
  }

  function checkFormat (data, { internal }) {
    let dataLength = null;
    const columnNameChecker = internal
      ? checkInternalDataColumnName
      : checkRegularColumnName;

    for (const columnName in data) {
      columnNameChecker(columnName);
      const column = data[columnName];

      dataLength = dataLength || column.length;

      if (internal === false && dataLength === 0) {
        throw new Error('Invalid data: columns cannot be empty')
      }

      if (dataLength !== column.length) {
        throw new Error('Invalid data: columns must be of same length')
      }
    }
  }

  function checkRegularColumnName (columnName) {
    if (columnName.match(forbiddenChars)) {
      throw new Error(`Invalid column name '${columnName}': '$' and '/' are not allowed'`)
    }
  }

  const forbiddenChars = /[/$]/;

  function checkInternalDataColumnName (columnName) {
    if (!['$key', '$geometry', '$grouped'].includes(columnName)) {
      checkRegularColumnName(columnName);
    }
  }

  // Adds floating point numbers with twice the normal precision.
  // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
  // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
  // 305–363 (1997).
  // Code adapted from GeographicLib by Charles F. F. Karney,
  // http://geographiclib.sourceforge.net/

  function adder() {
    return new Adder;
  }

  function Adder() {
    this.reset();
  }

  Adder.prototype = {
    constructor: Adder,
    reset: function() {
      this.s = // rounded value
      this.t = 0; // exact error
    },
    add: function(y) {
      add(temp, y, this.t);
      add(this, temp.s, this.s);
      if (this.s) this.t += temp.t;
      else this.s = temp.t;
    },
    valueOf: function() {
      return this.s;
    }
  };

  var temp = new Adder;

  function add(adder, a, b) {
    var x = adder.s = a + b,
        bv = x - a,
        av = x - bv;
    adder.t = (a - av) + (b - bv);
  }

  var pi = Math.PI;
  var tau = pi * 2;

  var abs = Math.abs;
  var sqrt = Math.sqrt;

  function noop() {}

  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }

  var streamObjectType = {
    Feature: function(object, stream) {
      streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function(object, stream) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) streamGeometry(features[i].geometry, stream);
    }
  };

  var streamGeometryType = {
    Sphere: function(object, stream) {
      stream.sphere();
    },
    Point: function(object, stream) {
      object = object.coordinates;
      stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
    },
    LineString: function(object, stream) {
      streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) streamLine(coordinates[i], stream, 0);
    },
    Polygon: function(object, stream) {
      streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function(object, stream) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) streamGeometry(geometries[i], stream);
    }
  };

  function streamLine(coordinates, stream, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }

  function streamPolygon(coordinates, stream) {
    var i = -1, n = coordinates.length;
    stream.polygonStart();
    while (++i < n) streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
  }

  function geoStream(object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) {
      streamObjectType[object.type](object, stream);
    } else {
      streamGeometry(object, stream);
    }
  }

  function identity(x) {
    return x;
  }

  var areaSum = adder(),
      areaRingSum = adder(),
      x00,
      y00,
      x0,
      y0;

  var areaStream = {
    point: noop,
    lineStart: noop,
    lineEnd: noop,
    polygonStart: function() {
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;
      areaSum.add(abs(areaRingSum));
      areaRingSum.reset();
    },
    result: function() {
      var area = areaSum / 2;
      areaSum.reset();
      return area;
    }
  };

  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }

  function areaPointFirst(x, y) {
    areaStream.point = areaPoint;
    x00 = x0 = x, y00 = y0 = y;
  }

  function areaPoint(x, y) {
    areaRingSum.add(y0 * x - x0 * y);
    x0 = x, y0 = y;
  }

  function areaRingEnd() {
    areaPoint(x00, y00);
  }

  var x0$1 = Infinity,
      y0$1 = x0$1,
      x1 = -x0$1,
      y1 = x1;

  var boundsStream = {
    point: boundsPoint,
    lineStart: noop,
    lineEnd: noop,
    polygonStart: noop,
    polygonEnd: noop,
    result: function() {
      var bounds = [[x0$1, y0$1], [x1, y1]];
      x1 = y1 = -(y0$1 = x0$1 = Infinity);
      return bounds;
    }
  };

  function boundsPoint(x, y) {
    if (x < x0$1) x0$1 = x;
    if (x > x1) x1 = x;
    if (y < y0$1) y0$1 = y;
    if (y > y1) y1 = y;
  }

  // TODO Enforce positive area for exterior, negative area for interior?

  var X0 = 0,
      Y0 = 0,
      Z0 = 0,
      X1 = 0,
      Y1 = 0,
      Z1 = 0,
      X2 = 0,
      Y2 = 0,
      Z2 = 0,
      x00$1,
      y00$1,
      x0$2,
      y0$2;

  var centroidStream = {
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.point = centroidPoint;
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    },
    result: function() {
      var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
          : Z1 ? [X1 / Z1, Y1 / Z1]
          : Z0 ? [X0 / Z0, Y0 / Z0]
          : [NaN, NaN];
      X0 = Y0 = Z0 =
      X1 = Y1 = Z1 =
      X2 = Y2 = Z2 = 0;
      return centroid;
    }
  };

  function centroidPoint(x, y) {
    X0 += x;
    Y0 += y;
    ++Z0;
  }

  function centroidLineStart() {
    centroidStream.point = centroidPointFirstLine;
  }

  function centroidPointFirstLine(x, y) {
    centroidStream.point = centroidPointLine;
    centroidPoint(x0$2 = x, y0$2 = y);
  }

  function centroidPointLine(x, y) {
    var dx = x - x0$2, dy = y - y0$2, z = sqrt(dx * dx + dy * dy);
    X1 += z * (x0$2 + x) / 2;
    Y1 += z * (y0$2 + y) / 2;
    Z1 += z;
    centroidPoint(x0$2 = x, y0$2 = y);
  }

  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }

  function centroidRingStart() {
    centroidStream.point = centroidPointFirstRing;
  }

  function centroidRingEnd() {
    centroidPointRing(x00$1, y00$1);
  }

  function centroidPointFirstRing(x, y) {
    centroidStream.point = centroidPointRing;
    centroidPoint(x00$1 = x0$2 = x, y00$1 = y0$2 = y);
  }

  function centroidPointRing(x, y) {
    var dx = x - x0$2,
        dy = y - y0$2,
        z = sqrt(dx * dx + dy * dy);

    X1 += z * (x0$2 + x) / 2;
    Y1 += z * (y0$2 + y) / 2;
    Z1 += z;

    z = y0$2 * x - x0$2 * y;
    X2 += z * (x0$2 + x);
    Y2 += z * (y0$2 + y);
    Z2 += z * 3;
    centroidPoint(x0$2 = x, y0$2 = y);
  }

  function PathContext(context) {
    this._context = context;
  }

  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
      return this._radius = _, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._context.closePath();
      this._point = NaN;
    },
    point: function(x, y) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x, y);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x, y);
          break;
        }
        default: {
          this._context.moveTo(x + this._radius, y);
          this._context.arc(x, y, this._radius, 0, tau);
          break;
        }
      }
    },
    result: noop
  };

  var lengthSum = adder(),
      lengthRing,
      x00$2,
      y00$2,
      x0$3,
      y0$3;

  var lengthStream = {
    point: noop,
    lineStart: function() {
      lengthStream.point = lengthPointFirst;
    },
    lineEnd: function() {
      if (lengthRing) lengthPoint(x00$2, y00$2);
      lengthStream.point = noop;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length = +lengthSum;
      lengthSum.reset();
      return length;
    }
  };

  function lengthPointFirst(x, y) {
    lengthStream.point = lengthPoint;
    x00$2 = x0$3 = x, y00$2 = y0$3 = y;
  }

  function lengthPoint(x, y) {
    x0$3 -= x, y0$3 -= y;
    lengthSum.add(sqrt(x0$3 * x0$3 + y0$3 * y0$3));
    x0$3 = x, y0$3 = y;
  }

  function PathString() {
    this._string = [];
  }

  PathString.prototype = {
    _radius: 4.5,
    _circle: circle(4.5),
    pointRadius: function(_) {
      if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._string.push("Z");
      this._point = NaN;
    },
    point: function(x, y) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x, ",", y);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x, ",", y);
          break;
        }
        default: {
          if (this._circle == null) this._circle = circle(this._radius);
          this._string.push("M", x, ",", y, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };

  function circle(radius) {
    return "m0," + radius
        + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
        + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
        + "z";
  }

  function geoPath(projection, context) {
    var pointRadius = 4.5,
        projectionStream,
        contextStream;

    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        geoStream(object, projectionStream(contextStream));
      }
      return contextStream.result();
    }

    path.area = function(object) {
      geoStream(object, projectionStream(areaStream));
      return areaStream.result();
    };

    path.measure = function(object) {
      geoStream(object, projectionStream(lengthStream));
      return lengthStream.result();
    };

    path.bounds = function(object) {
      geoStream(object, projectionStream(boundsStream));
      return boundsStream.result();
    };

    path.centroid = function(object) {
      geoStream(object, projectionStream(centroidStream));
      return centroidStream.result();
    };

    path.projection = function(_) {
      return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
    };

    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return path;
    };

    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };

    return path.projection(projection).context(context);
  }

  function isInvalid (value) {
    if (value === undefined || value === null) { return true }

    if (value.constructor === Number) {
      return !isFinite(value)
    }

    return false
  }

  function isDefined (value) {
    return value !== undefined
  }

  function isUndefined (value) {
    return value === undefined
  }

  function calculateBBoxGeometries (geometries) {
    let bbox = [[Infinity, Infinity], [-Infinity, -Infinity]];

    for (let i = 0; i < geometries.length; i++) {
      const geometry = geometries[i];

      if (!isInvalid(geometry)) {
        bbox = updateBBox(bbox, geometry);
      }
    }

    const bboxObj = {
      x: [bbox[0][0], bbox[1][0]],
      y: [bbox[0][1], bbox[1][1]]
    };

    return bboxObj
  }

  const path = geoPath();

  function updateBBox (bbox, geometry) {
    const newBBox = path.bounds(geometry);

    bbox[0][0] = bbox[0][0] < newBBox[0][0] ? bbox[0][0] : newBBox[0][0];
    bbox[0][1] = bbox[0][1] < newBBox[0][1] ? bbox[0][1] : newBBox[0][1];
    bbox[1][0] = bbox[1][0] > newBBox[1][0] ? bbox[1][0] : newBBox[1][0];
    bbox[1][1] = bbox[1][1] > newBBox[1][1] ? bbox[1][1] : newBBox[1][1];

    return bbox
  }

  function warn (message) {
    if (!process) console.warn(message);

    if (process && process.env.NODE_ENV !== 'test') {
      console.warn(message);
    }
  }

  function calculateDomain (column, columnName) {
    if (columnName === '$grouped') {
      throw new Error(`Cannot calculate domain of column '${columnName}'.`)
    }

    if (column.length === 0) {
      return createEmptyDomain(columnName)
    }

    const { firstValidValue, nValidValues } = findFirstValidValue(column);

    if (nValidValues === 0) {
      throw new Error(`Cannot calculate domain of column '${column}'. Column contains only missing values.`)
    }

    if (nValidValues > 0) {
      ensureValidDataType(firstValidValue);
      const type = getDataType(firstValidValue);

      if (columnName === '$geometry') {
        return calculateBBoxGeometries(column)
      }

      if (columnName !== '$geometry') {
        return calculateNonGeometryColumnDomain(column, columnName, nValidValues, firstValidValue, type)
      }
    }
  }

  function createEmptyDomain (columnName) {
    if (columnName === '$geometry') {
      return { x: [], y: [] }
    }

    if (columnName !== '$geometry') {
      return []
    }
  }

  function findFirstValidValue (column) {
    let firstValidValue;
    let nValidValues = 0;

    for (let i = 0; i < column.length; i++) {
      if (!isInvalid(column[i])) {
        nValidValues++;
        firstValidValue = firstValidValue || column[i];
      }

      if (nValidValues > 1) break
    }

    return { firstValidValue, nValidValues }
  }

  function calculateNonGeometryColumnDomain (column, columnName, nValidValues, firstValidValue, type) {
    let domain;
    const nUniqueValues = calculateNumberOfUniqueValues(column, type);

    if (columnHasOnlyOneUniqueValue(nValidValues, nUniqueValues)) {
      domain = calculateDomainForColumnWithOneUniqueValue(
        nValidValues, nUniqueValues, type, firstValidValue, columnName
      );
    } else {
      domain = calculateDomainForRegularColumn(type, column, columnName);
    }

    return domain
  }

  function calculateNumberOfUniqueValues (col, type) {
    const uniqueVals = {};

    if (['quantitative', 'categorical'].includes(type)) {
      for (let i = 0; i < col.length; i++) {
        const val = col[i];
        if (!isInvalid(val)) {
          uniqueVals[val] = 0;
        }
      }
    }

    if (type === 'temporal') {
      for (let i = 0; i < col.length; i++) {
        const val = col[i];
        if (!isInvalid(val)) {
          uniqueVals[val.getTime()] = 0;
        }
      }
    }

    if (type === 'interval') {
      for (let i = 0; i < col.length; i++) {
        const val = col[i];
        if (!isInvalid(val)) {
          const str = JSON.stringify(val);
          uniqueVals[str] = 0;
        }
      }
    }

    return Object.keys(uniqueVals).length
  }

  function columnHasOnlyOneUniqueValue (nValidValues, nUniqueValues) {
    return nValidValues === 1 || nUniqueValues === 1
  }

  function calculateDomainForColumnWithOneUniqueValue (nValidValues, nUniqueValues, type, firstValidValue, columnName) {
    const domain = createDomainForSingleValue(type, firstValidValue);
    const warningText = nValidValues === 1 ? 'valid' : 'unique';

    if (type !== 'categorical') {
      warn(
        `Column '${columnName}' contains only 1 ${warningText} value: ${firstValidValue}.\n` +
        `Using domain ${JSON.stringify(domain)}`
      );
    }

    return domain
  }

  function calculateDomainForRegularColumn (type, column, columnName) {
    let domain = initDomain(type);

    for (let i = 0; i < column.length; i++) {
      const value = column[i];

      if (!isInvalid(value)) {
        if (getDataType(value) !== type) {
          throw new Error(`Invalid column ${columnName}: column contains multiple data types`)
        }

        domain = updateDomain(domain, value, type);
      }
    }

    return domain
  }

  const minUnixTime = new Date(0);
  const maxUnixTime = new Date('19 January 2038');

  function initDomain (type) {
    let domain;
    switch (type) {
      case 'quantitative': {
        domain = [Infinity, -Infinity];
        break
      }
      case 'categorical': {
        domain = [];
        break
      }
      case 'temporal': {
        domain = [maxUnixTime, minUnixTime];
        break
      }
      case 'interval': {
        domain = [Infinity, -Infinity];
        break
      }
    }

    return domain
  }

  function updateDomain (domain, value, type) {
    if (!['quantitative', 'categorical', 'temporal', 'interval'].includes(type)) {
      throw new Error(`Cannot set domain for column of type '${type}'`)
    }

    if (type === 'quantitative') {
      if (domain[0] >= value) { domain[0] = value; }
      if (domain[1] <= value) { domain[1] = value; }
    }

    if (type === 'categorical') {
      if (!domain.includes(value)) { domain.push(value); }
    }

    if (type === 'temporal') {
      const epoch = value.getTime();

      if (domain[0].getTime() >= epoch) { domain[0] = value; }
      if (domain[1].getTime() <= epoch) { domain[1] = value; }
    }

    if (type === 'interval') {
      domain = updateDomain(domain, value[0], 'quantitative');
      domain = updateDomain(domain, value[1], 'quantitative');
    }

    return domain
  }

  function createDomainForSingleValue (type, value) {
    let domain;

    if (type === 'quantitative') {
      domain = [value - 1, value + 1];
    }

    if (type === 'categorical') {
      domain = [value];
    }

    if (type === 'temporal') {
      domain = [getDay(value, -1), getDay(value, 1)];
    }

    if (type === 'interval') {
      domain = value.sort((a, b) => a - b);
    }

    return domain
  }

  function getDay (date, days) {
    const dateCopy = new Date(date.getTime());
    return new Date(dateCopy.setDate(dateCopy.getDate() + days))
  }

  function getColumnType (column) {
    const { firstValidValue } = findFirstValidValue(column);
    return getDataType(firstValidValue)
  }

  function getDataType (value) {
    if (isInvalid(value)) return undefined

    if (value.constructor === Number) return 'quantitative'
    if (value.constructor === String) return 'categorical'
    if (value.constructor === Date) return 'temporal'
    if (isInterval(value)) return 'interval'
    if (isGeometry(value)) return 'geometry'
    if (value.constructor === DataContainer) return 'grouped'

    return undefined
  }

  function ensureValidDataType (value) {
    if (isInvalid(getDataType(value))) {
      throw new Error('Invalid data')
    }
  }

  function isGeometry (value) {
    return value.constructor === Object && 'type' in value && 'coordinates' in value
  }

  function isInterval (value) {
    return value.constructor === Array && value.length === 2 && value.every(entry => entry.constructor === Number)
  }

  function generateKeyColumn (length) {
    return new Array(length).fill(0).map((_, i) => i)
  }

  function validateKeyColumn (keyColumn, requiredLength) {
    if (keyColumn.length !== requiredLength) {
      throw new Error('Key column must be of same length as rest of the data')
    }

    ensureAllSameType(keyColumn);
    ensureUnique(keyColumn);
  }

  function ensureAllSameType (keyColumn) {
    for (let i = 0; i < keyColumn.length; i++) {
      const key = keyColumn[i];
      validateKey(key);
    }
  }

  function validateKey (key) {
    const type = getDataType(key);

    if (type !== 'quantitative' || !Number.isInteger(key)) {
      throw new Error('Key column can contain only integers')
    }
  }

  function ensureUnique (keyColumn) {
    if (keyColumn.length !== new Set(keyColumn).size) {
      throw new Error('Keys must be unique')
    }
  }

  function getDataLength (data) {
    const firstKey = Object.keys(data)[0];
    const firstColumn = data[firstKey];
    return firstColumn.length
  }

  function convertRowToColumnData (data) {
    checkIfDataIsEmpty(data);
    let columnData = initColumnData(data);

    for (let row of data) {
      for (let key in row) {
        columnData[key].push(row[key]);
      }
    }

    return columnData
  }

  function initColumnData (data) {
    let firstRow = data[0];
    let columnKeys = Object.keys(firstRow);
    let columnData = {};

    for (let key of columnKeys) {
      columnData[key] = [];
    }

    return columnData
  }

  function checkIfDataIsEmpty (data) {
    if (data.length === 0) {
      throw new Error('Received empty Array while trying to load row-oriented data. This is not allowed.')
    }
  }

  function parseGeoJSON (geojsonData) {
    const geometryData = [];
    const data = {};

    const features = geojsonData.features;
    const firstFeature = features[0];

    if ('properties' in firstFeature) {
      for (const columnName in firstFeature.properties) {
        data[columnName] = [];
      }
    }

    for (let i = 0; i < features.length; i++) {
      const { geometry, properties } = features[i];
      geometryData.push(geometry);

      for (const columnName in properties) {
        data[columnName].push(properties[columnName]);
      }
    }

    checkFormatColumnData(data);

    data.$geometry = geometryData;

    return data
  }

  const methods = {
    _setColumnData (data, options) {
      if (options.validate === false) {
        checkFormatInternal(data);
      } else {
        checkFormatColumnData(data);
      }

      this._storeData(data, options);
    },

    _setRowData (rowData, options) {
      const columnData = convertRowToColumnData(rowData);
      this._setColumnData(columnData, options);
    },

    _setGeoJSON (geojsonData, options) {
      const data = parseGeoJSON(geojsonData);
      this._storeData(data, options);
    },

    _setGroup (group, options) {
      const data = group.data;
      checkFormatInternal(data);
      this._storeData(data, options);
    },

    _storeData (data, options) {
      this._data = data;

      this._setupKeyColumn();

      if (options.validate === true) {
        this.validateAllColumns();
      }
    },

    _setupKeyColumn () {
      const length = getDataLength(this._data);

      if ('$key' in this._data) {
        validateKeyColumn(this._data.$key, length);
        this._syncKeyToRowNumber();
      } else {
        const keyColumn = generateKeyColumn(length);
        this._setKeyColumn(keyColumn);
      }
    },

    _setKeyColumn (keyColumn) {
      this._data = produce(this._data, draft => {
        draft.$key = keyColumn;
      });

      this._syncKeyToRowNumber();
    },

    _syncKeyToRowNumber () {
      const length = getDataLength(this._data);

      for (let i = 0; i < length; i++) {
        const key = this._data.$key[i];
        this._keyToRowNumber[key] = i;
      }
    }
  };

  function dataLoadingMixin (targetClass) {
    Object.assign(targetClass.prototype, methods);
  }

  function filter (data, filterFunction) {
    const length = getDataLength(data);
    const newData = {};
    for (const colName in data) { newData[colName] = []; }

    for (let i = 0; i < length; i++) {
      const row = {};
      for (const colName in data) { row[colName] = data[colName][i]; }

      if (filterFunction(row, i) === true) {
        for (const colName in row) { newData[colName].push(row[colName]); }
      }
    }

    return newData
  }

  function select (data, selection) {
    if (selection.constructor === String) {
      selection = [selection];
    }

    if (selection.constructor === Array) {
      validateSelectionInstructions(data, selection);

      for (const columnName in data) {
        if (!selection.includes(columnName)) {
          delete data[columnName];
        }
      }
    } else {
      throw new Error('select can only be used with a string or array of strings')
    }
  }

  function validateSelectionInstructions (data, selection) {
    for (const columnName of selection) {
      if (!(columnName in data)) {
        throw new Error(`Column '${columnName}' not found`)
      }
    }
  }

  function arrange (data, sortInstructions) {
    if (sortInstructions.constructor === Object) {
      sort(data, sortInstructions);
    } else if (sortInstructions.constructor === Array) {
      for (let i = sortInstructions.length - 1; i >= 0; i--) {
        const instruction = sortInstructions[i];
        sort(data, instruction);
      }
    } else {
      throw new Error('arrange requires a key-value object or array of key-value objects')
    }
  }

  const sortFuncs = {
    quantitative: {
      // https://beta.observablehq.com/@mbostock/manipulating-flat-arrays
      ascending: (a, b) => a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN,
      descending: (a, b) => b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN
    },
    categorical: {
      ascending: (a, b) => {
        const sorted = [a, b].sort();
        return sorted[0] === a ? -1 : 1
      },
      descending: (a, b) => {
        const sorted = [a, b].sort();
        return sorted[0] === a ? 1 : -1
      }
    },
    temporal: {
      ascending: (a, b) => {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN
      },
      descending: (a, b) => {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN
      }
    }
  };

  function sort (data, sortInstructions) {
    if (Object.keys(sortInstructions).length !== 1) {
      throw new Error('Only one key-value pair allowed')
    }

    const variable = Object.keys(sortInstructions)[0];
    const sortMethod = sortInstructions[variable];

    ensureValidDataType(data[variable][0]);
    const dataType = getDataType(data[variable][0]);

    let sortFunc;
    if (sortMethod.constructor === String) {
      sortFunc = sortFuncs[dataType][sortMethod];
    }
    if (sortMethod.constructor === Function) {
      sortFunc = sortMethod;
    }

    const column = data[variable];

    const indices = column.map((v, i) => i);
    const sortedIndices = indices.sort((a, b) => sortFunc(column[a], column[b]));

    for (const colName in data) {
      data[colName] = reorder(data[colName], sortedIndices);
    }
  }

  function reorder (column, indices) {
    return indices.map(i => column[i])
  }

  function rename (data, renameInstructions) {
    if (renameInstructions.constructor !== Object) {
      throw new Error('Rename only accepts an object')
    }

    for (const oldName in renameInstructions) {
      if (oldName in data) {
        const newName = renameInstructions[oldName];
        checkRegularColumnName(newName);
        data[newName] = data[oldName];
        delete data[oldName];
      } else {
        warn(`Rename: column '${oldName}' not found`);
      }
    }
  }

  function mutate (data, mutateInstructions) {
    const length = getDataLength(data);
    const newData = {};

    for (const key in mutateInstructions) {
      newData[key] = new Array(length);
    }

    for (let i = 0; i < length; i++) {
      const row = {};
      let prevRow = {};
      let nextRow = {};

      for (const colName in data) {
        row[colName] = data[colName][i];
        prevRow[colName] = data[colName][i - 1];
        nextRow[colName] = data[colName][i + 1];
      }

      if (i === 0) { prevRow = undefined; }
      if (i === length - 1) { nextRow = undefined; }

      for (const key in mutateInstructions) {
        const mutateFunction = mutateInstructions[key];
        newData[key][i] = mutateFunction(row, i, prevRow, nextRow);
      }
    }

    Object.assign(data, newData);
  }

  function transmute (data, mutateObj) {
    data = mutate(data, mutateObj);

    for (const key in data) {
      if (!(key in mutateObj)) {
        delete data[key];
      }
    }
  }

  var aggregations = {
    count,
    sum,
    mean,
    median,
    mode,
    min,
    max
  };

  function count (column) {
    return column.length
  }

  function sum (column) {
    let total = 0;
    for (const value of column) {
      total += value;
    }

    return total
  }

  function mean (column) {
    return sum(column) / count(column)
  }

  function median (column) {
    const asc = column.sort((a, b) => a > b);
    const len = count(column);

    if (len % 2 === 1) {
      // Odd
      return asc[Math.floor(len / 2)]
    } else {
      // Even
      const lower = asc[(len / 2) - 1];
      const upper = asc[(len / 2)];
      return (lower + upper) / 2
    }
  }

  function mode (column) {
    const counts = {};

    for (const value of column) {
      if (value in counts) {
        counts[value]++;
      } else {
        counts[value] = 1;
      }
    }

    let winner;
    let winningVal = 0;

    for (const value in counts) {
      if (counts[value] > winningVal) {
        winningVal = counts[value];
        winner = value;
      }
    }

    return winner
  }

  function min (column) {
    let winner = Infinity;
    for (const value of column) {
      if (value < winner) { winner = value; }
    }
    return winner
  }

  function max (column) {
    let winner = -Infinity;
    for (const value of column) {
      if (value > winner) { winner = value; }
    }
    return winner
  }

  function checkKeyValuePair (obj, allowedKeys) {
    const keys = Object.keys(obj);
    if (keys.length !== 1) {
      throw new Error('Invalid transformation syntax')
    }

    const key = keys[0];

    if (!allowedKeys.includes(key)) {
      throw new Error(`Unknown transformation ${key}`)
    }

    return key
  }

  function summarise (data, summariseInstructions) {
    if (summariseInstructions.constructor !== Object) {
      throw new Error('summarise must be an object')
    }

    let newData = initNewData(summariseInstructions, data);

    if ('$grouped' in data) {
      checkSummariseInstructions(summariseInstructions, data);

      for (const columnName in data) {
        if (columnName !== '$grouped') {
          newData[columnName] = data[columnName];
        }
      }

      for (const group of data.$grouped) {
        const data = group.data();
        newData = summariseGroup(data, summariseInstructions, newData);
      }
    } else {
      newData = summariseGroup(data, summariseInstructions, newData);
    }
    return newData
  }

  function initNewData (summariseInstructions, data) {
    const newData = {};
    for (const newCol in summariseInstructions) { newData[newCol] = []; }
    if (data && '$grouped' in data) {
      for (const col in data) {
        if (col !== '$grouped') {
          newData[col] = [];
        }
      }
    }
    return newData
  }

  function summariseGroup (data, summariseInstructions, newData) {
    for (const newColName in summariseInstructions) {
      const instruction = summariseInstructions[newColName];

      if (instruction.constructor === Object) {
        const column = checkKeyValuePair(instruction, Object.keys(data));
        const aggregation = instruction[column];

        if (aggregation.constructor === String) {
          if (!(aggregation in aggregations)) {
            throw new Error(`Unkown summaryMethod: '${aggregation}'.`)
          }

          newData[newColName].push(aggregations[aggregation](data[column]));
        } else if (aggregation.constructor === Function) {
          newData[newColName].push(aggregation(data[column]));
        } else {
          throw new Error(`Invalid summaryMethod: '${aggregation}'. Must be String or Function`)
        }
      }
    }

    return newData
  }

  function checkSummariseInstructions (summariseInstructions, data) {
    for (const newColName in summariseInstructions) {
      const instruction = summariseInstructions[newColName];
      const name = Object.keys(instruction)[0];

      checkRegularColumnName(name);

      if (name in data) {
        throw new Error(`Cannot summarise the column '${name}': used for grouping`)
      }
    }
  }

  function mutarise (data, mutariseInstructions) {
    if (mutariseInstructions.constructor !== Object) {
      throw new Error('mutarise must be an object')
    }

    let newCols = initNewData(mutariseInstructions);

    if ('$grouped' in data) {
      checkSummariseInstructions(mutariseInstructions, data);

      for (const group of data.$grouped) {
        let summarizedData = initNewData(mutariseInstructions);
        const dataInGroup = group.data();
        summarizedData = summariseGroup(dataInGroup, mutariseInstructions, summarizedData);

        const length = getDataLength(dataInGroup);
        newCols = addGroupSummaries(newCols, summarizedData, length);
      }

      data = ungroup(data);
    } else {
      let summarizedData = initNewData(mutariseInstructions);
      summarizedData = summariseGroup(data, mutariseInstructions, summarizedData);

      const length = getDataLength(data);
      newCols = addGroupSummaries(newCols, summarizedData, length);
    }

    return join(data, newCols)
  }

  function addGroupSummaries (newCols, summarizedData, length) {
    for (let i = 0; i < length; i++) {
      for (const key in summarizedData) {
        newCols[key].push(summarizedData[key][0]);
      }
    }

    return newCols
  }

  function ungroup (data) {
    const newData = initNewData(data.$grouped[0].data());

    for (const group of data.$grouped) {
      const groupData = group.data();
      for (const col in newData) {
        newData[col].push(...groupData[col]);
      }
    }

    return newData
  }

  function join (data, newCols) {
    for (const col in newCols) {
      data[col] = newCols[col];
    }

    return data
  }

  function groupBy (data, groupByInstructions) {
    const groupedData = {};

    const groupedColumns = getGroupedColumns(data, groupByInstructions);
    const groups = groupBy$1(data, groupedColumns);

    groupedData.$grouped = groups.map(group => new DataContainer(group));
    for (const col of groupedColumns) {
      groupedData[col] = [];
    }

    for (let i = 0; i < groupedColumns.length; i++) {
      const col = groupedColumns[i];

      for (const group of groups) {
        groupedData[col].push(group.groupedValues[i]);
      }
    }

    return groupedData
  }

  function getGroupedColumns (data, groupByInstructions) {
    const con = groupByInstructions.constructor;
    if (![String, Array].includes(con)) {
      throw new Error('groupBy can only be used with a string or array of strings')
    }

    const groupedColumns = con === String ? [groupByInstructions] : groupByInstructions;

    for (const col of groupedColumns) {
      if (!(col in data)) {
        throw new Error(`Column '${col}' not found`)
      }
    }

    if (groupedColumns.length === Object.keys(data).length) {
      throw new Error('Cannot group by all columns')
    }

    return groupedColumns
  }

  function getGroupedValues (data, i, columns) {
    const groupedValues = [];
    for (const col of columns) {
      groupedValues.push(data[col][i]);
    }

    return groupedValues
  }

  function groupBy$1 (data, groupedColumns) {
    const groups = {};

    const length = getDataLength(data);

    for (let i = 0; i < length; i++) {
      // Ge grouped values
      const groupedValues = getGroupedValues(data, i, groupedColumns);

      // Get unique identifier for group
      const groupID = JSON.stringify(groupedValues);

      // If groups object has no entry for this group yet: create new group object
      groups[groupID] = groups[groupID] || new Group(data, groupedValues);

      // Add row to group
      groups[groupID].addRow(data, i);
    }

    // Convert groups object to array
    return Object.keys(groups).map(group => {
      return groups[group]
    })
  }

  class Group {
    constructor (data, groupedValues) {
      this.data = {};
      this.groupedValues = groupedValues;

      for (const col in data) {
        this.data[col] = [];
      }
    }

    addRow (data, i) {
      for (const col in data) {
        this.data[col].push(data[col][i]);
      }
    }
  }

  /**
  * geostats() is a tiny and standalone javascript library for classification
  * Project page - https://github.com/simogeo/geostats
  * Copyright (c) 2011 Simon Georget, http://www.intermezzo-coop.eu
  * Licensed under the MIT license
  */

  var _t = function (str) {
    return str
  };

  // taking from http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric
  var isNumber = function (n) {
    return !isNaN(parseFloat(n)) && isFinite(n)
  };

  function Geostats (a) {
    this.objectID = '';
    this.separator = ' - ';
    this.legendSeparator = this.separator;
    this.method = '';
    this.precision = 0;
    this.precisionflag = 'auto';
    this.roundlength = 2; // Number of decimals, round values
    this.is_uniqueValues = false;
    this.debug = false;
    this.silent = false;

    this.bounds = [];
    this.ranges = [];
    this.inner_ranges = null;
    this.colors = [];
    this.counter = [];

    // statistics information
    this.stat_sorted = null;
    this.stat_mean = null;
    this.stat_median = null;
    this.stat_sum = null;
    this.stat_max = null;
    this.stat_min = null;
    this.stat_pop = null;
    this.stat_variance = null;
    this.stat_stddev = null;
    this.stat_cov = null;

    /**
   * logging method
   */
    this.log = function (msg, force) {
      if (this.debug === true || force != null) {
        console.log(this.objectID + '(object id) :: ' + msg);
      }
    };

    /**
   * Set bounds
   */
    this.setBounds = function (a) {
      this.log('Setting bounds (' + a.length + ') : ' + a.join());

      this.bounds = []; // init empty array to prevent bug when calling classification after another with less items (sample getQuantile(6) and getQuantile(4))

      this.bounds = a;
      // this.bounds = this.decimalFormat(a);
    };

    /**
   * Set a new serie
   */
    this.setSerie = function (a) {
      this.log('Setting serie (' + a.length + ') : ' + a.join());

      this.serie = []; // init empty array to prevent bug when calling classification after another with less items (sample getQuantile(6) and getQuantile(4))
      this.serie = a;

      // reset statistics after changing serie
      this.resetStatistics();

      this.setPrecision();
    };

    /**
   * Set colors
   */
    this.setColors = function (colors) {
      this.log('Setting color ramp (' + colors.length + ') : ' + colors.join());

      this.colors = colors;
    };

    /**
     * Get feature count
     * With bounds array(0, 0.75, 1.5, 2.25, 3);
     * should populate this.counter with 5 keys
     * and increment counters for each key
     */
    this.doCount = function () {
      if (this._nodata()) { return }

      var tmp = this.sorted();

      this.counter = [];

      // we init counter with 0 value
      for (let i = 0; i < this.bounds.length - 1; i++) {
        this.counter[i] = 0;
      }

      for (let j = 0; j < tmp.length; j++) {
        // get current class for value to increment the counter
        var cclass = this.getClass(tmp[j]);
        this.counter[cclass]++;
      }
    };

    /**
     * Set decimal precision according to user input
     * or automatcally determined according
     * to the given serie.
     */
    this.setPrecision = function (decimals) {
      // only when called from user
      if (typeof decimals !== 'undefined') {
        this.precisionflag = 'manual';
        this.precision = decimals;
      }

      // we calculate the maximal decimal length on given serie
      if (this.precisionflag === 'auto') {
        for (var i = 0; i < this.serie.length; i++) {
          // check if the given value is a number and a float
          var precision;
          if (!isNaN((this.serie[i] + '')) && (this.serie[i] + '').toString().indexOf('.') !== -1) {
            precision = (this.serie[i] + '').split('.')[1].length;
          } else {
            precision = 0;
          }

          if (precision > this.precision) {
            this.precision = precision;
          }
        }
      }
      if (this.precision > 20) {
        // prevent "Uncaught RangeError: toFixed() digits argument must be between 0 and 20" bug. See https://github.com/simogeo/geostats/issues/34
        this.log('this.precision value (' + this.precision + ') is greater than max value. Automatic set-up to 20 to prevent "Uncaught RangeError: toFixed()" when calling decimalFormat() method.');
        this.precision = 20;
      }

      this.log('Calling setPrecision(). Mode : ' + this.precisionflag + ' - Decimals : ' + this.precision);

      this.serie = this.decimalFormat(this.serie);
    };

    /**
     * Format array numbers regarding to precision
     */
    this.decimalFormat = function (a) {
      var b = [];

      for (var i = 0; i < a.length; i++) {
        // check if the given value is a number
        if (isNumber(a[i])) {
          b[i] = parseFloat(parseFloat(a[i]).toFixed(this.precision));
        } else {
          b[i] = a[i];
        }
      }

      return b
    };

    /**
     * Transform a bounds array to a range array the following array : array(0,
     * 0.75, 1.5, 2.25, 3); becomes : array('0-0.75', '0.75-1.5', '1.5-2.25',
     * '2.25-3');
     */
    this.setRanges = function () {
      this.ranges = []; // init empty array to prevent bug when calling classification after another with less items (sample getQuantile(6) and getQuantile(4))

      for (let i = 0; i < (this.bounds.length - 1); i++) {
        this.ranges[i] = this.bounds[i] + this.separator + this.bounds[i + 1];
      }
    };

    /** return min value */
    this.min = function () {
      if (this._nodata()) { return }

      this.stat_min = this.serie[0];

      for (let i = 0; i < this.pop(); i++) {
        if (this.serie[i] < this.stat_min) {
          this.stat_min = this.serie[i];
        }
      }

      return this.stat_min
    };

    /** return max value */
    this.max = function () {
      if (this._nodata()) { return }

      this.stat_max = this.serie[0];
      for (let i = 0; i < this.pop(); i++) {
        if (this.serie[i] > this.stat_max) {
          this.stat_max = this.serie[i];
        }
      }

      return this.stat_max
    };

    /** return sum value */
    this.sum = function () {
      if (this._nodata()) { return }

      if (this.stat_sum === null) {
        this.stat_sum = 0;
        for (let i = 0; i < this.pop(); i++) {
          this.stat_sum += parseFloat(this.serie[i]);
        }
      }

      return this.stat_sum
    };

    /** return population number */
    this.pop = function () {
      if (this._nodata()) { return }

      if (this.stat_pop === null) {
        this.stat_pop = this.serie.length;
      }

      return this.stat_pop
    };

    /** return mean value */
    this.mean = function () {
      if (this._nodata()) { return }

      if (this.stat_mean === null) {
        this.stat_mean = parseFloat(this.sum() / this.pop());
      }

      return this.stat_mean
    };

    /** return median value */
    this.median = function () {
      if (this._nodata()) { return }

      if (this.stat_median === null) {
        this.stat_median = 0;
        var tmp = this.sorted();

        // serie pop is odd
        if (tmp.length % 2) {
          this.stat_median = parseFloat(tmp[(Math.ceil(tmp.length / 2) - 1)]);

        // serie pop is even
        } else {
          this.stat_median = (parseFloat(tmp[((tmp.length / 2) - 1)]) + parseFloat(tmp[(tmp.length / 2)])) / 2;
        }
      }

      return this.stat_median
    };

    /** return variance value */
    this.variance = function (round) {
      round = (typeof round === 'undefined');

      if (this._nodata()) { return }

      if (this.stat_variance === null) {
        var tmp = 0;
        var serieMean = this.mean();
        for (var i = 0; i < this.pop(); i++) {
          tmp += Math.pow((this.serie[i] - serieMean), 2);
        }

        this.stat_variance = tmp / this.pop();

        if (round === true) {
          this.stat_variance = Math.round(this.stat_variance * Math.pow(10, this.roundlength)) / Math.pow(10, this.roundlength);
        }
      }

      return this.stat_variance
    };

    /** return standard deviation value */
    this.stddev = function (round) {
      round = (typeof round === 'undefined');

      if (this._nodata()) { return }

      if (this.stat_stddev === null) {
        this.stat_stddev = Math.sqrt(this.variance());

        if (round === true) {
          this.stat_stddev = Math.round(this.stat_stddev * Math.pow(10, this.roundlength)) / Math.pow(10, this.roundlength);
        }
      }

      return this.stat_stddev
    };

    /** coefficient of variation - measure of dispersion */
    this.cov = function (round) {
      round = (typeof round === 'undefined');

      if (this._nodata()) { return }

      if (this.stat_cov === null) {
        this.stat_cov = this.stddev() / this.mean();

        if (round === true) {
          this.stat_cov = Math.round(this.stat_cov * Math.pow(10, this.roundlength)) / Math.pow(10, this.roundlength);
        }
      }

      return this.stat_cov
    };

    /** reset all attributes after setting a new serie */
    this.resetStatistics = function () {
      this.stat_sorted = null;
      this.stat_mean = null;
      this.stat_median = null;
      this.stat_sum = null;
      this.stat_max = null;
      this.stat_min = null;
      this.stat_pop = null;
      this.stat_variance = null;
      this.stat_stddev = null;
      this.stat_cov = null;
    };

    /** data test */
    this._nodata = function () {
      if (this.serie.length === 0) {
        if (this.silent) this.log('[silent mode] Error. You should first enter a serie!', true);
        else throw new TypeError('Error. You should first enter a serie!')
        return 1
      } else { return 0 }
    };

    /** ensure nbClass is an integer */
    this._nbClassInt = function (nbClass) {
      var nbclassTmp = parseInt(nbClass, 10);
      if (isNaN(nbclassTmp)) {
        if (this.silent) this.log("[silent mode] '" + nbclassTmp + "' is not a valid integer. Enable to set class number.", true);
        else throw new TypeError("'" + nbclassTmp + "' is not a valid integer. Enable to set class number.")
      } else {
        return nbclassTmp
      }
    };

    /** check if the serie contains negative value */
    this._hasNegativeValue = function () {
      for (let i = 0; i < this.serie.length; i++) {
        if (this.serie[i] < 0) { return true }
      }
      return false
    };

    /** check if the serie contains zero value */
    this._hasZeroValue = function () {
      for (let i = 0; i < this.serie.length; i++) {
        if (parseFloat(this.serie[i]) === 0) { return true }
      }
      return false
    };

    /** return sorted values (as array) */
    this.sorted = function () {
      if (this.stat_sorted === null) {
        if (this.is_uniqueValues === false) {
          this.stat_sorted = this.serie.sort(function (a, b) {
            return a - b
          });
        } else {
          this.stat_sorted = this.serie.sort(function (a, b) {
            var nameA = a.toString().toLowerCase(); var nameB = b.toString().toLowerCase();
            if (nameA < nameB) return -1
            if (nameA > nameB) return 1
            return 0
          });
        }
      }

      return this.stat_sorted
    };

    /**
   * Set Manual classification Return an array with bounds : ie array(0,
   * 0.75, 1.5, 2.25, 3);
   * Set ranges and prepare data for displaying legend
   *
   */
    this.setClassManually = function (array) {
      if (this._nodata()) { return }

      if (array[0] !== this.min() || array[array.length - 1] !== this.max()) {
        if (this.silent) this.log('[silent mode] ' + _t('Given bounds may not be correct! please check your input.\nMin value : ' + this.min() + ' / Max value : ' + this.max()), true);
        else throw new TypeError(_t('Given bounds may not be correct! please check your input.\nMin value : ' + this.min() + ' / Max value : ' + this.max()))
        return
      }

      this.setBounds(array);
      this.setRanges();

      // we specify the classification method
      this.method = _t('manual classification') + ' (' + (array.length - 1) + ' ' + _t('classes') + ')';

      return this.bounds
    };

    /**
   * Equal intervals classification Return an array with bounds : ie array(0,
   * 0.75, 1.5, 2.25, 3);
   */
    this.getClassEqInterval = function (nbClass, forceMin, forceMax) {
      nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

      if (this._nodata()) { return }

      var tmpMin = (typeof forceMin === 'undefined') ? this.min() : forceMin;
      var tmpMax = (typeof forceMax === 'undefined') ? this.max() : forceMax;

      var a = [];
      var val = tmpMin;
      var interval = (tmpMax - tmpMin) / nbClass;

      for (let i = 0; i <= nbClass; i++) {
        a[i] = val;
        val += interval;
      }

      // -> Fix last bound to Max of values
      a[nbClass] = tmpMax;

      this.setBounds(a);
      this.setRanges();

      // we specify the classification method
      this.method = _t('eq. intervals') + ' (' + nbClass + ' ' + _t('classes') + ')';

      return this.bounds
    };

    this.getQuantiles = function (nbClass) {
      nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

      var tmp = this.sorted();
      var quantiles = [];

      var step = this.pop() / nbClass;
      for (var i = 1; i < nbClass; i++) {
        var qidx = Math.round(i * step + 0.49);
        quantiles.push(tmp[qidx - 1]); // zero-based
      }

      return quantiles
    };

    /**
   * Quantile classification Return an array with bounds : ie array(0, 0.75,
   * 1.5, 2.25, 3);
   */
    this.getClassQuantile = function (nbClass) {
      nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

      if (this._nodata()) { return }

      var tmp = this.sorted();
      var bounds = this.getQuantiles(nbClass);
      bounds.unshift(tmp[0]);

      if (bounds[tmp.length - 1] !== tmp[tmp.length - 1]) { bounds.push(tmp[tmp.length - 1]); }

      this.setBounds(bounds);
      this.setRanges();

      // we specify the classification method
      this.method = _t('quantile') + ' (' + nbClass + ' ' + _t('classes') + ')';

      return this.bounds
    };

    /**
   * Standard Deviation classification
   * Return an array with bounds : ie array(0,
   * 0.75, 1.5, 2.25, 3);
   */
    this.getClassStdDeviation = function (nbClass, matchBounds) {
      nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

      if (this._nodata()) { return }

      var tmpMax = this.max();
      var tmpMin = this.min();
      var tmpStdDev = this.stddev();
      var tmpMean = this.mean();

      var a = [];

      // number of classes is odd
      if (nbClass % 2 === 1) {
        // Euclidean division to get the inferior bound
        var infBound = Math.floor(nbClass / 2);

        var supBound = infBound + 1;

        // we set the central bounds
        a[infBound] = tmpMean - (tmpStdDev / 2);
        a[supBound] = tmpMean + (tmpStdDev / 2);

        // Values < to infBound, except first one
        for (let i = infBound - 1; i > 0; i--) {
          let val = a[i + 1] - tmpStdDev;
          a[i] = val;
        }

        // Values > to supBound, except last one
        for (let i = supBound + 1; i < nbClass; i++) {
          let val = a[i - 1] + tmpStdDev;
          a[i] = val;
        }

        // number of classes is even
      } else {
        var meanBound = nbClass / 2;

        // we get the mean value
        a[meanBound] = tmpMean;

        // Values < to the mean, except first one
        for (let i = meanBound - 1; i > 0; i--) {
          let val = a[i + 1] - tmpStdDev;
          a[i] = val;
        }

        // Values > to the mean, except last one
        for (let i = meanBound + 1; i < nbClass; i++) {
          let val = a[i - 1] + tmpStdDev;
          a[i] = val;
        }
      }

      // we finally set the first value
      // do we excatly match min value or not ?
      a[0] = (typeof matchBounds === 'undefined') ? a[1] - tmpStdDev : tmpMin;

      // we finally set the last value
      // do we excatly match max value or not ?
      a[nbClass] = (typeof matchBounds === 'undefined') ? a[nbClass - 1] + tmpStdDev : tmpMax;

      this.setBounds(a);
      this.setRanges();

      // we specify the classification method
      this.method = _t('std deviation') + ' (' + nbClass + ' ' + _t('classes') + ')';

      return this.bounds
    };

    /**
   * Geometric Progression classification
   * http://en.wikipedia.org/wiki/Geometric_progression
   * Return an array with bounds : ie array(0,
   * 0.75, 1.5, 2.25, 3);
   */
    this.getClassGeometricProgression = function (nbClass) {
      nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

      if (this._nodata()) { return }

      if (this._hasNegativeValue() || this._hasZeroValue()) {
        if (this.silent) this.log('[silent mode] ' + _t('geometric progression can\'t be applied with a serie containing negative or zero values.'), true);
        else throw new TypeError(_t('geometric progression can\'t be applied with a serie containing negative or zero values.'))
        return
      }

      var a = [];
      var tmpMin = this.min();
      var tmpMax = this.max();

      var logMax = Math.log(tmpMax) / Math.LN10; // max decimal logarithm (or base 10)
      var logMin = Math.log(tmpMin) / Math.LN10; // min decimal logarithm (or base 10)

      var interval = (logMax - logMin) / nbClass;

      // we compute log bounds
      for (let i = 0; i < nbClass; i++) {
        if (i === 0) {
          a[i] = logMin;
        } else {
          a[i] = a[i - 1] + interval;
        }
      }

      // we compute antilog
      a = a.map(function (x) { return Math.pow(10, x) });

      // and we finally add max value
      a.push(this.max());

      this.setBounds(a);
      this.setRanges();

      // we specify the classification method
      this.method = _t('geometric progression') + ' (' + nbClass + ' ' + _t('classes') + ')';

      return this.bounds
    };

    /**
   * Arithmetic Progression classification
   * http://en.wikipedia.org/wiki/Arithmetic_progression
   * Return an array with bounds : ie array(0,
   * 0.75, 1.5, 2.25, 3);
   */
    this.getClassArithmeticProgression = function (nbClass) {
      nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

      if (this._nodata()) { return }

      var denominator = 0;

      // we compute the (french) "Raison"
      for (let i = 1; i <= nbClass; i++) {
        denominator += i;
      }

      var a = [];
      var tmpMin = this.min();
      var tmpMax = this.max();

      var interval = (tmpMax - tmpMin) / denominator;

      for (let i = 0; i <= nbClass; i++) {
        if (i === 0) {
          a[i] = tmpMin;
        } else {
          a[i] = a[i - 1] + (i * interval);
        }
      }

      this.setBounds(a);
      this.setRanges();

      // we specify the classification method
      this.method = _t('arithmetic progression') + ' (' + nbClass + ' ' + _t('classes') + ')';

      return this.bounds
    };

    /**
   * Credits : Doug Curl (javascript) and Daniel J Lewis (python implementation)
   * http://www.arcgis.com/home/item.html?id=0b633ff2f40d412995b8be377211c47b
   * http://danieljlewis.org/2010/06/07/jenks-natural-breaks-algorithm-in-python/
   */
    this.getClassJenks = function (nbClass) {
      nbClass = this._nbClassInt(nbClass); // ensure nbClass is an integer

      if (this._nodata()) { return }

      let dataList = this.sorted();

      // now iterate through the datalist:
      // determine mat1 and mat2
      // really not sure how these 2 different arrays are set - the code for
      // each seems the same!
      // but the effect are 2 different arrays: mat1 and mat2
      var mat1 = [];
      // for (var x = 0, xl = dataList.length + 1; x < xl; x++) {
      for (var x = 0; x < dataList.length + 1; x++) {
        var temp = [];
        for (var j = 0, jl = nbClass + 1; j < jl; j++) {
          temp.push(0);
        }
        mat1.push(temp);
      }

      var mat2 = [];
      // for (var i = 0, il = dataList.length + 1; i < il; i++) {
      for (var i = 0; i < dataList.length + 1; i++) {
        var temp2 = [];
        for (var c = 0, cl = nbClass + 1; c < cl; c++) {
          temp2.push(0);
        }
        mat2.push(temp2);
      }

      // absolutely no idea what this does - best I can tell, it sets the 1st
      // group in the
      // mat1 and mat2 arrays to 1 and 0 respectively
      for (var y = 1, yl = nbClass + 1; y < yl; y++) {
        mat1[0][y] = 1;
        mat2[0][y] = 0;
        for (var t = 1, tl = dataList.length + 1; t < tl; t++) {
          mat2[t][y] = Infinity;
        }
        var v = 0.0;
      }

      // and this part - I'm a little clueless on - but it works
      // pretty sure it iterates across the entire dataset and compares each
      // value to
      // one another to and adjust the indices until you meet the rules:
      // minimum deviation
      // within a class and maximum separation between classes
      for (var l = 2, ll = dataList.length + 1; l < ll; l++) {
        var s1 = 0.0;
        var s2 = 0.0;
        var w = 0.0;
        for (var m = 1, ml = l + 1; m < ml; m++) {
          var i3 = l - m + 1;
          var val = parseFloat(dataList[i3 - 1]);
          s2 += val * val;
          s1 += val;
          w += 1;
          v = s2 - (s1 * s1) / w;
          var i4 = i3 - 1;
          if (i4 !== 0) {
            for (var p = 2, pl = nbClass + 1; p < pl; p++) {
              if (mat2[l][p] >= (v + mat2[i4][p - 1])) {
                mat1[l][p] = i3;
                mat2[l][p] = v + mat2[i4][p - 1];
              }
            }
          }
        }
        mat1[l][1] = 1;
        mat2[l][1] = v;
      }

      var k = dataList.length;
      var kclass = [];

      // fill the kclass (classification) array with zeros:
      for (i = 0; i <= nbClass; i++) {
        kclass.push(0);
      }

      // this is the last number in the array:
      kclass[nbClass] = parseFloat(dataList[dataList.length - 1]);
      // this is the first number - can set to zero, but want to set to lowest
      // to use for legend:
      kclass[0] = parseFloat(dataList[0]);
      var countNum = nbClass;
      while (countNum >= 2) {
        var id = parseInt((mat1[k][countNum]) - 2);
        kclass[countNum - 1] = dataList[id];
        k = parseInt((mat1[k][countNum] - 1));
        // spits out the rank and value of the break values:
        // console.log("id="+id,"rank = " + String(mat1[k][countNum]),"val =
        // " + String(dataList[id]))
        // count down:
        countNum -= 1;
      }
      // check to see if the 0 and 1 in the array are the same - if so, set 0
      // to 0:
      if (kclass[0] === kclass[1]) {
        kclass[0] = 0;
      }

      this.setBounds(kclass);
      this.setRanges();

      this.method = _t('Jenks') + ' (' + nbClass + ' ' + _t('classes') + ')';

      return this.bounds // array of breaks
    };

    /**
   * Quantile classification Return an array with bounds : ie array(0, 0.75,
   * 1.5, 2.25, 3);
   */
    this.getClassUniqueValues = function () {
      if (this._nodata()) { return }

      this.is_uniqueValues = true;
      var tmp = this.sorted(); // display in alphabetical order

      var a = [];

      for (let i = 0; i < this.pop(); i++) {
        if (a.indexOf(tmp[i]) === -1) {
          a.push(tmp[i]);
        }
      }

      this.bounds = a;

      // we specify the classification method
      this.method = _t('unique values');

      return a
    };

    /**
   * Return the class of a given value.
   * For example value : 6
   * and bounds array = (0, 4, 8, 12);
   * Return 2
   */
    this.getClass = function (value) {
      for (let i = 0; i < this.bounds.length; i++) {
        if (this.is_uniqueValues === true) {
          if (value === this.bounds[i]) { return i }
        } else {
        // parseFloat() is necessary
          if (parseFloat(value) <= this.bounds[i + 1]) {
            return i
          }
        }
      }

      return _t("Unable to get value's class.")
    };

    /**
   * Return the ranges array : array('0-0.75', '0.75-1.5', '1.5-2.25',
   * '2.25-3');
   */
    this.getRanges = function () {
      return this.ranges
    };

    /**
   * Returns the number/index of this.ranges that value falls into
   */
    this.getRangeNum = function (value) {
      var bounds, i;

      for (i = 0; i < this.ranges.length; i++) {
        bounds = this.ranges[i].split(/ - /);
        if (value <= parseFloat(bounds[1])) {
          return i
        }
      }
    };

    /*
   * Compute inner ranges based on serie.
   * Produce discontinous ranges used for legend - return an array similar to :
   * array('0.00-0.74', '0.98-1.52', '1.78-2.25', '2.99-3.14');
   * If inner ranges already computed, return array values.
   */
    this.getInnerRanges = function () {
      // if already computed, we return the result
      if (this.inner_ranges != null) {
        return this.inner_ranges
      }

      var a = [];
      var tmp = this.sorted();
      var cnt = 1; // bounds array counter

      for (let i = 0; i < tmp.length; i++) {
        let rangeFirstValue;
        if (i === 0) {
          rangeFirstValue = tmp[i]; // we init first range value
        }

        if (parseFloat(tmp[i]) > parseFloat(this.bounds[cnt])) {
          a[cnt - 1] = '' + rangeFirstValue + this.separator + tmp[i - 1];

          rangeFirstValue = tmp[i];

          cnt++;
        }

        // we reach the last range, we finally complete manually
        // and return the array
        if (cnt === (this.bounds.length - 1)) {
        // we set the last value
          a[cnt - 1] = '' + rangeFirstValue + this.separator + tmp[tmp.length - 1];

          this.inner_ranges = a;
          return this.inner_ranges
        }
      }
    };

    this.getSortedlist = function () {
      return this.sorted().join(', ')
    };

    // object constructor
    // At the end of script. If not setPrecision() method is not known

    // we create an object identifier for debugging
    this.objectID = new Date().getUTCMilliseconds();
    this.log('Creating new geostats object');

    if (typeof a !== 'undefined' && a.length > 0) {
      this.serie = a;
      this.setPrecision();
      this.log('Setting serie (' + a.length + ') : ' + a.join());
    } else {
      this.serie = [];
    }

    // creating aliases on classification function for backward compatibility
    this.getJenks = this.getClassJenks;
    this.getGeometricProgression = this.getClassGeometricProgression;
    this.getEqInterval = this.getClassEqInterval;
    this.getQuantile = this.getClassQuantile;
    this.getStdDeviation = this.getClassStdDeviation;
    this.getUniqueValues = this.getClassUniqueValues;
    this.getArithmeticProgression = this.getClassArithmeticProgression;
  }

  function bin (data, binInstructions) {
    if (binInstructions.constructor === Object) {
      const intervalBounds = getIntervalBounds(data, binInstructions);
      const ranges = pairRanges(intervalBounds);

      return bin1d(data, binInstructions.groupBy, ranges)
    }

    if (binInstructions.constructor === Array) {
      const intervalBoundsPerVariable = binInstructions.map(instructions => getIntervalBounds(data, instructions));
      const rangesPerVariable = intervalBoundsPerVariable.map(bounds => pairRanges(bounds));
      const variables = binInstructions.map(instructions => instructions.groupBy);

      return binKd(data, variables, rangesPerVariable)
    }
  }

  function getIntervalBounds (data, binInstructions) {
    const { groupBy, method, numClasses } = parseBinInstructions(binInstructions);

    const variableData = data[groupBy];
    if (!variableData) {
      throw new Error(`groupBy column '${groupBy}' does not exist`)
    }

    if (method === 'IntervalSize') {
      return createRangesFromBinSize(variableData, binInstructions.binSize)
    }

    if (method === 'Manual') {
      return binInstructions.manualClasses
    }

    const geoStat = new Geostats(variableData);
    return geoStat[methodMap[method]](numClasses)
  }

  function parseBinInstructions (binInstructions) {
    if (binInstructions.constructor !== Object) {
      throw new Error('Bin only accepts an Object')
    }

    const groupBy = binInstructions.groupBy;
    if (groupBy.constructor !== String) {
      throw new Error('groupBy only accepts a String variable name')
    }

    let method = binInstructions.method;
    if (!method) {
      warn('No binning method specified, defaulting to EqualInterval');
      method = 'EqualInterval';
    }
    if (method.constructor !== String) {
      warn('Binning method not recognized, defaulting to EqualInterval');
      method = 'EqualInterval';
    }

    let numClasses = binInstructions.numClasses;
    if (!numClasses) {
      warn('numClasses not specified, defaulting to 5');
      numClasses = 5;
    }

    return { groupBy, method, numClasses }
  }

  function createRangesFromBinSize (variableData, binSize) {
    if (!binSize) {
      throw new Error('Missing required option \'binSize\'')
    }

    const domain = calculateDomain(variableData);

    const binCount = Math.floor((domain[1] - domain[0]) / binSize);

    let lowerBound = domain[0];
    const ranges = [lowerBound];

    for (let i = 0; i < binCount - 1; i++) {
      const upperBound = lowerBound + binSize;
      ranges.push(upperBound);
      lowerBound = upperBound;
    }

    ranges.push(domain[1]);

    return ranges
  }

  const methodMap = {
    EqualInterval: 'getClassEqInterval',
    StandardDeviation: 'getClassStdDeviation',
    ArithmeticProgression: 'getClassArithmeticProgression',
    GeometricProgression: 'getClassGeometricProgression',
    Quantile: 'getClassQuantile',
    Jenks: 'getClassJenks'
  };

  function pairRanges (ranges) {
    const l = ranges.length;
    const newRange = [];

    for (let i = 0; i < l - 1; i++) {
      newRange.push([ranges[i], ranges[i + 1]]);
    }

    return newRange
  }

  function bin1d (data, variable, ranges) {
    // Create an empty array to store new groups divided by range
    const groups = Array(ranges.length);

    for (let i = 0; i < groups.length; i++) {
      groups[i] = {};

      for (const col in data) {
        groups[i][col] = [];
      }
    }

    const length = getDataLength(data);

    for (let i = 0; i < length; i++) {
      const value = data[variable][i];
      const binIndex = getBinIndex(ranges, value);

      if (binIndex !== -1) {
        for (const col in data) {
          groups[binIndex][col].push(data[col][i]);
        }
      }
    }

    // Remove empty bins
    const nonEmptyBinIndices = getNonEmptyBinIndices(groups);
    const nonEmptyRanges = nonEmptyBinIndices.map(i => ranges[i]);
    const nonEmptyGroups = nonEmptyBinIndices.map(i => groups[i]);

    // Add new grouped column to newData
    const newData = {
      bins: nonEmptyRanges,
      $grouped: nonEmptyGroups.map(group => new DataContainer(group, { validate: false }))
    };

    return newData
  }

  function getBinIndex (bins, value) {
    // Find index of bin in which the instance belongs
    const binIndex = bins.findIndex(function (bin, i) {
      if (i === bins.length - 1) {
        return value >= bin[0] && value <= bin[1]
      } else {
        return value >= bin[0] && value < bin[1]
      }
    });

    return binIndex
  }

  function getNonEmptyBinIndices (groups) {
    const nonEmptyBinIndices = [];

    for (let i = 0; i < groups.length; i++) {
      if (getDataLength(groups[i]) > 0) nonEmptyBinIndices.push(i);
    }

    return nonEmptyBinIndices
  }

  function binKd (data, variables, rangesPerVariable) {
    const binIndexTree = constructBinIndexTree(data, variables, rangesPerVariable);
    const binnedData = convertTreeIntoColumnData(binIndexTree, variables, rangesPerVariable);

    binnedData.$grouped = binnedData.$grouped.map(group => new DataContainer(group, { validate: false }));

    return binnedData
  }

  function constructBinIndexTree (data, variables, rangesPerVariable) {
    let binIndexTree = {};
    const dataLength = getDataLength(data);

    for (let i = 0; i < dataLength; i++) {
      const binIndices = getBinIndices(data, i, variables, rangesPerVariable);
      if (rowIsNotEmpty(binIndices)) {
        binIndexTree = updateBranch(binIndexTree, binIndices, data, i);
      }
    }

    return binIndexTree
  }

  function getBinIndices (data, index, variables, rangesPerVariable) {
    const binIndices = [];

    for (let i = 0; i < variables.length; i++) {
      const variable = variables[i];
      const value = data[variable][index];

      binIndices.push(getBinIndex(rangesPerVariable[i], value));
    }

    return binIndices
  }

  function rowIsNotEmpty (binIndices) {
    return binIndices.every(binIndex => binIndex > -1)
  }

  function updateBranch (tree, indices, data, rowIndex) {
    let currentLevel = tree;

    for (let i = 0; i < indices.length; i++) {
      const index = indices[i];

      if (lastIndex(i, indices.length)) {
        if (!(index in currentLevel)) {
          currentLevel[index] = initGroup(data);
        }

        currentLevel[index] = addRow(currentLevel[index], data, rowIndex);
      } else {
        if (!(index in currentLevel)) {
          currentLevel[index] = {};
        }

        currentLevel = currentLevel[index];
      }
    }

    return tree
  }

  function lastIndex (i, length) {
    return i === (length - 1)
  }

  function initGroup (data) {
    const group = {};
    for (const columnName in data) {
      group[columnName] = [];
    }

    return group
  }

  function addRow (group, data, rowIndex) {
    for (const columnName in data) {
      group[columnName].push(data[columnName][rowIndex]);
    }

    return group
  }

  function convertTreeIntoColumnData (binIndexTree, variables, binsPerVariable) {
    const columnData = initColumnData$1(variables);
    const dataIndex = variables.length;

    forEachBranch(binIndexTree, branchArray => {
      for (let i = 0; i < variables.length; i++) {
        const binIndex = branchArray[i];
        const bin = binsPerVariable[i][binIndex];

        const binnedColumnName = getBinnedColumnName(variables[i]);

        columnData[binnedColumnName].push(bin);
      }

      columnData.$grouped.push(branchArray[dataIndex]);
    });

    return columnData
  }

  function initColumnData$1 (variables) {
    const columnData = { $grouped: [] };

    for (let i = 0; i < variables.length; i++) {
      const binnedColumnName = getBinnedColumnName(variables[i]);
      columnData[binnedColumnName] = [];
    }

    return columnData
  }

  function forEachBranch (tree, callback) {
    for (const path of traverse(tree)) {
      callback(path);
    }
  }

  // https://stackoverflow.com/a/45628445
  function * traverse (o) {
    const memory = new Set();

    function * innerTraversal (o, path = []) {
      if (memory.has(o)) {
        // we've seen this object before don't iterate it
        return
      }

      // add the new object to our memory.
      memory.add(o);

      for (const i of Object.keys(o)) {
        const itemPath = path.concat(i);

        if (!('$key' in o[i])) {
          yield * innerTraversal(o[i], itemPath);
        } else {
          itemPath.push(o[i]);
          yield itemPath;
        }
      }
    }

    yield * innerTraversal(o);
  }

  function getBinnedColumnName (columnName) {
    return 'bins_' + columnName
  }

  function dropNA (data, dropInstructions) {
    let filterFunc;

    if (!dropInstructions) {
      // If the instructions are falsy, we will check all columns for invalid values
      filterFunc = row => {
        let keep = true;

        for (const key in row) {
          const val = row[key];
          if (isInvalid(val)) {
            keep = false;
            break
          }
        }

        return keep
      };
    } else if (dropInstructions.constructor === String) {
      // If the instructions are a string, we check only one column for invalid values
      checkIfColumnsExist(data, [dropInstructions]);
      filterFunc = row => !isInvalid(row[dropInstructions]);
    } else if (dropInstructions.constructor === Array) {
      // if the instructions are an array, we check the columns named in the array
      checkIfColumnsExist(data, dropInstructions);
      filterFunc = row => {
        let keep = true;
        for (const col of dropInstructions) {
          if (isInvalid(row[col])) {
            keep = false;
            break
          }
        }

        return keep
      };
    } else {
      throw new Error('dropNA can only be passed undefined, a String or an Array of Strings')
    }

    return filter(data, filterFunc)
  }

  function checkIfColumnsExist (data, columns) {
    for (const col of columns) {
      if (!(col in data)) {
        throw new Error(`Column '${col}' not found`)
      }
    }
  }

  // This function comes from Turf's wonderful geospatial lib
  // We only need this single function and importing it from @turf/meta
  // doesn't work well for in-browser compilation
  // https://github.com/Turfjs/turf

  // The MIT License (MIT)

  // Copyright (c) 2019 Morgan Herlocker

  // Permission is hereby granted, free of charge, to any person obtaining a copy of
  // this software and associated documentation files (the "Software"), to deal in
  // the Software without restriction, including without limitation the rights to
  // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  // the Software, and to permit persons to whom the Software is furnished to do so,
  // subject to the following conditions:

  // The above copyright notice and this permission notice shall be included in all
  // copies or substantial portions of the Software.

  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  // FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  // COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  // IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  // CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  function coordEach (geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return
    var j; var k; var l; var geometry; var stopG; var coords;
    var geometryMaybeCollection;
    var wrapShrink = 0;
    var coordIndex = 0;
    var isGeometryCollection;
    var type = geojson.type;
    var isFeatureCollection = type === 'FeatureCollection';
    var isFeature = type === 'Feature';
    var stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry
        : (isFeature ? geojson.geometry : geojson));
      isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection
          ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

        // Handles null Geometry -- Skips this geometry
        if (geometry === null) continue
        coords = geometry.coordinates;
        var geomType = geometry.type;

        wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

        switch (geomType) {
          case null:
            break
          case 'Point':
            if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
            coordIndex++;
            multiFeatureIndex++;
            break
          case 'LineString':
          case 'MultiPoint':
            for (j = 0; j < coords.length; j++) {
              if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
              coordIndex++;
              if (geomType === 'MultiPoint') multiFeatureIndex++;
            }
            if (geomType === 'LineString') multiFeatureIndex++;
            break
          case 'Polygon':
          case 'MultiLineString':
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length - wrapShrink; k++) {
                if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
                coordIndex++;
              }
              if (geomType === 'MultiLineString') multiFeatureIndex++;
              if (geomType === 'Polygon') geometryIndex++;
            }
            if (geomType === 'Polygon') multiFeatureIndex++;
            break
          case 'MultiPolygon':
            for (j = 0; j < coords.length; j++) {
              geometryIndex = 0;
              for (k = 0; k < coords[j].length; k++) {
                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                  if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break
          case 'GeometryCollection':
            for (j = 0; j < geometry.geometries.length; j++) { if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false }
            break
          default:
            throw new Error('Unknown Geometry Type')
        }
      }
    }
  }

  function transformGeometries (geometries, transformFunc) {
    const geometriesClone = JSON.parse(JSON.stringify(geometries));

    if (geometriesClone.constructor === Array) {
      for (let i = 0; i < geometriesClone.length; i++) {
        transformGeometryInplace(geometriesClone[i], transformFunc);
      }
    }

    if (geometriesClone.constructor === Object) {
      for (const key in geometriesClone) {
        transformGeometryInplace(geometriesClone[key], transformFunc);
      }
    }

    return geometriesClone
  }

  function transformGeometryInplace (geometry, transformFunc) {
    coordEach(geometry, coord => {
      const transformedPosition = transformFunc(coord);
      coord[0] = transformedPosition[0];
      coord[1] = transformedPosition[1];
    });
  }

  function reproject (data, transformation) {
    if (!('$geometry' in data)) {
      warn('No geometry column found. Skipping reproject-transformation.');
      return data
    }

    const transformedGeometries = transformGeometries(data.$geometry, transformation);
    data.$geometry = transformedGeometries;

    return data
  }

  function transform (data, transformFunction) {
    if (transformFunction.constructor !== Function) {
      throw new Error(`Invalid 'transform' transformation: must be a Function`)
    }

    transformFunction(data);
  }

  function cumsum (data, cumsumInstructions, options = { asInterval: false }) {
    const asInterval = options.asInterval;
    const length = getDataLength(data);
    const newColumns = {};

    for (const newColName in cumsumInstructions) {
      checkRegularColumnName(newColName);

      const oldColName = cumsumInstructions[newColName];

      if (getColumnType(data[oldColName]) !== 'quantitative') {
        throw new Error('cumsum columns can only be of type \'quantitative\'')
      }

      let previousSum = 0;
      let currentSum = 0;
      newColumns[newColName] = [];

      for (let i = 0; i < length; i++) {
        const value = data[oldColName][i];

        if (!isInvalid(value)) {
          currentSum += value;
        }

        if (asInterval) {
          newColumns[newColName].push([previousSum, currentSum]);
        } else {
          newColumns[newColName].push(currentSum);
        }

        previousSum = currentSum;
      }
    }

    Object.assign(data, newColumns);
  }

  function rowCumsum (data, _cumsumInstructions, options = { asInterval: false }) {
    const asInterval = options.asInterval;
    const cumsumInstructions = parseCumsumInstructions(_cumsumInstructions);
    validateColumns(data, cumsumInstructions);

    const rowCumsumColumns = {};
    let previousColumnName;

    for (const [newName, oldName] of cumsumInstructions) {
      checkRegularColumnName(newName);
      const oldColumn = data[oldName];

      if (previousColumnName === undefined) {
        if (asInterval) {
          rowCumsumColumns[newName] = oldColumn.map(value => [0, value]);
        } else {
          rowCumsumColumns[newName] = oldColumn;
        }
      } else {
        const previousColumn = rowCumsumColumns[previousColumnName];
        let newColumn;

        if (asInterval) {
          newColumn = oldColumn.map((value, i) => {
            const previousValue = previousColumn[i][1];
            const newValue = previousValue + value;
            return [previousValue, newValue]
          });
        } else {
          newColumn = oldColumn.map((value, i) => value + previousColumn[i]);
        }

        rowCumsumColumns[newName] = newColumn;
      }

      previousColumnName = newName;
    }

    Object.assign(data, rowCumsumColumns);
  }

  const invalidInstructionsError = new Error('Invalid rowCumsum instrutions');

  function parseCumsumInstructions (cumsumInstructions) {
    if (cumsumInstructions && cumsumInstructions.constructor === Array) {
      const parsedInstructions = [];

      for (const instruction of cumsumInstructions) {
        validateInstruction(instruction);

        if (instruction.constructor === String) {
          parsedInstructions.push([instruction, instruction]);
        }

        if (instruction.constructor === Object) {
          const newName = Object.keys(instruction)[0];
          const oldName = instruction[newName];
          parsedInstructions.push([newName, oldName]);
        }
      }

      return parsedInstructions
    }

    throw invalidInstructionsError
  }

  function validateInstruction (instruction) {
    if (instruction.constructor === String) return

    if (instruction.constructor === Object) {
      if (Object.keys(instruction).length === 1) return
    }

    throw invalidInstructionsError
  }

  function validateColumns (data, stackInstructions) {
    for (const [, oldName] of stackInstructions) {
      const column = data[oldName];

      if (!column) {
        throw new Error(`Column '${oldName}' does not exist`)
      }

      const columnType = getColumnType(column);

      if (columnType !== 'quantitative') {
        throw new Error('rowCumsum columns can only be of type \'quantitative\'')
      }
    }
  }

  const transformations = {
    filter,
    select: produce(select),
    arrange: produce(arrange),
    rename: produce(rename),
    mutate: produce(mutate),
    transmute: produce(transmute),
    summarise,
    mutarise,
    groupBy,
    bin,
    dropNA,
    reproject: produce(reproject),
    transform: produce(transform),
    cumsum: produce(cumsum),
    rowCumsum: produce(rowCumsum)
  };

  const methods$1 = {
    arrange (sortInstructions) {
      const data = transformations.arrange(this._data, sortInstructions);
      return new DataContainer(data, { validate: false })
    },

    bin (binInstructions) {
      const data = transformations.bin(this._data, binInstructions);
      return new DataContainer(data, { validate: false })
    },

    cumsum (cumsumInstructions, options) {
      const data = transformations.cumsum(this._data, cumsumInstructions, options);
      return new DataContainer(data, { validate: false })
    },

    dropNA (dropInstructions) {
      const data = transformations.dropNA(this._data, dropInstructions);
      return new DataContainer(data, { validate: false })
    },

    filter (filterFunction) {
      const data = transformations.filter(this._data, filterFunction);
      return new DataContainer(data, { validate: false })
    },

    groupBy (groupByInstructions) {
      const data = transformations.groupBy(this._data, groupByInstructions);
      return new DataContainer(data, { validate: false })
    },

    mutarise (mutariseInstructions) {
      const data = transformations.mutarise(this._data, mutariseInstructions);
      return new DataContainer(data, { validate: false })
    },

    mutarize (mutariseInstructions) {
      const data = transformations.mutarise(this._data, mutariseInstructions);
      return new DataContainer(data, { validate: false })
    },

    mutate (mutateInstructions) {
      const data = transformations.mutate(this._data, mutateInstructions);
      return new DataContainer(data, { validate: false })
    },

    transmute (transmuteInstructions) {
      const data = transformations.transmute(this._data, transmuteInstructions);
      return new DataContainer(data, { validate: false })
    },

    rename (renameInstructions) {
      const data = transformations.rename(this._data, renameInstructions);
      return new DataContainer(data, { validate: false })
    },

    reproject (reprojectInstructions) {
      const data = transformations.reproject(this._data, reprojectInstructions);
      return new DataContainer(data, { validate: false })
    },

    rowCumsum (cumsumInstructions, options) {
      const data = transformations.rowCumsum(this._data, cumsumInstructions, options);
      return new DataContainer(data, { validate: false })
    },

    select (selection) {
      const data = transformations.select(this._data, selection);
      return new DataContainer(data, { validate: false })
    },

    summarise (summariseInstructions) {
      const data = transformations.summarise(this._data, summariseInstructions);
      return new DataContainer(data, { validate: false })
    },

    summarize (summariseInstructions) {
      const data = transformations.summarise(this._data, summariseInstructions);
      return new DataContainer(data, { validate: false })
    },

    transform (transformFunction) {
      const data = transformations.transform(this._data, transformFunction);
      return new DataContainer(data, { validate: false })
    }
  };

  function transformationsMixin (targetClass) {
    Object.assign(targetClass.prototype, methods$1);
  }

  function ensureValidRow (row, self) {
    for (const columnName in row) {
      if (!(columnName in self._data)) throw new Error(`Column '${columnName}' not found`)
    }

    for (const columnName in self._data) {
      if (columnName === '$key') {
        if (columnName in row) throw new Error('Cannot set \'$key\' column')
      } else {
        if (!(columnName in row)) throw new Error(`Missing column '${columnName}'`)

        const value = row[columnName];
        ensureValueIsRightForColumn(value, columnName, self);
      }
    }
  }

  function ensureValidRowUpdate (row, self) {
    for (const columnName in row) {
      if (!(columnName in self._data)) throw new Error(`Column '${columnName}' not found`)

      const value = row[columnName];
      ensureValueIsRightForColumn(value, columnName, self);
    }
  }

  function ensureRowExists (key, self) {
    if (isUndefined(self._keyToRowNumber[key])) {
      throw new Error(`Key '${key}' not found`)
    }
  }

  function ensureValueIsRightForColumn (value, columnName, self) {
    if (!isInvalid(value)) {
      const columnType = getColumnType(self._data[columnName]);

      ensureValidDataType(value);
      const valueType = getDataType(value);

      if (columnType !== valueType) {
        throw new Error(`Column '${columnName}' is of type '${columnType}'. Received value of type '${valueType}'`)
      }
    }
  }

  function isValidColumn (column, columnName) {
    const columnType = getColumnType(column);

    if (columnType === undefined) return false
    if (!columnNameMatchesType(columnName, columnType)) return false
    if (!allValidValuesHaveTheSameType(column, columnType)) return false

    return true
  }

  function ensureValidColumn (column, columnName) {
    const { nValidValues } = findFirstValidValue(column);

    if (nValidValues === 0) {
      throw new Error(`Invalid column '${columnName}'. Column contains only invalid values.`)
    }

    const columnType = getColumnType(column);

    if (columnType === undefined) throw new Error(`Column '${columnName}' contains data of unknown type`)
    ensureColumnNameMatchesType(columnType);
    ensureAllValidValuesHaveTheSameType(column, columnType, columnName);
  }

  function columnNameMatchesType (columnName, columnType) {
    if (columnName === '$geometry' && columnType !== 'geometry') return false
    if (columnName !== '$geometry' && columnType === 'geometry') return false

    return true
  }

  function ensureColumnNameMatchesType (columnName, columnType) {
    if (columnName === '$geometry' && columnType !== 'geometry') {
      throw new Error(`Column '$geometry' can only contain data of type 'geometry', received '${columnType}'`)
    }

    if (columnName !== '$geometry' && columnType === 'geometry') {
      throw new Error(`Only the '$geometry' column can contain data of type 'geometry'`)
    }
  }

  function allValidValuesHaveTheSameType (column, columnType) {
    for (let i = 0; i < column.length; i++) {
      const value = column[i];

      if (isInvalid(value)) continue

      const valueType = getDataType(value);

      if (valueType !== columnType) {
        return false
      }
    }

    return true
  }

  function ensureAllValidValuesHaveTheSameType (column, columnType, columnName) {
    if (!allValidValuesHaveTheSameType(column, columnType)) {
      throw new Error(`Column '${columnName}' mixes types`)
    }
  }

  function columnExists (columnName, self) {
    return columnName in self._data
  }

  function ensureColumnExists (columnName, self) {
    if (!columnExists(columnName, self)) {
      throw new Error(`Invalid column name: '${columnName}'`)
    }
  }

  const methods$2 = {
    // Rows
    addRow (row) {
      ensureValidRow(row, this);
      const self = this;

      this._data = produce(this._data, draft => {
        for (const columnName in row) {
          const value = row[columnName];
          draft[columnName].push(value);

          self._updateDomainIfNecessary(columnName, value);
        }
      });

      const rowNumber = getDataLength(this._data) - 1;
      const keyDomain = this.domain('$key');
      keyDomain[1]++;
      const key = keyDomain[1];

      this._data = produce(this._data, draft => {
        draft.$key.push(key);
      });

      this._keyToRowNumber[key] = rowNumber;
    },

    updateRow (key, row) {
      if (row.constructor === Function) {
        const result = row(this.row(key));

        if (!(result && result.constructor === Object)) {
          throw new Error('updateRow function must return Object')
        }

        this.updateRow(key, result);
      }

      ensureRowExists(key, this);
      ensureValidRowUpdate(row, this);
      const self = this;
      const rowNumber = this._keyToRowNumber[key];

      this._data = produce(this._data, draft => {
        for (const columnName in row) {
          throwErrorIfColumnIsKey(columnName);

          const value = row[columnName];
          draft[columnName][rowNumber] = value;

          self._resetDomainIfNecessary(columnName);
        }
      });
    },

    deleteRow (key) {
      ensureRowExists(key, this);
      const self = this;
      const rowNumber = this._keyToRowNumber[key];
      delete this._keyToRowNumber[key];

      this._data = produce(this._data, draft => {
        for (const columnName in draft) {
          draft[columnName].splice(rowNumber, 1);
          self._resetDomainIfNecessary(columnName);
        }
      });
    },

    // Columns
    addColumn (columnName, column) {
      this._validateNewColumn(columnName, column);

      this._data = produce(this._data, draft => {
        draft[columnName] = column;
      });
    },

    replaceColumn (columnName, column) {
      this.deleteColumn(columnName);
      this.addColumn(columnName, column);
    },

    deleteColumn (columnName) {
      ensureColumnExists(columnName, this);
      throwErrorIfColumnIsKey(columnName);

      if (Object.keys(this._data).length === 2) {
        throw new Error('Cannot delete last column')
      }

      this._data = produce(this._data, draft => {
        delete draft[columnName];
      });
    },

    // Private methods
    _updateDomainIfNecessary (columnName, value) {
      const type = getDataType(value);

      if (columnName in this._domains) {
        this._domains[columnName] = updateDomain(
          this._domains[columnName],
          value,
          type
        );
      }
    },

    _resetDomainIfNecessary (columnName) {
      if (columnName in this._domains) {
        delete this._domains[columnName];
      }
    },

    _validateNewColumn (columnName, column) {
      checkRegularColumnName(columnName);

      if (columnName in this._data) {
        throw new Error(`Column '${columnName}' already exists`)
      }

      const dataLength = getDataLength(this._data);
      if (dataLength !== column.length) {
        throw new Error('Column must be of same length as rest of data')
      }

      ensureValidColumn(column);
    }
  };

  function modifyingRowsAndColumnsMixin (targetClass) {
    Object.assign(targetClass.prototype, methods$2);
  }

  function throwErrorIfColumnIsKey (columnName) {
    if (columnName === '$key') throw new Error('Cannot modify key column')
  }

  function getJoinColumns (left, right, by) {
    const leftData = left.data();
    const rightData = right.data();

    if (isUndefined(by)) {
      const leftDataLength = getDataLength(leftData);
      const joinColumns = {};

      for (const columnName in rightData) {
        if (columnName !== '$key') {
          const rightColumn = rightData[columnName];
          joinColumns[columnName] = rightColumn.slice(0, leftDataLength);
        }
      }

      return joinColumns
    }

    if (isDefined(by)) {
      const joinColumns = initJoinColumns(rightData, by[1]);

      const rightRowsByKey = generateRightRowsByKey(rightData, by[1]);
      const leftByColumn = leftData[by[0]];

      for (let i = 0; i < leftByColumn.length; i++) {
        const leftKey = leftByColumn[i];
        const row = rightRowsByKey[leftKey];

        for (const columnName in row) {
          joinColumns[columnName].push(row[columnName]);
        }
      }

      return joinColumns
    }
  }

  function initJoinColumns (right, byColumnName) {
    const joinColumns = {};

    for (const columnName in right) {
      if (columnName !== '$key' && columnName !== byColumnName) {
        joinColumns[columnName] = [];
      }
    }

    return joinColumns
  }

  function generateRightRowsByKey (right, byColumnName) {
    const rightRowsByKey = {};
    const byColumn = right[byColumnName];

    for (let i = 0; i < byColumn.length; i++) {
      const key = byColumn[i];
      const row = {};

      for (const columnName in right) {
        if (columnName !== '$key' && columnName !== byColumnName) {
          row[columnName] = right[columnName][i];
        }
      }

      rightRowsByKey[key] = row;
    }

    return rightRowsByKey
  }

  function validateJoin (left, right, by) {
    const leftData = left.data();
    const rightData = getRightData(right);

    if (isUndefined(by)) {
      const leftLength = getDataLength(leftData);
      const rightLength = getDataLength(rightData);

      if (rightLength < leftLength) {
        throw new Error(
          'Without \'by\', the right DataContainer must be the same length as or longer than left DataContainer'
        )
      }
    }

    if (isDefined(by)) {
      validateByColumnsExist(leftData, rightData, by);
      ensureColumnsAreCompatible(leftData, rightData, by);
      ensureNoDuplicateColumnNames(leftData, rightData, by);
    }
  }

  function getRightData (right) {
    if (!(right instanceof DataContainer)) {
      throw new Error('It is only possible to join another DataContainer')
    }

    return right.data()
  }

  function validateByColumnsExist (left, right, by) {
    if (!(by.constructor === Array && by.length === 2 && by.every(c => c.constructor === String))) {
      throw new Error('Invalid format of \'by\'. Must be Array of two column names.')
    }

    const [leftColumnName, rightColumnName] = by;

    if (!(leftColumnName in left)) {
      throw new Error(`Column '${leftColumnName}' not found`)
    }

    if (!(rightColumnName in right)) {
      throw new Error(`Column '${rightColumnName}' not found`)
    }
  }

  function ensureColumnsAreCompatible (left, right, by) {
    const [leftColumnName, rightColumnName] = by;
    const leftColumn = left[leftColumnName];
    const rightColumn = right[rightColumnName];

    const leftType = getColumnType(leftColumn);
    const rightType = getColumnType(rightColumn);

    if (leftType !== rightType) throw new Error('\'by\' columns must be of the same type')

    ensureRightByColumnIsUnique(right[rightColumnName]);
    ensureLeftColumnIsSubsetOfRightColumn(leftColumn, rightColumn);
  }

  function ensureRightByColumnIsUnique (column) {
    if (column.length !== new Set(column).size) {
      throw new Error('Right \'by\' column must contain only unique values')
    }
  }

  function ensureLeftColumnIsSubsetOfRightColumn (leftColumn, rightColumn) {
    const rightSet = new Set(rightColumn);

    for (let i = 0; i < leftColumn.length; i++) {
      const leftKey = leftColumn[i];
      if (!rightSet.has(leftKey)) {
        throw new Error('Left \'by\' column must be subset of right column')
      }
    }
  }

  function ensureNoDuplicateColumnNames (left, right, by) {
    const rightColumnName = by[1];

    for (const columnName in right) {
      if (columnName !== '$key' && columnName in left) {
        if (columnName !== rightColumnName) {
          throw new Error(`Duplicate column name: '${columnName}'`)
        }
      }
    }
  }

  class DataContainer {
    constructor (data, options = { validate: true }) {
      this._data = {};
      this._keyToRowNumber = {};
      this._domains = {};

      if (isColumnOriented(data)) {
        this._setColumnData(data, options);
        return
      }

      if (isRowOriented(data)) {
        this._setRowData(data, options);
        return
      }

      if (isGeoJSON(data)) {
        this._setGeoJSON(data, options);
        return
      }

      if (data instanceof Group) {
        this._setGroup(data, options);
        return
      }

      throw invalidDataError
    }

    // Accessing data
    data () {
      return this._data
    }

    row (key) {
      const rowNumber = this._keyToRowNumber[key];
      return this._row(rowNumber)
    }

    prevRow (key) {
      const rowNumber = this._keyToRowNumber[key];
      const previousRowNumber = rowNumber - 1;
      return this._row(previousRowNumber)
    }

    nextRow (key) {
      const rowNumber = this._keyToRowNumber[key];
      const nextRowNumber = rowNumber + 1;
      return this._row(nextRowNumber)
    }

    rows () {
      const rows = [];
      const length = getDataLength(this._data);

      for (let i = 0; i < length; i++) {
        rows.push(this._row(i));
      }

      return rows
    }

    column (columnName) {
      ensureColumnExists(columnName, this);
      return this._data[columnName]
    }

    map (columnName, mapFunction) {
      return this.column(columnName).map(mapFunction)
    }

    domain (columnName) {
      if (columnName in this._domains) {
        return this._domains[columnName]
      }

      const column = this.column(columnName);
      const domain = calculateDomain(column, columnName);
      this._domains[columnName] = domain;
      return domain
    }

    type (columnName) {
      const column = this.column(columnName);
      return getColumnType(column)
    }

    columnNames () {
      return Object.keys(this._data)
    }

    // Checks
    hasColumn (columnName) {
      return columnExists(columnName, this)
    }

    columnIsValid (columnName) {
      const column = this.column(columnName);
      return isValidColumn(column, columnName)
    }

    validateColumn (columnName) {
      const column = this.column(columnName);
      ensureValidColumn(column, columnName);
    }

    validateAllColumns () {
      for (const columnName in this._data) {
        this.validateColumn(columnName);
      }
    }

    // Join
    join (dataContainer, { by = undefined } = {}) {
      validateJoin(this, dataContainer, by);
      const joinColumns = getJoinColumns(this, dataContainer, by);

      for (const columnName in joinColumns) {
        this.addColumn(columnName, joinColumns[columnName]);
      }
    }

    // Private methods
    _row (rowNumber) {
      const length = getDataLength(this._data);

      if (rowNumber < 0 || rowNumber >= length) {
        return undefined
      }

      const row = {};

      for (const columnName in this._data) {
        const value = this._data[columnName][rowNumber];
        row[columnName] = value;
      }

      return row
    }
  }

  dataLoadingMixin(DataContainer);
  transformationsMixin(DataContainer);
  modifyingRowsAndColumnsMixin(DataContainer);

  const invalidDataError = new Error('Data passed to DataContainer is of unknown format');

  return DataContainer;

})));
