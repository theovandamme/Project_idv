(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.ducebox = {}));
}(this, (function (exports) { 'use strict';

  function _dispatchableCompareFn (fn) {
    return function (column) {
      const getValue = column.constructor === Function
        ? column
        : row => row[column];

      return function (rowA, rowB) {
        return fn(getValue(rowA), getValue(rowB))
      }
    }
  }

  const ascending = _dispatchableCompareFn(
    (a, b) => a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN
  );

  const ascendingStr = _dispatchableCompareFn((a, b) => {
    if (a === b) return 0

    const sorted = [a, b].sort();
    return sorted[0] === a ? -1 : 1
  });

  const descending = _dispatchableCompareFn(
    (a, b) => b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN
  );

  const ascendingStr$1 = _dispatchableCompareFn((a, b) => {
    if (a === b) return 0

    const sorted = [a, b].sort();
    return sorted[0] === a ? 1 : -1
  });

  function _isPlaceholder(a) {
    return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
  }

  /**
   * Optimized internal one-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  /**
   * Optimized internal two-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;

        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
            return fn(a, _b);
          });

        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }

  function _arity(n, fn) {
    /* eslint-disable no-unused-vars */
    switch (n) {
      case 0:
        return function () {
          return fn.apply(this, arguments);
        };

      case 1:
        return function (a0) {
          return fn.apply(this, arguments);
        };

      case 2:
        return function (a0, a1) {
          return fn.apply(this, arguments);
        };

      case 3:
        return function (a0, a1, a2) {
          return fn.apply(this, arguments);
        };

      case 4:
        return function (a0, a1, a2, a3) {
          return fn.apply(this, arguments);
        };

      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.apply(this, arguments);
        };

      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.apply(this, arguments);
        };

      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.apply(this, arguments);
        };

      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.apply(this, arguments);
        };

      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.apply(this, arguments);
        };

      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.apply(this, arguments);
        };

      default:
        throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
    }
  }

  /**
   * Internal curryN function.
   *
   * @private
   * @category Function
   * @param {Number} length The arity of the curried function.
   * @param {Array} received An array of arguments received thus far.
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curryN(length, received, fn) {
    return function () {
      var combined = [];
      var argsIdx = 0;
      var left = length;
      var combinedIdx = 0;

      while (combinedIdx < received.length || argsIdx < arguments.length) {
        var result;

        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
          result = received[combinedIdx];
        } else {
          result = arguments[argsIdx];
          argsIdx += 1;
        }

        combined[combinedIdx] = result;

        if (!_isPlaceholder(result)) {
          left -= 1;
        }

        combinedIdx += 1;
      }

      return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
    };
  }

  /**
   * Returns a curried equivalent of the provided function, with the specified
   * arity. The curried function has two unusual capabilities. First, its
   * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.5.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curry
   * @example
   *
   *      const sumArgs = (...args) => R.sum(args);
   *
   *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
   *      const f = curriedAddFourNumbers(1, 2);
   *      const g = f(3);
   *      g(4); //=> 10
   */

  var curryN =
  /*#__PURE__*/
  _curry2(function curryN(length, fn) {
    if (length === 1) {
      return _curry1(fn);
    }

    return _arity(length, _curryN(length, [], fn));
  });

  /**
   * Optimized internal three-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curry3(fn) {
    return function f3(a, b, c) {
      switch (arguments.length) {
        case 0:
          return f3;

        case 1:
          return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          });

        case 2:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _curry1(function (_c) {
            return fn(a, b, _c);
          });

        default:
          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
            return fn(_a, _b, c);
          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b, c);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b, c);
          }) : _isPlaceholder(c) ? _curry1(function (_c) {
            return fn(a, b, _c);
          }) : fn(a, b, c);
      }
    };
  }

  /**
   * Tests whether or not an object is an array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is an array, `false` otherwise.
   * @example
   *
   *      _isArray([]); //=> true
   *      _isArray(null); //=> false
   *      _isArray({}); //=> false
   */
  var _isArray = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
  };

  function _isTransformer(obj) {
    return obj != null && typeof obj['@@transducer/step'] === 'function';
  }

  /**
   * Returns a function that dispatches with different strategies based on the
   * object in list position (last argument). If it is an array, executes [fn].
   * Otherwise, if it has a function with one of the given method names, it will
   * execute that function (functor case). Otherwise, if it is a transformer,
   * uses transducer [xf] to return a new transformer (transducer case).
   * Otherwise, it will default to executing [fn].
   *
   * @private
   * @param {Array} methodNames properties to check for a custom implementation
   * @param {Function} xf transducer to initialize if object is transformer
   * @param {Function} fn default ramda implementation
   * @return {Function} A function that dispatches on object in list position
   */

  function _dispatchable(methodNames, xf, fn) {
    return function () {
      if (arguments.length === 0) {
        return fn();
      }

      var args = Array.prototype.slice.call(arguments, 0);
      var obj = args.pop();

      if (!_isArray(obj)) {
        var idx = 0;

        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === 'function') {
            return obj[methodNames[idx]].apply(obj, args);
          }

          idx += 1;
        }

        if (_isTransformer(obj)) {
          var transducer = xf.apply(null, args);
          return transducer(obj);
        }
      }

      return fn.apply(this, arguments);
    };
  }

  var _xfBase = {
    init: function () {
      return this.xf['@@transducer/init']();
    },
    result: function (result) {
      return this.xf['@@transducer/result'](result);
    }
  };

  function _map(fn, functor) {
    var idx = 0;
    var len = functor.length;
    var result = Array(len);

    while (idx < len) {
      result[idx] = fn(functor[idx]);
      idx += 1;
    }

    return result;
  }

  function _isString(x) {
    return Object.prototype.toString.call(x) === '[object String]';
  }

  /**
   * Tests whether or not an object is similar to an array.
   *
   * @private
   * @category Type
   * @category List
   * @sig * -> Boolean
   * @param {*} x The object to test.
   * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
   * @example
   *
   *      _isArrayLike([]); //=> true
   *      _isArrayLike(true); //=> false
   *      _isArrayLike({}); //=> false
   *      _isArrayLike({length: 10}); //=> false
   *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
   */

  var _isArrayLike =
  /*#__PURE__*/
  _curry1(function isArrayLike(x) {
    if (_isArray(x)) {
      return true;
    }

    if (!x) {
      return false;
    }

    if (typeof x !== 'object') {
      return false;
    }

    if (_isString(x)) {
      return false;
    }

    if (x.nodeType === 1) {
      return !!x.length;
    }

    if (x.length === 0) {
      return true;
    }

    if (x.length > 0) {
      return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
    }

    return false;
  });

  var XWrap =
  /*#__PURE__*/
  function () {
    function XWrap(fn) {
      this.f = fn;
    }

    XWrap.prototype['@@transducer/init'] = function () {
      throw new Error('init not implemented on XWrap');
    };

    XWrap.prototype['@@transducer/result'] = function (acc) {
      return acc;
    };

    XWrap.prototype['@@transducer/step'] = function (acc, x) {
      return this.f(acc, x);
    };

    return XWrap;
  }();

  function _xwrap(fn) {
    return new XWrap(fn);
  }

  /**
   * Creates a function that is bound to a context.
   * Note: `R.bind` does not provide the additional argument-binding capabilities of
   * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @category Object
   * @sig (* -> *) -> {*} -> (* -> *)
   * @param {Function} fn The function to bind to context
   * @param {Object} thisObj The context to bind `fn` to
   * @return {Function} A function that will execute in the context of `thisObj`.
   * @see R.partial
   * @example
   *
   *      const log = R.bind(console.log, console);
   *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
   *      // logs {a: 2}
   * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
   */

  var bind =
  /*#__PURE__*/
  _curry2(function bind(fn, thisObj) {
    return _arity(fn.length, function () {
      return fn.apply(thisObj, arguments);
    });
  });

  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      idx += 1;
    }

    return xf['@@transducer/result'](acc);
  }

  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();

    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      step = iter.next();
    }

    return xf['@@transducer/result'](acc);
  }

  function _methodReduce(xf, acc, obj, methodName) {
    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
  }

  var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
  function _reduce(fn, acc, list) {
    if (typeof fn === 'function') {
      fn = _xwrap(fn);
    }

    if (_isArrayLike(list)) {
      return _arrayReduce(fn, acc, list);
    }

    if (typeof list['fantasy-land/reduce'] === 'function') {
      return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
    }

    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }

    if (typeof list.next === 'function') {
      return _iterableReduce(fn, acc, list);
    }

    if (typeof list.reduce === 'function') {
      return _methodReduce(fn, acc, list, 'reduce');
    }

    throw new TypeError('reduce: list must be array or iterable');
  }

  var XMap =
  /*#__PURE__*/
  function () {
    function XMap(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XMap.prototype['@@transducer/init'] = _xfBase.init;
    XMap.prototype['@@transducer/result'] = _xfBase.result;

    XMap.prototype['@@transducer/step'] = function (result, input) {
      return this.xf['@@transducer/step'](result, this.f(input));
    };

    return XMap;
  }();

  var _xmap =
  /*#__PURE__*/
  _curry2(function _xmap(f, xf) {
    return new XMap(f, xf);
  });

  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var toString = Object.prototype.toString;

  var _isArguments =
  /*#__PURE__*/
  function () {
    return toString.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
      return toString.call(x) === '[object Arguments]';
    } : function _isArguments(x) {
      return _has('callee', x);
    };
  }();

  var hasEnumBug = !
  /*#__PURE__*/
  {
    toString: null
  }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

  var hasArgsEnumBug =
  /*#__PURE__*/
  function () {

    return arguments.propertyIsEnumerable('length');
  }();

  var contains = function contains(list, item) {
    var idx = 0;

    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }

      idx += 1;
    }

    return false;
  };
  /**
   * Returns a list containing the names of all the enumerable own properties of
   * the supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own properties.
   * @see R.keysIn, R.values
   * @example
   *
   *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
   */


  var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?
  /*#__PURE__*/
  _curry1(function keys(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) :
  /*#__PURE__*/
  _curry1(function keys(obj) {
    if (Object(obj) !== obj) {
      return [];
    }

    var prop, nIdx;
    var ks = [];

    var checkArgsLength = hasArgsEnumBug && _isArguments(obj);

    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
        ks[ks.length] = prop;
      }
    }

    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;

      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];

        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }

        nIdx -= 1;
      }
    }

    return ks;
  });

  /**
   * Takes a function and
   * a [functor](https://github.com/fantasyland/fantasy-land#functor),
   * applies the function to each of the functor's values, and returns
   * a functor of the same shape.
   *
   * Ramda provides suitable `map` implementations for `Array` and `Object`,
   * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
   *
   * Dispatches to the `map` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * Also treats functions as functors and will compose them together.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => (a -> b) -> f a -> f b
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {Array} list The list to be iterated over.
   * @return {Array} The new list.
   * @see R.transduce, R.addIndex
   * @example
   *
   *      const double = x => x * 2;
   *
   *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
   *
   *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
   * @symb R.map(f, [a, b]) = [f(a), f(b)]
   * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
   * @symb R.map(f, functor_o) = functor_o.map(f)
   */

  var map =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case '[object Function]':
        return curryN(functor.length, function () {
          return fn.call(this, functor.apply(this, arguments));
        });

      case '[object Object]':
        return _reduce(function (acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys(functor));

      default:
        return _map(fn, functor);
    }
  }));

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It may use
   * [`R.reduced`](#reduced) to shortcut the iteration.
   *
   * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
   * is *(value, acc)*.
   *
   * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduce` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
   *
   * Dispatches to the `reduce` method of the third argument, if present. When
   * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
   * shortcuting, as this is not implemented by `reduce`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduced, R.addIndex, R.reduceRight
   * @example
   *
   *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
   *      //          -               -10
   *      //         / \              / \
   *      //        -   4           -6   4
   *      //       / \              / \
   *      //      -   3   ==>     -3   3
   *      //     / \              / \
   *      //    -   2           -1   2
   *      //   / \              / \
   *      //  0   1            0   1
   *
   * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
   */

  var reduce =
  /*#__PURE__*/
  _curry3(_reduce);

  function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
  }

  /**
   * Gives a single-word string description of the (native) type of a value,
   * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
   * attempt to distinguish user Object types any further, reporting them all as
   * 'Object'.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Type
   * @sig (* -> {*}) -> String
   * @param {*} val The value to test
   * @return {String}
   * @example
   *
   *      R.type({}); //=> "Object"
   *      R.type(1); //=> "Number"
   *      R.type(false); //=> "Boolean"
   *      R.type('s'); //=> "String"
   *      R.type(null); //=> "Null"
   *      R.type([]); //=> "Array"
   *      R.type(/[A-z]/); //=> "RegExp"
   *      R.type(() => {}); //=> "Function"
   *      R.type(undefined); //=> "Undefined"
   */

  var type =
  /*#__PURE__*/
  _curry1(function type(val) {
    return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
  });

  /**
   * Copies an object.
   *
   * @private
   * @param {*} value The value to be copied
   * @param {Array} refFrom Array containing the source references
   * @param {Array} refTo Array containing the copied source references
   * @param {Boolean} deep Whether or not to perform deep cloning.
   * @return {*} The copied value.
   */

  function _clone(value, refFrom, refTo, deep) {
    var copy = function copy(copiedValue) {
      var len = refFrom.length;
      var idx = 0;

      while (idx < len) {
        if (value === refFrom[idx]) {
          return refTo[idx];
        }

        idx += 1;
      }

      refFrom[idx + 1] = value;
      refTo[idx + 1] = copiedValue;

      for (var key in value) {
        copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
      }

      return copiedValue;
    };

    switch (type(value)) {
      case 'Object':
        return copy({});

      case 'Array':
        return copy([]);

      case 'Date':
        return new Date(value.valueOf());

      case 'RegExp':
        return _cloneRegExp(value);

      default:
        return value;
    }
  }

  function _pipe(f, g) {
    return function () {
      return g.call(this, f.apply(this, arguments));
    };
  }

  /**
   * This checks whether a function has a [methodname] function. If it isn't an
   * array it will execute that function otherwise it will default to the ramda
   * implementation.
   *
   * @private
   * @param {Function} fn ramda implemtation
   * @param {String} methodname property to check for a custom implementation
   * @return {Object} Whatever the return value of the method is.
   */

  function _checkForMethod(methodname, fn) {
    return function () {
      var length = arguments.length;

      if (length === 0) {
        return fn();
      }

      var obj = arguments[length - 1];
      return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
    };
  }

  /**
   * Returns the elements of the given list or string (or object with a `slice`
   * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
   *
   * Dispatches to the `slice` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @sig Number -> Number -> String -> String
   * @param {Number} fromIndex The start index (inclusive).
   * @param {Number} toIndex The end index (exclusive).
   * @param {*} list
   * @return {*}
   * @example
   *
   *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
   *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
   *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
   *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
   *      R.slice(0, 3, 'ramda');                     //=> 'ram'
   */

  var slice =
  /*#__PURE__*/
  _curry3(
  /*#__PURE__*/
  _checkForMethod('slice', function slice(fromIndex, toIndex, list) {
    return Array.prototype.slice.call(list, fromIndex, toIndex);
  }));

  /**
   * Returns all but the first element of the given list or string (or object
   * with a `tail` method).
   *
   * Dispatches to the `slice` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.head, R.init, R.last
   * @example
   *
   *      R.tail([1, 2, 3]);  //=> [2, 3]
   *      R.tail([1, 2]);     //=> [2]
   *      R.tail([1]);        //=> []
   *      R.tail([]);         //=> []
   *
   *      R.tail('abc');  //=> 'bc'
   *      R.tail('ab');   //=> 'b'
   *      R.tail('a');    //=> ''
   *      R.tail('');     //=> ''
   */

  var tail =
  /*#__PURE__*/
  _curry1(
  /*#__PURE__*/
  _checkForMethod('tail',
  /*#__PURE__*/
  slice(1, Infinity)));

  /**
   * Performs left-to-right function composition. The first argument may have
   * any arity; the remaining arguments must be unary.
   *
   * In some libraries this function is named `sequence`.
   *
   * **Note:** The result of pipe is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
   * @param {...Function} functions
   * @return {Function}
   * @see R.compose
   * @example
   *
   *      const f = R.pipe(Math.pow, R.negate, R.inc);
   *
   *      f(3, 4); // -(3^4) + 1
   * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
   */

  function pipe() {
    if (arguments.length === 0) {
      throw new Error('pipe requires at least one argument');
    }

    return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
  }

  /**
   * Returns a new list or string with the elements or characters in reverse
   * order.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {Array|String} list
   * @return {Array|String}
   * @example
   *
   *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
   *      R.reverse([1, 2]);     //=> [2, 1]
   *      R.reverse([1]);        //=> [1]
   *      R.reverse([]);         //=> []
   *
   *      R.reverse('abc');      //=> 'cba'
   *      R.reverse('ab');       //=> 'ba'
   *      R.reverse('a');        //=> 'a'
   *      R.reverse('');         //=> ''
   */

  var reverse =
  /*#__PURE__*/
  _curry1(function reverse(list) {
    return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
  });

  /**
   * Performs right-to-left function composition. The last argument may have
   * any arity; the remaining arguments must be unary.
   *
   * **Note:** The result of compose is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
   * @param {...Function} ...functions The functions to compose
   * @return {Function}
   * @see R.pipe
   * @example
   *
   *      const classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
   *      const yellGreeting = R.compose(R.toUpper, classyGreeting);
   *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
   *
   *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
   *
   * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
   */

  function compose() {
    if (arguments.length === 0) {
      throw new Error('compose requires at least one argument');
    }

    return pipe.apply(this, reverse(arguments));
  }

  function _identity(x) {
    return x;
  }

  /**
   * A function that does nothing but return the parameter supplied to it. Good
   * as a default or placeholder function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> a
   * @param {*} x The value to return.
   * @return {*} The input value, `x`.
   * @example
   *
   *      R.identity(1); //=> 1
   *
   *      const obj = {};
   *      R.identity(obj) === obj; //=> true
   * @symb R.identity(a) = a
   */

  var identity =
  /*#__PURE__*/
  _curry1(_identity);

  function _filter(fn, list) {
    var idx = 0;
    var len = list.length;
    var result = [];

    while (idx < len) {
      if (fn(list[idx])) {
        result[result.length] = list[idx];
      }

      idx += 1;
    }

    return result;
  }

  function _isObject(x) {
    return Object.prototype.toString.call(x) === '[object Object]';
  }

  var XFilter =
  /*#__PURE__*/
  function () {
    function XFilter(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XFilter.prototype['@@transducer/init'] = _xfBase.init;
    XFilter.prototype['@@transducer/result'] = _xfBase.result;

    XFilter.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
    };

    return XFilter;
  }();

  var _xfilter =
  /*#__PURE__*/
  _curry2(function _xfilter(f, xf) {
    return new XFilter(f, xf);
  });

  /**
   * Takes a predicate and a `Filterable`, and returns a new filterable of the
   * same type containing the members of the given filterable which satisfy the
   * given predicate. Filterable objects include plain objects or any object
   * that has a filter method such as `Array`.
   *
   * Dispatches to the `filter` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array} Filterable
   * @see R.reject, R.transduce, R.addIndex
   * @example
   *
   *      const isEven = n => n % 2 === 0;
   *
   *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */

  var filter =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['filter'], _xfilter, function (pred, filterable) {
    return _isObject(filterable) ? _reduce(function (acc, key) {
      if (pred(filterable[key])) {
        acc[key] = filterable[key];
      }

      return acc;
    }, {}, keys(filterable)) : // else
    _filter(pred, filterable);
  }));

  function _objectAssign(target) {
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);
    var idx = 1;
    var length = arguments.length;

    while (idx < length) {
      var source = arguments[idx];

      if (source != null) {
        for (var nextKey in source) {
          if (_has(nextKey, source)) {
            output[nextKey] = source[nextKey];
          }
        }
      }

      idx += 1;
    }

    return output;
  }

  var _objectAssign$1 = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

  /**
   * Creates an object containing a single key:value pair.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @sig String -> a -> {String:a}
   * @param {String} key
   * @param {*} val
   * @return {Object}
   * @see R.pair
   * @example
   *
   *      const matchPhrases = R.compose(
   *        R.objOf('must'),
   *        R.map(R.objOf('match_phrase'))
   *      );
   *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
   */

  var objOf =
  /*#__PURE__*/
  _curry2(function objOf(key, val) {
    var obj = {};
    obj[key] = val;
    return obj;
  });

  var _stepCatArray = {
    '@@transducer/init': Array,
    '@@transducer/step': function (xs, x) {
      xs.push(x);
      return xs;
    },
    '@@transducer/result': _identity
  };
  var _stepCatString = {
    '@@transducer/init': String,
    '@@transducer/step': function (a, b) {
      return a + b;
    },
    '@@transducer/result': _identity
  };
  var _stepCatObject = {
    '@@transducer/init': Object,
    '@@transducer/step': function (result, input) {
      return _objectAssign$1(result, _isArrayLike(input) ? objOf(input[0], input[1]) : input);
    },
    '@@transducer/result': _identity
  };
  function _stepCat(obj) {
    if (_isTransformer(obj)) {
      return obj;
    }

    if (_isArrayLike(obj)) {
      return _stepCatArray;
    }

    if (typeof obj === 'string') {
      return _stepCatString;
    }

    if (typeof obj === 'object') {
      return _stepCatObject;
    }

    throw new Error('Cannot create transformer for ' + obj);
  }

  /**
   * Transforms the items of the list with the transducer and appends the
   * transformed items to the accumulator using an appropriate iterator function
   * based on the accumulator type.
   *
   * The accumulator can be an array, string, object or a transformer. Iterated
   * items will be appended to arrays and concatenated to strings. Objects will
   * be merged directly or 2-item arrays will be merged as key, value pairs.
   *
   * The accumulator can also be a transformer object that provides a 2-arity
   * reducing iterator function, step, 0-arity initial value function, init, and
   * 1-arity result extraction function result. The step function is used as the
   * iterator function in reduce. The result function is used to convert the
   * final accumulator into the return type and in most cases is R.identity. The
   * init function is used to provide the initial accumulator.
   *
   * The iteration is performed with [`R.reduce`](#reduce) after initializing the
   * transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig a -> (b -> b) -> [c] -> a
   * @param {*} acc The initial accumulator value.
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.transduce
   * @example
   *
   *      const numbers = [1, 2, 3, 4];
   *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
   *
   *      R.into([], transducer, numbers); //=> [2, 3]
   *
   *      const intoArray = R.into([]);
   *      intoArray(transducer, numbers); //=> [2, 3]
   */

  var into =
  /*#__PURE__*/
  _curry3(function into(acc, xf, list) {
    return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
  });

  /**
   * Initializes a transducer using supplied iterator function. Returns a single
   * item by iterating through the list, successively calling the transformed
   * iterator function and passing it an accumulator value and the current value
   * from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It will be
   * wrapped as a transformer to initialize the transducer. A transformer can be
   * passed directly in place of an iterator function. In both cases, iteration
   * may be stopped early with the [`R.reduced`](#reduced) function.
   *
   * A transducer is a function that accepts a transformer and returns a
   * transformer and can be composed directly.
   *
   * A transformer is an an object that provides a 2-arity reducing iterator
   * function, step, 0-arity initial value function, init, and 1-arity result
   * extraction function, result. The step function is used as the iterator
   * function in reduce. The result function is used to convert the final
   * accumulator into the return type and in most cases is
   * [`R.identity`](#identity). The init function can be used to provide an
   * initial accumulator, but is ignored by transduce.
   *
   * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array. Wrapped as transformer, if necessary, and used to
   *        initialize the transducer
   * @param {*} acc The initial accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.reduced, R.into
   * @example
   *
   *      const numbers = [1, 2, 3, 4];
   *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
   *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
   *
   *      const isOdd = (x) => x % 2 === 1;
   *      const firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
   *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
   */

  var transduce =
  /*#__PURE__*/
  curryN(4, function transduce(xf, fn, acc, list) {
    return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
  });

  function wrap (data) {
    const length = _getLength(data);

    return {
      reduce: function (step, acc) {
        let idx = 0;

        while (idx < length) {
          const row = {};

          for (const columnName in data) {
            row[columnName] = data[columnName][idx];
          }

          acc = step(acc, row);

          if (acc && acc['@@transducer/reduced']) {
            acc = acc['@@transducer/value'];
            break
          }

          idx += 1;
        }

        return acc
      }
    }
  }

  function accumulator () {
    return new ColumnOrientedAccumulator()
  }

  function _getLength (data) {
    return data[Object.keys(data)[0]].length
  }

  function ColumnOrientedAccumulator () {
    this.init = true;
  }

  ColumnOrientedAccumulator.prototype['@@transducer/init'] = () => ({});
  ColumnOrientedAccumulator.prototype['@@transducer/result'] = identity;
  ColumnOrientedAccumulator.prototype['@@transducer/step'] = function (acc, row) {
    if (this.init) {
      this.init = false;
      return this._initStep(acc, row)
    }

    return this._step(acc, row)
  };
  ColumnOrientedAccumulator.prototype._initStep = _initStep;
  ColumnOrientedAccumulator.prototype._step = _step;

  function _initStep (acc, row) {
    for (const columnName in row) {
      acc[columnName] = [row[columnName]];
    }

    return acc
  }

  function _step (acc, row) {
    for (const columnName in row) {
      acc[columnName].push(row[columnName]);
    }

    return acc
  }

  var columnOriented = /*#__PURE__*/Object.freeze({
    __proto__: null,
    wrap: wrap,
    accumulator: accumulator
  });

  function wrap$1 (data, geometryColumn = '@@geometry') {
    const length = _getLength$1(data);

    return {
      reduce: function (step, acc) {
        let idx = 0;

        while (idx < length) {
          const feature = data.features[idx];
          const row = feature.properties;

          row[geometryColumn] = feature.geometry;

          acc = step(acc, row);

          if (acc && acc['@@transducer/reduced']) {
            acc = acc['@@transducer/value'];
            break
          }

          idx += 1;
        }

        return acc
      }
    }
  }

  function accumulator$1 (geometryColumn = '@@geometry') {
    return new GeoJSONAccumulator(geometryColumn)
  }

  function _getLength$1 (data) {
    return data.features.length
  }

  function GeoJSONAccumulator (geometryColumn) {
    this.geometryColumn = geometryColumn;
  }

  GeoJSONAccumulator.prototype['@@transducer/init'] = _init;
  GeoJSONAccumulator.prototype['@@transducer/result'] = identity;
  GeoJSONAccumulator.prototype['@@transducer/step'] = _step$1;

  function _init () {
    return {
      type: 'FeatureCollection',
      features: []
    }
  }

  function _step$1 (acc, row) {
    const geometry = row[this.geometryColumn];
    const properties = row;
    delete properties[this.geometryColumn];

    acc.features.push({
      type: 'Feature',
      geometry,
      properties
    });

    return acc
  }

  var geojson = /*#__PURE__*/Object.freeze({
    __proto__: null,
    wrap: wrap$1,
    accumulator: accumulator$1
  });

  const REDUCABLE = Symbol('Reducable');

  function _dispatchableSummarizer (transducerCreator, fn) {
    return function (...args) {
      if (args[0] === undefined) {
        return REDUCABLE
      }

      if (args[0] && args[0].constructor === String) {
        return {
          column: args[0],
          xf: transducerCreator()
        }
      }

      return fn(...args)
    }
  }

  // Adapted from ramda: https://github.com/ramda/ramda
  var _isArray$1 = Array.isArray || function _isArray (val) {
    return (val != null &&
            val.length >= 0 &&
            Object.prototype.toString.call(val) === '[object Array]')
  };

  function _isString$1 (x) {
    return Object.prototype.toString.call(x) === '[object String]'
  }

  // Adapted from ramda: https://github.com/ramda/ramda

  const _isArrayLike$1 = curryN(1, function isArrayLike (x) {
    if (_isArray$1(x)) { return true }
    if (!x) { return false }
    if (typeof x !== 'object') { return false }
    if (_isString$1(x)) { return false }
    if (x.length === 0) { return true }
    if (x.length > 0) {
      return 0 in x && (x.length - 1) in x
    }
    return false
  });

  const init = () => 0;
  const result = identity;
  const step = acc => acc + 1;

  const _xcount = () => ({
    '@@transducer/init': init,
    '@@transducer/result': result,
    '@@transducer/step': step
  });

  const count = _dispatchableSummarizer(_xcount, function count (list) {
    return _isArrayLike$1(list)
      ? list.length
      : result(reduce(step, init(), list))
  });

  const init$1 = () => -Infinity;
  const result$1 = identity;
  const step$1 = (acc, val) => acc < val ? val : acc;

  const _xmax = () => ({
    '@@transducer/init': init$1,
    '@@transducer/result': result$1,
    '@@transducer/step': step$1
  });

  const max = _dispatchableSummarizer(_xmax, function (list) {
    return result$1(reduce(step$1, init$1(), list))
  });

  const init$2 = () => ({ count: 0, sum: 0 });
  const result$2 = acc => acc.sum / acc.count;
  const step$2 = (acc, val) => {
    acc.count++;
    acc.sum += val;

    return acc
  };

  const _xmean = () => ({
    '@@transducer/init': init$2,
    '@@transducer/result': result$2,
    '@@transducer/step': step$2
  });

  const mean = _dispatchableSummarizer(_xmean, function (list) {
    return result$2(reduce(step$2, init$2(), list))
  });

  // Translated to JavaScript from https://rcoh.me/posts/linear-time-median-finding/
  function median (array) {
    const len = array.length;

    if (len === 1) return array[0]

    if (len % 2 === 1) {
      return quickselect(array, len / 2)
    } else {
      return 0.5 * (
        quickselect(array, (len / 2) - 1) +
        quickselect(array, len / 2)
      )
    }
  }

  function quickselect (array, k) {
    const pivot = pickPivot(array);

    const lows = [];
    const highs = [];
    const pivots = [];

    for (let i = 0; i < array.length; i++) {
      const element = array[i];

      if (element < pivot) {
        lows.push(element);
      } else if (element > pivot) {
        highs.push(element);
      } else {
        pivots.push(element);
      }
    }

    if (k < lows.length) {
      return quickselect(lows, k)
    } else if (k < lows.length + pivots.length) {
      return pivots[0]
    } else {
      return quickselect(highs, k - lows.length - pivots.length)
    }
  }

  function pickPivot (array) {
    if (array.length < 5) {
      return nlogMedian(array)
    }

    const medians = getMediansOfChunks(array, 5);

    return median(medians)
  }

  function nlogMedian (array) {
    array.sort((a, b) => a - b);

    const len = array.length;

    if (len % 2 === 1) {
      return array[len / 2]
    } else {
      return 0.5 * (array[(len / 2) - 1] + array[len / 2])
    }
  }

  function getMediansOfChunks (array, chunkSize) {
    const medians = [];

    for (let i = 0; i < array.length; i = i + chunkSize) {
      if (i + chunkSize > array.length) {
        break
      }

      const chunk = [];

      for (let j = 0; j < chunkSize; j++) {
        chunk.push(array[i + j]);
      }

      chunk.sort((a, b) => a - b);

      medians.push(chunk[2]);
    }

    return medians
  }

  const init$3 = () => Infinity;
  const result$3 = identity;
  const step$3 = (acc, val) => acc < val ? acc : val;

  const _xmin = () => ({
    '@@transducer/init': init$3,
    '@@transducer/result': result$3,
    '@@transducer/step': step$3
  });

  const min = _dispatchableSummarizer(_xmin, function (list) {
    return result$3(reduce(step$3, init$3(), list))
  });

  const init$4 = () => ({});

  const result$4 = acc => {
    let maxCount = 0;
    let maxElement;

    for (const element in acc) {
      const count = acc[element];

      if (maxCount < count) {
        maxCount = count;
        maxElement = element;
      }
    }

    return parseInt(maxElement)
  };

  const step$4 = (acc, val) => {
    if (val in acc) {
      acc[val]++;
    } else {
      acc[val] = 1;
    }

    return acc
  };

  const _xmode = () => ({
    '@@transducer/init': init$4,
    '@@transducer/result': result$4,
    '@@transducer/step': step$4
  });

  const mode = _dispatchableSummarizer(_xmode, function (list) {
    return result$4(reduce(step$4, init$4(), list))
  });

  const init$5 = () => 0;
  const result$5 = identity;
  const step$5 = (acc, val) => acc + val;

  const _xsum = () => ({
    '@@transducer/init': init$5,
    '@@transducer/result': result$5,
    '@@transducer/step': step$5
  });

  const sum = _dispatchableSummarizer(_xsum, function (list) {
    return result$5(reduce(step$5, init$5(), list))
  });

  function _isTransformer$1 (obj) {
    return obj != null && typeof obj['@@transducer/step'] === 'function'
  }

  // Adapted from ramda: https://github.com/ramda/ramda

  function _dispatchable$1 (methodNames, transducerCreator, fn) {
    return function () {
      if (arguments.length === 0) {
        return fn()
      }
      const obj = arguments[arguments.length - 1];

      if (!_isArray$1(obj)) {
        let idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === 'function') {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1))
          }
          idx += 1;
        }
        if (_isTransformer$1(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj)
        }
      }
      return fn.apply(this, arguments)
    }
  }

  var _xfBase$1 = {
    init: function () {
      return this.xf['@@transducer/init']()
    },
    result: function (result) {
      return this.xf['@@transducer/result'](result)
    }
  };

  const _xarrange = curryN(2, function _xarrange (arrangeInstructions, xf) {
    return new XArrange(arrangeInstructions, xf)
  });

  const arrange = curryN(2, _dispatchable$1([], _xarrange,
    function (arrangeInstructions, df) {
      return into(
        [],
        arrange(arrangeInstructions),
        df
      )
    }
  ));

  function XArrange (arrangeInstructions, xf) {
    this.arrangeFn = arrangeInstructions.constructor === Function
      ? arrangeInstructions
      : _combineArrangeFns(arrangeInstructions);

    this.rows = [];
    this.xf = xf;
  }

  XArrange.prototype['@@transducer/init'] = _xfBase$1.init;
  XArrange.prototype['@@transducer/result'] = function () {
    this.rows.sort(this.arrangeFn);

    return this.xf['@@transducer/result'](reduce(
      this.xf['@@transducer/step'].bind(this.xf),
      this.xf['@@transducer/init'](),
      this.rows
    ))
  };
  XArrange.prototype['@@transducer/step'] = function (acc, row) {
    this.rows.push(row);
  };

  function _combineArrangeFns (arrangeFns) {
    return function (a, b) {
      for (let i = 0; i < arrangeFns.length; i++) {
        const res = arrangeFns[i](a, b);
        if (res) return res
      }

      return -1
    }
  }

  function _reduceObjVals (step, acc, obj) {
    for (const key in obj) {
      const val = obj[key];

      acc = step(acc, val);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break
      }
    }

    return acc
  }

  function _idFromCols (row, idCols, sep = '@') {
    let id = sep;

    for (let i = 0; i < idCols.length; i++) {
      id += row[idCols[i]] + sep;
    }

    return id
  }

  const _xsummariseByReducable = (summariseFn, by, xf) => {
    return new XSummariseByReducable(summariseFn, by, xf)
  };

  function XSummariseByReducable (summariseFn, by, xf) {
    this.instructions = _getReducableInstructions(summariseFn);
    this.by = by;
    this.xf = xf;

    this.summarizedDataById = {};
  }

  function _getReducableInstructions (f) {
    const columnProxy = new Proxy({}, { get (_, prop) { return prop } });
    return f(columnProxy)
  }

  XSummariseByReducable.prototype['@@transducer/init'] = _xfBase$1.init;
  XSummariseByReducable.prototype['@@transducer/result'] = _result;
  XSummariseByReducable.prototype['@@transducer/step'] = _step$2;
  XSummariseByReducable.prototype._finalStep = _finalStep;

  function _result () {
    return this.xf['@@transducer/result'](_reduceObjVals(
      this._finalStep.bind(this),
      this.xf['@@transducer/init'](),
      this.summarizedDataById
    ))
  }

  function _step$2 (acc, row) {
    const id = _idFromCols(row, this.by);
    const newId = !(id in this.summarizedDataById);

    if (newId) {
      this.summarizedDataById[id] = _initSummaryGroup(
        this.instructions,
        row,
        this.by
      );
    }

    this.summarizedDataById[id] = _updateSummaryGroup(
      this.summarizedDataById[id],
      this.instructions,
      row
    );

    return acc
  }

  function _finalStep (acc, row) {
    for (const newColumnName in this.instructions) {
      row[newColumnName] = this
        .instructions[newColumnName]
        .xf['@@transducer/result'](row[newColumnName]);
    }

    return this.xf['@@transducer/step'](acc, row)
  }

  function _initSummaryGroup (instructions, row, by) {
    const summaryGroup = {};

    for (const newColumnName in instructions) {
      const instruction = instructions[newColumnName];
      summaryGroup[newColumnName] = instruction.xf['@@transducer/init']();
    }

    for (let i = 0; i < by.length; i++) {
      const byCol = by[i];
      summaryGroup[byCol] = row[byCol];
    }

    return summaryGroup
  }

  function _updateSummaryGroup (summaryGroup, instructions, row) {
    for (const newColumnName in instructions) {
      const instruction = instructions[newColumnName];

      summaryGroup[newColumnName] = instruction.xf['@@transducer/step'](
        summaryGroup[newColumnName],
        row[instruction.column]
      );
    }

    return summaryGroup
  }

  const _stepCatArray$1 = {
    '@@transducer/init': Array,
    '@@transducer/step': function (xs, x) {
      xs.push(x);
      return xs
    },
    '@@transducer/result': identity
  };

  const _stepCatString$1 = {
    '@@transducer/init': String,
    '@@transducer/step': function (a, b) { return a + b },
    '@@transducer/result': identity
  };

  const _stepCatObject$1 = {
    '@@transducer/init': Object,
    '@@transducer/step': function (result, input) {
      return Object.assign(
        result,
        _isArrayLike$1(input) ? objOf(input[0], input[1]) : input
      )
    },
    '@@transducer/result': identity
  };

  function _stepCat$1 (obj) {
    if (_isTransformer$1(obj)) {
      return obj
    }

    if (_isArrayLike$1(obj)) {
      return _stepCatArray$1
    }

    if (typeof obj === 'string') {
      return _stepCatString$1
    }

    if (typeof obj === 'object') {
      return _stepCatObject$1
    }

    throw new Error('Cannot create transformer for ' + obj)
  }

  function select (columns, df) {
    const selectFn = _getSelectFn(columns);
    return df
      ? map(selectFn, df)
      : map(selectFn)
  }

  function _getSelectFn (columns) {
    return row => {
      const newRow = {};

      for (let i = 0; i < columns.length; i++) {
        const columnName = columns[i];
        newRow[columnName] = row[columnName];
      }

      return newRow
    }
  }

  const _xnestBy = curryN(3, function _xnestBy (nestInstructions, by, xf) {
    return new XNestBy(nestInstructions, by, xf)
  });

  const nestBy = curryN(3, _dispatchable$1([], _xnestBy,
    function (nestInstructions, by, df) {
      return into(
        [],
        nestBy(nestInstructions, by),
        df
      )
    }
  ));

  function XNestBy (nestInstructions, by, xf) {
    const nestInstructionsIsObj = nestInstructions.constructor === Object;

    this.nestColName = nestInstructionsIsObj
      ? nestInstructions.column
      : nestInstructions;

    this.getAccumulator = nestInstructionsIsObj && nestInstructions.getAccumulator
      ? nestInstructions.getAccumulator
      : () => [];

    this.by = by;
    this.xf = xf;

    this.select = null;
    this.nestedDataById = {};
    this.accumulatorById = {};

    this.init = true;
  }

  XNestBy.prototype['@@transducer/init'] = _xfBase$1.init;
  XNestBy.prototype['@@transducer/result'] = _result$1;
  XNestBy.prototype['@@transducer/step'] = function (acc, row) {
    if (this.init) {
      this._initStep(acc, row);
      this.init = false;
    }

    return this._step(acc, row)
  };
  XNestBy.prototype._initStep = _initStep$1;
  XNestBy.prototype._step = _step$3;

  function _result$1 () {
    return this.xf['@@transducer/result'](_reduceObjVals(
      this.xf['@@transducer/step'].bind(this.xf),
      this.xf['@@transducer/init'](),
      this.nestedDataById
    ))
  }

  function _initStep$1 (acc, row) {
    const bySet = new Set(this.by);
    const nestedColumns = [];

    for (const columnName in row) {
      if (!bySet.has(columnName)) {
        nestedColumns.push(columnName);
      }
    }

    this.select = _getSelectFn(nestedColumns);
  }

  function _step$3 (acc, row) {
    const id = _idFromCols(row, this.by);
    const newId = !(id in this.accumulatorById);

    if (newId) {
      this.accumulatorById[id] = _stepCat$1(this.getAccumulator());

      const nestRow = _initNestRow(
        row,
        this.nestColName,
        this.by,
        this.accumulatorById[id]['@@transducer/init']()
      );

      this.nestedDataById[id] = nestRow;
    }

    const xf = this.accumulatorById[id];

    this.nestedDataById[id][this.nestColName] = xf['@@transducer/step'](
      this.nestedDataById[id][this.nestColName],
      this.select(row)
    );

    return acc
  }

  function _initNestRow (row, nestColName, by, initVal) {
    const nestRow = {};

    for (let i = 0; i < by.length; i++) {
      const colName = by[i];
      nestRow[colName] = row[colName];
    }

    nestRow[nestColName] = initVal;

    return nestRow
  }

  const _xsummariseByIrreducable = (summariseFn, by, xf) => {
    return new XSummariseByIrreducable(summariseFn, by, xf)
  };

  function XSummariseByIrreducable (summariseFn, by, xf) {
    this.summariseFn = summariseFn;
    this.by = by;
    this.xf = xf;

    this.nestColName = Symbol('nested');
    this.getAccumulator = accumulator;

    this.nestedColumns = [];
    this.nestedDataById = {};
    this.accumulatorById = {};

    this.init = true;
  }

  XSummariseByIrreducable.prototype['@@transducer/init'] = _xfBase$1.init;
  XSummariseByIrreducable.prototype['@@transducer/result'] = _result$2;
  XSummariseByIrreducable.prototype['@@transducer/step'] = function (acc, row) {
    if (this.init) {
      this._initStep(acc, row);
      this.init = false;
    }

    return this._step(acc, row)
  };
  XSummariseByIrreducable.prototype._initStep = _initStep$1;
  XSummariseByIrreducable.prototype._step = _step$3;
  XSummariseByIrreducable.prototype._finalStep = _finalStep$1;

  function _result$2 () {
    return this.xf['@@transducer/result'](_reduceObjVals(
      this._finalStep.bind(this),
      this.xf['@@transducer/init'](),
      this.nestedDataById
    ))
  }

  function _finalStep$1 (acc, row) {
    const summarizedRow = this.summariseFn(row[this.nestColName]);

    for (let i = 0; i < this.by.length; i++) {
      const byCol = this.by[i];
      summarizedRow[byCol] = row[byCol];
    }

    return this.xf['@@transducer/step'](acc, summarizedRow)
  }

  const _xsummariseBy = curryN(3, (summariseFn, by, xf) => {
    return _isReducable(summariseFn)
      ? _xsummariseByReducable(summariseFn, by, xf)
      : _xsummariseByIrreducable(summariseFn, by, xf)
  });

  const summariseBy = curryN(3, _dispatchable$1([], _xsummariseBy,
    function (summariseFn, by, df) {
      return into(
        [],
        summariseBy(summariseFn, by),
        df
      )
    }
  ));

  function _isReducable (summariseFn) {
    try {
      const summariseInstructions = summariseFn({});

      for (const newColumnName in summariseInstructions) {
        if (summariseInstructions[newColumnName] !== REDUCABLE) {
          return false
        }
      }
    } catch (e) {
      return false
    }

    return true
  }

  const _xfilterByReducable = (summariseFn, predicate, by, xf) => {
    return new XFilterByReducable(summariseFn, predicate, by, xf)
  };

  function XFilterByReducable (summariseFn, predicate, by, xf) {
    this.instructions = _getReducableInstructions(summariseFn);
    this.predicate = predicate;
    this.by = by;
    this.xf = xf;

    this.summarizedDataById = {};
    this.rows = [];
    this.ids = [];
  }

  XFilterByReducable.prototype['@@transducer/init'] = _xfBase$1.init;
  XFilterByReducable.prototype['@@transducer/result'] = _result$3;
  XFilterByReducable.prototype['@@transducer/step'] = _step$4;

  function _result$3 () {
    for (const id in this.summarizedDataById) {
      for (const newColumnName in this.instructions) {
        const resultFn = this
          .instructions[newColumnName]
          .xf['@@transducer/result'];

        this.summarizedDataById[id][newColumnName] = resultFn(
          this.summarizedDataById[id][newColumnName]
        );
      }
    }

    let acc = this.xf['@@transducer/init']();
    let idx = 0;
    const len = this.rows.length;

    while (idx < len) {
      const row = this.rows[idx];
      const id = this.ids[idx];

      if (this.predicate(row, this.summarizedDataById[id])) {
        acc = this.xf['@@transducer/step'](acc, row);
      }

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break
      }

      idx++;
    }

    return this.xf['@@transducer/result'](acc)
  }

  function _step$4 (acc, row) {
    const id = _idFromCols(row, this.by);
    const newId = !(id in this.summarizedDataById);

    this.rows.push(row);
    this.ids.push(id);

    if (newId) {
      this.summarizedDataById[id] = _initSummaryGroup(
        this.instructions,
        row,
        this.by
      );
    }

    this.summarizedDataById[id] = _updateSummaryGroup(
      this.summarizedDataById[id],
      this.instructions,
      row
    );

    return acc
  }

  // import _reduceObjVals from './_reduceObjVals.js'

  const _xfilterByIrreducable = (summariseFn, predicate, by, xf) => {
    return new XFilterByIrreducable(summariseFn, predicate, by, xf)
  };

  function XFilterByIrreducable (summariseFn, predicate, by, xf) {
    this.summariseFn = summariseFn;
    this.predicate = predicate;
    this.by = by;
    this.xf = xf;

    this.nestColName = Symbol('nested');
    this.getAccumulator = accumulator;

    this.nestedColumns = [];
    this.nestedDataById = {};
    this.accumulatorById = {};
    this.rows = [];
    this.ids = [];

    this.init = true;
  }

  XFilterByIrreducable.prototype['@@transducer/init'] = _xfBase$1.init;
  XFilterByIrreducable.prototype['@@transducer/result'] = _result$4;
  XFilterByIrreducable.prototype['@@transducer/step'] = function (acc, row) {
    if (this.init) {
      this._initStep(acc, row);
      this.init = false;
    }

    return this._step(acc, row)
  };
  XFilterByIrreducable.prototype._initStep = _initStep$1;
  XFilterByIrreducable.prototype._step = _step$5;

  function _result$4 () {
    for (const id in this.nestedDataById) {
      const row = this.nestedDataById[id];

      const summarizedRow = this.summariseFn(row[this.nestColName]);

      for (let i = 0; i < this.by.length; i++) {
        const byCol = this.by[i];
        summarizedRow[byCol] = row[byCol];
      }

      this.nestedDataById[id] = summarizedRow;
    }

    this.summarizedDataById = this.nestedDataById;
    this.nestedDataById = null;

    let acc = this.xf['@@transducer/init']();
    let idx = 0;
    const len = this.rows.length;

    while (idx < len) {
      const row = this.rows[idx];
      const id = this.ids[idx];

      if (this.predicate(row, this.summarizedDataById[id])) {
        acc = this.xf['@@transducer/step'](acc, row);
      }

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break
      }

      idx++;
    }

    return this.xf['@@transducer/result'](acc)
  }

  function _step$5 (acc, row) {
    const id = _idFromCols(row, this.by);
    const newId = !(id in this.accumulatorById);

    this.rows.push(row);
    this.ids.push(id);

    if (newId) {
      this.accumulatorById[id] = _stepCat$1(this.getAccumulator());

      const nestRow = _initNestRow(
        row,
        this.nestColName,
        this.by,
        this.accumulatorById[id]['@@transducer/init']()
      );

      this.nestedDataById[id] = nestRow;
    }

    const xf = this.accumulatorById[id];

    this.nestedDataById[id][this.nestColName] = xf['@@transducer/step'](
      this.nestedDataById[id][this.nestColName],
      this.select(row)
    );

    return acc
  }

  const _xfilterBy = curryN(4, function _xfilterBy (summariseFn, predicate, by, xf) {
    return _isReducable(summariseFn)
      ? _xfilterByReducable(summariseFn, predicate, by, xf)
      : _xfilterByIrreducable(summariseFn, predicate, by, xf)
  });

  const filterBy = curryN(4, _dispatchable$1([], _xfilterBy,
    function (summariseFn, predicate, by, df) {
      return into(
        [],
        filterBy(summariseFn, predicate, by),
        df
      )
    }
  ));

  function mutate (mutateInstructions, df) {
    const mutateFn = _getMutateFn(mutateInstructions);
    return df
      ? map(mutateFn, df)
      : map(mutateFn)
  }

  function _getMutateFn (mutateInstructions) {
    return row => {
      const newRow = Object.assign({}, row);

      for (const newColumnName in mutateInstructions) {
        newRow[newColumnName] = mutateInstructions[newColumnName](newRow);
      }

      return newRow
    }
  }

  const _xpivotLonger = curryN(2, function _xpivotLonger (pivotInstructions, xf) {
    return new XPivotLonger(pivotInstructions, xf)
  });

  const pivotLonger = curryN(2, _dispatchable$1([], _xpivotLonger,
    function (pivotInstructions, df) {
      return into(
        [],
        pivotLonger(pivotInstructions),
        df
      )
    }
  ));

  function XPivotLonger ({ columns, namesTo, valuesTo }, xf) {
    this.pivotColumns = columns;
    this.pivotColumnsSet = new Set(columns);
    this.namesTo = namesTo;
    this.valuesTo = valuesTo;
    this.xf = xf;

    this.columns = null;
    this.idColumns = null;

    this.init = true;
  }

  XPivotLonger.prototype['@@transducer/init'] = _xfBase$1.init;
  XPivotLonger.prototype['@@transducer/result'] = _xfBase$1.result;
  XPivotLonger.prototype['@@transducer/step'] = function (acc, row) {
    if (this.init) {
      this._initStep(acc, row);
      this.init = false;
    }

    return this._step(acc, row)
  };
  XPivotLonger.prototype._initStep = _initStep$2;
  XPivotLonger.prototype._step = _step$6;

  function _initStep$2 (acc, row) {
    this.columns = Object.keys(row);

    this.idColumns = this.columns.filter(
      columnName => !this.pivotColumnsSet.has(columnName)
    );
  }

  function _step$6 (acc, row) {
    const newRows = [];

    for (let j = 0; j < this.pivotColumns.length; j++) {
      const newRow = {};

      const pivotColumnName = this.pivotColumns[j];
      const pivotColumnValue = row[pivotColumnName];

      newRow[this.namesTo] = pivotColumnName;
      newRow[this.valuesTo] = pivotColumnValue;

      for (let k = 0; k < this.idColumns.length; k++) {
        const idColumnName = this.idColumns[k];
        newRow[idColumnName] = row[idColumnName];
      }

      newRows.push(newRow);
    }

    return reduce(
      this.xf['@@transducer/step'].bind(this.xf),
      acc,
      newRows
    )
  }

  const _xpivotWider = curryN(2, function _xpivotWider (pivotInstructions, xf) {
    return new XPivotWider(pivotInstructions, xf)
  });

  const pivotWider = curryN(2, _dispatchable$1([], _xpivotWider,
    function (pivotInstructions, df) {
      return into(
        [],
        pivotWider(pivotInstructions),
        df
      )
    }
  ));

  function XPivotWider ({ namesFrom, valuesFrom, valuesFill = null }, xf) {
    this.namesFrom = namesFrom;
    this.valuesFrom = valuesFrom;
    this.valuesFill = valuesFill;
    this.xf = xf;

    this.idColumns = null;
    this.widerRowsById = {};
    this.newColumnsSet = new Set();
    this.newColumns = null;

    this.init = true;
  }

  XPivotWider.prototype['@@transducer/init'] = _xfBase$1.init;
  XPivotWider.prototype['@@transducer/result'] = _result$5;
  XPivotWider.prototype['@@transducer/step'] = function (acc, row) {
    if (this.init) {
      this._initStep(acc, row);
      this.init = false;
    }

    return this._step(acc, row)
  };
  XPivotWider.prototype._initStep = _initStep$3;
  XPivotWider.prototype._step = _step$7;
  XPivotWider.prototype._finalStep = _finalStep$2;

  function _result$5 () {
    this.newColumns = Array.from(this.newColumnsSet);

    return this.xf['@@transducer/result'](_reduceObjVals(
      this._finalStep.bind(this),
      this.xf['@@transducer/init'](),
      this.widerRowsById
    ))
  }

  function _initStep$3 (acc, row) {
    const columns = Object.keys(row);
    const nonIdColumns = [this.namesFrom, this.valuesFrom];
    this.idColumns = columns.filter(c => !nonIdColumns.includes(c));
  }

  function _step$7 (acc, row) {
    const id = _idFromCols(row, this.idColumns);
    const newId = !(id in this.widerRowsById);

    if (newId) {
      const widerRow = {};

      for (let i = 0; i < this.idColumns.length; i++) {
        const idColumn = this.idColumns[i];
        widerRow[idColumn] = row[idColumn];
      }

      this.widerRowsById[id] = widerRow;
    }

    const column = row[this.namesFrom];
    const value = row[this.valuesFrom];

    this.widerRowsById[id][column] = value;
    this.newColumnsSet.add(column);
  }

  function _finalStep$2 (acc, row) {
    for (let i = 0; i < this.newColumns.length; i++) {
      const newColumn = this.newColumns[i];

      if (!(newColumn in row)) {
        row[newColumn] = this.valuesFill;
      }
    }

    return this.xf['@@transducer/step'](acc, row)
  }

  function rename (renameInstructions, df) {
    const renameFn = _getRenameFn(renameInstructions);
    return df
      ? map(renameFn, df)
      : map(renameFn)
  }

  function _getRenameFn (renameInstructions) {
    return row => {
      const newRow = Object.assign({}, row);

      for (const newCol in renameInstructions) {
        const oldCol = renameInstructions[newCol];
        newRow[newCol] = newRow[oldCol];
        delete newRow[oldCol];
      }

      return newRow
    }
  }

  function _reduced (x) {
    return x && x['@@transducer/reduced']
      ? x
      : {
        '@@transducer/value': x,
        '@@transducer/reduced': true
      }
  }

  const _xslice = curryN(2, function _xslice (indices, xf) {
    return new XSlice(indices, xf)
  });

  const slice$1 = curryN(2, _dispatchable$1([], _xslice,
    function (indices, df) {
      return into(
        [],
        slice$1(indices),
        df
      )
    }
  ));

  function XSlice (indices, xf) {
    this.indices = new Set(indices);
    this.xf = xf;

    this.counter = -1;
  }

  XSlice.prototype['@@transducer/init'] = _xfBase$1.init;
  XSlice.prototype['@@transducer/result'] = _xfBase$1.result;
  XSlice.prototype['@@transducer/step'] = function (acc, row) {
    this.counter++;

    if (this.indices.has(this.counter)) {
      this.indices.delete(this.counter);
      const output = this.xf['@@transducer/step'](acc, row);

      return this.indices.size === 0
        ? _reduced(output)
        : output
    }

    return acc
  };

  const _xunnest = curryN(3, function _xunnest (nestColName, nestWrapper, xf) {
    return new XUnnest(nestColName, nestWrapper, xf)
  });

  const unnest = curryN(3, _dispatchable$1([], _xunnest,
    function (nestColName, nestWrapper, df) {
      return into(
        [],
        unnest(nestColName, nestWrapper),
        df
      )
    }
  ));

  function XUnnest (nestColName, nestWrapper, xf) {
    this.nestColName = nestColName;
    this.nestWrapper = nestWrapper;
    this.xf = xf;
    this.outerColumns = [];

    this.init = true;
  }

  XUnnest.prototype['@@transducer/init'] = _xfBase$1.init;
  XUnnest.prototype['@@transducer/result'] = _xfBase$1.result;
  XUnnest.prototype['@@transducer/step'] = function (acc, row) {
    if (this.init) {
      this._initStep(acc, row);
      this.init = false;
    }

    return this._step(acc, row)
  };

  XUnnest.prototype._initStep = function (acc, row) {
    for (const columnName in row) {
      if (columnName !== this.nestColName) {
        this.outerColumns.push(columnName);
      }
    }
  };

  XUnnest.prototype._step = function (acc, row) {
    const nestedData = row[this.nestColName];

    const rowWithoutNested = Object.assign({}, row);
    delete rowWithoutNested[this.nestColName];

    return reduce(
      (innerAcc, innerRow) => this.xf[['@@transducer/step']](
        innerAcc,
        _attach(innerRow, rowWithoutNested)
      ),
      acc,
      this.nestWrapper(nestedData)
    )
  };

  function _attach (innerRow, outerRow) {
    const newRow = Object.assign({}, innerRow);

    for (const columnName in outerRow) {
      newRow[columnName] = outerRow[columnName];
    }

    return newRow
  }

  exports.arrange = arrange;
  exports.ascending = ascending;
  exports.ascendingStr = ascendingStr;
  exports.columnOriented = columnOriented;
  exports.compose = compose;
  exports.count = count;
  exports.descending = descending;
  exports.descendingStr = ascendingStr$1;
  exports.filter = filter;
  exports.filterBy = filterBy;
  exports.geojson = geojson;
  exports.into = into;
  exports.max = max;
  exports.mean = mean;
  exports.median = median;
  exports.min = min;
  exports.mode = mode;
  exports.mutate = mutate;
  exports.nestBy = nestBy;
  exports.pivotLonger = pivotLonger;
  exports.pivotWider = pivotWider;
  exports.reduce = reduce;
  exports.rename = rename;
  exports.select = select;
  exports.slice = slice$1;
  exports.sum = sum;
  exports.summariseBy = summariseBy;
  exports.transduce = transduce;
  exports.unnest = unnest;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
