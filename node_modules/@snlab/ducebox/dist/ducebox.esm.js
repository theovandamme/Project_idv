import { identity, curryN, reduce, into, objOf, map } from 'ramda';
export { compose, filter, into, reduce, transduce } from 'ramda';

function _dispatchableCompareFn (fn) {
  return function (column) {
    const getValue = column.constructor === Function
      ? column
      : row => row[column];

    return function (rowA, rowB) {
      return fn(getValue(rowA), getValue(rowB))
    }
  }
}

const ascending = _dispatchableCompareFn(
  (a, b) => a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN
);

const ascendingStr = _dispatchableCompareFn((a, b) => {
  if (a === b) return 0

  const sorted = [a, b].sort();
  return sorted[0] === a ? -1 : 1
});

const descending = _dispatchableCompareFn(
  (a, b) => b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN
);

const ascendingStr$1 = _dispatchableCompareFn((a, b) => {
  if (a === b) return 0

  const sorted = [a, b].sort();
  return sorted[0] === a ? 1 : -1
});

function wrap (data) {
  const length = _getLength(data);

  return {
    reduce: function (step, acc) {
      let idx = 0;

      while (idx < length) {
        const row = {};

        for (const columnName in data) {
          row[columnName] = data[columnName][idx];
        }

        acc = step(acc, row);

        if (acc && acc['@@transducer/reduced']) {
          acc = acc['@@transducer/value'];
          break
        }

        idx += 1;
      }

      return acc
    }
  }
}

function accumulator () {
  return new ColumnOrientedAccumulator()
}

function _getLength (data) {
  return data[Object.keys(data)[0]].length
}

function ColumnOrientedAccumulator () {
  this.init = true;
}

ColumnOrientedAccumulator.prototype['@@transducer/init'] = () => ({});
ColumnOrientedAccumulator.prototype['@@transducer/result'] = identity;
ColumnOrientedAccumulator.prototype['@@transducer/step'] = function (acc, row) {
  if (this.init) {
    this.init = false;
    return this._initStep(acc, row)
  }

  return this._step(acc, row)
};
ColumnOrientedAccumulator.prototype._initStep = _initStep;
ColumnOrientedAccumulator.prototype._step = _step;

function _initStep (acc, row) {
  for (const columnName in row) {
    acc[columnName] = [row[columnName]];
  }

  return acc
}

function _step (acc, row) {
  for (const columnName in row) {
    acc[columnName].push(row[columnName]);
  }

  return acc
}

var columnOriented = /*#__PURE__*/Object.freeze({
  __proto__: null,
  wrap: wrap,
  accumulator: accumulator
});

function wrap$1 (data, geometryColumn = '@@geometry') {
  const length = _getLength$1(data);

  return {
    reduce: function (step, acc) {
      let idx = 0;

      while (idx < length) {
        const feature = data.features[idx];
        const row = feature.properties;

        row[geometryColumn] = feature.geometry;

        acc = step(acc, row);

        if (acc && acc['@@transducer/reduced']) {
          acc = acc['@@transducer/value'];
          break
        }

        idx += 1;
      }

      return acc
    }
  }
}

function accumulator$1 (geometryColumn = '@@geometry') {
  return new GeoJSONAccumulator(geometryColumn)
}

function _getLength$1 (data) {
  return data.features.length
}

function GeoJSONAccumulator (geometryColumn) {
  this.geometryColumn = geometryColumn;
}

GeoJSONAccumulator.prototype['@@transducer/init'] = _init;
GeoJSONAccumulator.prototype['@@transducer/result'] = identity;
GeoJSONAccumulator.prototype['@@transducer/step'] = _step$1;

function _init () {
  return {
    type: 'FeatureCollection',
    features: []
  }
}

function _step$1 (acc, row) {
  const geometry = row[this.geometryColumn];
  const properties = row;
  delete properties[this.geometryColumn];

  acc.features.push({
    type: 'Feature',
    geometry,
    properties
  });

  return acc
}

var geojson = /*#__PURE__*/Object.freeze({
  __proto__: null,
  wrap: wrap$1,
  accumulator: accumulator$1
});

const REDUCABLE = Symbol('Reducable');

function _dispatchableSummarizer (transducerCreator, fn) {
  return function (...args) {
    if (args[0] === undefined) {
      return REDUCABLE
    }

    if (args[0] && args[0].constructor === String) {
      return {
        column: args[0],
        xf: transducerCreator()
      }
    }

    return fn(...args)
  }
}

// Adapted from ramda: https://github.com/ramda/ramda
var _isArray = Array.isArray || function _isArray (val) {
  return (val != null &&
          val.length >= 0 &&
          Object.prototype.toString.call(val) === '[object Array]')
};

function _isString (x) {
  return Object.prototype.toString.call(x) === '[object String]'
}

// Adapted from ramda: https://github.com/ramda/ramda

const _isArrayLike = curryN(1, function isArrayLike (x) {
  if (_isArray(x)) { return true }
  if (!x) { return false }
  if (typeof x !== 'object') { return false }
  if (_isString(x)) { return false }
  if (x.length === 0) { return true }
  if (x.length > 0) {
    return 0 in x && (x.length - 1) in x
  }
  return false
});

const init = () => 0;
const result = identity;
const step = acc => acc + 1;

const _xcount = () => ({
  '@@transducer/init': init,
  '@@transducer/result': result,
  '@@transducer/step': step
});

const count = _dispatchableSummarizer(_xcount, function count (list) {
  return _isArrayLike(list)
    ? list.length
    : result(reduce(step, init(), list))
});

const init$1 = () => -Infinity;
const result$1 = identity;
const step$1 = (acc, val) => acc < val ? val : acc;

const _xmax = () => ({
  '@@transducer/init': init$1,
  '@@transducer/result': result$1,
  '@@transducer/step': step$1
});

const max = _dispatchableSummarizer(_xmax, function (list) {
  return result$1(reduce(step$1, init$1(), list))
});

const init$2 = () => ({ count: 0, sum: 0 });
const result$2 = acc => acc.sum / acc.count;
const step$2 = (acc, val) => {
  acc.count++;
  acc.sum += val;

  return acc
};

const _xmean = () => ({
  '@@transducer/init': init$2,
  '@@transducer/result': result$2,
  '@@transducer/step': step$2
});

const mean = _dispatchableSummarizer(_xmean, function (list) {
  return result$2(reduce(step$2, init$2(), list))
});

// Translated to JavaScript from https://rcoh.me/posts/linear-time-median-finding/
function median (array) {
  const len = array.length;

  if (len === 1) return array[0]

  if (len % 2 === 1) {
    return quickselect(array, len / 2)
  } else {
    return 0.5 * (
      quickselect(array, (len / 2) - 1) +
      quickselect(array, len / 2)
    )
  }
}

function quickselect (array, k) {
  const pivot = pickPivot(array);

  const lows = [];
  const highs = [];
  const pivots = [];

  for (let i = 0; i < array.length; i++) {
    const element = array[i];

    if (element < pivot) {
      lows.push(element);
    } else if (element > pivot) {
      highs.push(element);
    } else {
      pivots.push(element);
    }
  }

  if (k < lows.length) {
    return quickselect(lows, k)
  } else if (k < lows.length + pivots.length) {
    return pivots[0]
  } else {
    return quickselect(highs, k - lows.length - pivots.length)
  }
}

function pickPivot (array) {
  if (array.length < 5) {
    return nlogMedian(array)
  }

  const medians = getMediansOfChunks(array, 5);

  return median(medians)
}

function nlogMedian (array) {
  array.sort((a, b) => a - b);

  const len = array.length;

  if (len % 2 === 1) {
    return array[len / 2]
  } else {
    return 0.5 * (array[(len / 2) - 1] + array[len / 2])
  }
}

function getMediansOfChunks (array, chunkSize) {
  const medians = [];

  for (let i = 0; i < array.length; i = i + chunkSize) {
    if (i + chunkSize > array.length) {
      break
    }

    const chunk = [];

    for (let j = 0; j < chunkSize; j++) {
      chunk.push(array[i + j]);
    }

    chunk.sort((a, b) => a - b);

    medians.push(chunk[2]);
  }

  return medians
}

const init$3 = () => Infinity;
const result$3 = identity;
const step$3 = (acc, val) => acc < val ? acc : val;

const _xmin = () => ({
  '@@transducer/init': init$3,
  '@@transducer/result': result$3,
  '@@transducer/step': step$3
});

const min = _dispatchableSummarizer(_xmin, function (list) {
  return result$3(reduce(step$3, init$3(), list))
});

const init$4 = () => ({});

const result$4 = acc => {
  let maxCount = 0;
  let maxElement;

  for (const element in acc) {
    const count = acc[element];

    if (maxCount < count) {
      maxCount = count;
      maxElement = element;
    }
  }

  return parseInt(maxElement)
};

const step$4 = (acc, val) => {
  if (val in acc) {
    acc[val]++;
  } else {
    acc[val] = 1;
  }

  return acc
};

const _xmode = () => ({
  '@@transducer/init': init$4,
  '@@transducer/result': result$4,
  '@@transducer/step': step$4
});

const mode = _dispatchableSummarizer(_xmode, function (list) {
  return result$4(reduce(step$4, init$4(), list))
});

const init$5 = () => 0;
const result$5 = identity;
const step$5 = (acc, val) => acc + val;

const _xsum = () => ({
  '@@transducer/init': init$5,
  '@@transducer/result': result$5,
  '@@transducer/step': step$5
});

const sum = _dispatchableSummarizer(_xsum, function (list) {
  return result$5(reduce(step$5, init$5(), list))
});

function _isTransformer (obj) {
  return obj != null && typeof obj['@@transducer/step'] === 'function'
}

// Adapted from ramda: https://github.com/ramda/ramda

function _dispatchable (methodNames, transducerCreator, fn) {
  return function () {
    if (arguments.length === 0) {
      return fn()
    }
    const obj = arguments[arguments.length - 1];

    if (!_isArray(obj)) {
      let idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === 'function') {
          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1))
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
        return transducer(obj)
      }
    }
    return fn.apply(this, arguments)
  }
}

var _xfBase = {
  init: function () {
    return this.xf['@@transducer/init']()
  },
  result: function (result) {
    return this.xf['@@transducer/result'](result)
  }
};

const _xarrange = curryN(2, function _xarrange (arrangeInstructions, xf) {
  return new XArrange(arrangeInstructions, xf)
});

const arrange = curryN(2, _dispatchable([], _xarrange,
  function (arrangeInstructions, df) {
    return into(
      [],
      arrange(arrangeInstructions),
      df
    )
  }
));

function XArrange (arrangeInstructions, xf) {
  this.arrangeFn = arrangeInstructions.constructor === Function
    ? arrangeInstructions
    : _combineArrangeFns(arrangeInstructions);

  this.rows = [];
  this.xf = xf;
}

XArrange.prototype['@@transducer/init'] = _xfBase.init;
XArrange.prototype['@@transducer/result'] = function () {
  this.rows.sort(this.arrangeFn);

  return this.xf['@@transducer/result'](reduce(
    this.xf['@@transducer/step'].bind(this.xf),
    this.xf['@@transducer/init'](),
    this.rows
  ))
};
XArrange.prototype['@@transducer/step'] = function (acc, row) {
  this.rows.push(row);
};

function _combineArrangeFns (arrangeFns) {
  return function (a, b) {
    for (let i = 0; i < arrangeFns.length; i++) {
      const res = arrangeFns[i](a, b);
      if (res) return res
    }

    return -1
  }
}

function _reduceObjVals (step, acc, obj) {
  for (const key in obj) {
    const val = obj[key];

    acc = step(acc, val);

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break
    }
  }

  return acc
}

function _idFromCols (row, idCols, sep = '@') {
  let id = sep;

  for (let i = 0; i < idCols.length; i++) {
    id += row[idCols[i]] + sep;
  }

  return id
}

const _xsummariseByReducable = (summariseFn, by, xf) => {
  return new XSummariseByReducable(summariseFn, by, xf)
};

function XSummariseByReducable (summariseFn, by, xf) {
  this.instructions = _getReducableInstructions(summariseFn);
  this.by = by;
  this.xf = xf;

  this.summarizedDataById = {};
}

function _getReducableInstructions (f) {
  const columnProxy = new Proxy({}, { get (_, prop) { return prop } });
  return f(columnProxy)
}

XSummariseByReducable.prototype['@@transducer/init'] = _xfBase.init;
XSummariseByReducable.prototype['@@transducer/result'] = _result;
XSummariseByReducable.prototype['@@transducer/step'] = _step$2;
XSummariseByReducable.prototype._finalStep = _finalStep;

function _result () {
  return this.xf['@@transducer/result'](_reduceObjVals(
    this._finalStep.bind(this),
    this.xf['@@transducer/init'](),
    this.summarizedDataById
  ))
}

function _step$2 (acc, row) {
  const id = _idFromCols(row, this.by);
  const newId = !(id in this.summarizedDataById);

  if (newId) {
    this.summarizedDataById[id] = _initSummaryGroup(
      this.instructions,
      row,
      this.by
    );
  }

  this.summarizedDataById[id] = _updateSummaryGroup(
    this.summarizedDataById[id],
    this.instructions,
    row
  );

  return acc
}

function _finalStep (acc, row) {
  for (const newColumnName in this.instructions) {
    row[newColumnName] = this
      .instructions[newColumnName]
      .xf['@@transducer/result'](row[newColumnName]);
  }

  return this.xf['@@transducer/step'](acc, row)
}

function _initSummaryGroup (instructions, row, by) {
  const summaryGroup = {};

  for (const newColumnName in instructions) {
    const instruction = instructions[newColumnName];
    summaryGroup[newColumnName] = instruction.xf['@@transducer/init']();
  }

  for (let i = 0; i < by.length; i++) {
    const byCol = by[i];
    summaryGroup[byCol] = row[byCol];
  }

  return summaryGroup
}

function _updateSummaryGroup (summaryGroup, instructions, row) {
  for (const newColumnName in instructions) {
    const instruction = instructions[newColumnName];

    summaryGroup[newColumnName] = instruction.xf['@@transducer/step'](
      summaryGroup[newColumnName],
      row[instruction.column]
    );
  }

  return summaryGroup
}

const _stepCatArray = {
  '@@transducer/init': Array,
  '@@transducer/step': function (xs, x) {
    xs.push(x);
    return xs
  },
  '@@transducer/result': identity
};

const _stepCatString = {
  '@@transducer/init': String,
  '@@transducer/step': function (a, b) { return a + b },
  '@@transducer/result': identity
};

const _stepCatObject = {
  '@@transducer/init': Object,
  '@@transducer/step': function (result, input) {
    return Object.assign(
      result,
      _isArrayLike(input) ? objOf(input[0], input[1]) : input
    )
  },
  '@@transducer/result': identity
};

function _stepCat (obj) {
  if (_isTransformer(obj)) {
    return obj
  }

  if (_isArrayLike(obj)) {
    return _stepCatArray
  }

  if (typeof obj === 'string') {
    return _stepCatString
  }

  if (typeof obj === 'object') {
    return _stepCatObject
  }

  throw new Error('Cannot create transformer for ' + obj)
}

function select (columns, df) {
  const selectFn = _getSelectFn(columns);
  return df
    ? map(selectFn, df)
    : map(selectFn)
}

function _getSelectFn (columns) {
  return row => {
    const newRow = {};

    for (let i = 0; i < columns.length; i++) {
      const columnName = columns[i];
      newRow[columnName] = row[columnName];
    }

    return newRow
  }
}

const _xnestBy = curryN(3, function _xnestBy (nestInstructions, by, xf) {
  return new XNestBy(nestInstructions, by, xf)
});

const nestBy = curryN(3, _dispatchable([], _xnestBy,
  function (nestInstructions, by, df) {
    return into(
      [],
      nestBy(nestInstructions, by),
      df
    )
  }
));

function XNestBy (nestInstructions, by, xf) {
  const nestInstructionsIsObj = nestInstructions.constructor === Object;

  this.nestColName = nestInstructionsIsObj
    ? nestInstructions.column
    : nestInstructions;

  this.getAccumulator = nestInstructionsIsObj && nestInstructions.getAccumulator
    ? nestInstructions.getAccumulator
    : () => [];

  this.by = by;
  this.xf = xf;

  this.select = null;
  this.nestedDataById = {};
  this.accumulatorById = {};

  this.init = true;
}

XNestBy.prototype['@@transducer/init'] = _xfBase.init;
XNestBy.prototype['@@transducer/result'] = _result$1;
XNestBy.prototype['@@transducer/step'] = function (acc, row) {
  if (this.init) {
    this._initStep(acc, row);
    this.init = false;
  }

  return this._step(acc, row)
};
XNestBy.prototype._initStep = _initStep$1;
XNestBy.prototype._step = _step$3;

function _result$1 () {
  return this.xf['@@transducer/result'](_reduceObjVals(
    this.xf['@@transducer/step'].bind(this.xf),
    this.xf['@@transducer/init'](),
    this.nestedDataById
  ))
}

function _initStep$1 (acc, row) {
  const bySet = new Set(this.by);
  const nestedColumns = [];

  for (const columnName in row) {
    if (!bySet.has(columnName)) {
      nestedColumns.push(columnName);
    }
  }

  this.select = _getSelectFn(nestedColumns);
}

function _step$3 (acc, row) {
  const id = _idFromCols(row, this.by);
  const newId = !(id in this.accumulatorById);

  if (newId) {
    this.accumulatorById[id] = _stepCat(this.getAccumulator());

    const nestRow = _initNestRow(
      row,
      this.nestColName,
      this.by,
      this.accumulatorById[id]['@@transducer/init']()
    );

    this.nestedDataById[id] = nestRow;
  }

  const xf = this.accumulatorById[id];

  this.nestedDataById[id][this.nestColName] = xf['@@transducer/step'](
    this.nestedDataById[id][this.nestColName],
    this.select(row)
  );

  return acc
}

function _initNestRow (row, nestColName, by, initVal) {
  const nestRow = {};

  for (let i = 0; i < by.length; i++) {
    const colName = by[i];
    nestRow[colName] = row[colName];
  }

  nestRow[nestColName] = initVal;

  return nestRow
}

const _xsummariseByIrreducable = (summariseFn, by, xf) => {
  return new XSummariseByIrreducable(summariseFn, by, xf)
};

function XSummariseByIrreducable (summariseFn, by, xf) {
  this.summariseFn = summariseFn;
  this.by = by;
  this.xf = xf;

  this.nestColName = Symbol('nested');
  this.getAccumulator = accumulator;

  this.nestedColumns = [];
  this.nestedDataById = {};
  this.accumulatorById = {};

  this.init = true;
}

XSummariseByIrreducable.prototype['@@transducer/init'] = _xfBase.init;
XSummariseByIrreducable.prototype['@@transducer/result'] = _result$2;
XSummariseByIrreducable.prototype['@@transducer/step'] = function (acc, row) {
  if (this.init) {
    this._initStep(acc, row);
    this.init = false;
  }

  return this._step(acc, row)
};
XSummariseByIrreducable.prototype._initStep = _initStep$1;
XSummariseByIrreducable.prototype._step = _step$3;
XSummariseByIrreducable.prototype._finalStep = _finalStep$1;

function _result$2 () {
  return this.xf['@@transducer/result'](_reduceObjVals(
    this._finalStep.bind(this),
    this.xf['@@transducer/init'](),
    this.nestedDataById
  ))
}

function _finalStep$1 (acc, row) {
  const summarizedRow = this.summariseFn(row[this.nestColName]);

  for (let i = 0; i < this.by.length; i++) {
    const byCol = this.by[i];
    summarizedRow[byCol] = row[byCol];
  }

  return this.xf['@@transducer/step'](acc, summarizedRow)
}

const _xsummariseBy = curryN(3, (summariseFn, by, xf) => {
  return _isReducable(summariseFn)
    ? _xsummariseByReducable(summariseFn, by, xf)
    : _xsummariseByIrreducable(summariseFn, by, xf)
});

const summariseBy = curryN(3, _dispatchable([], _xsummariseBy,
  function (summariseFn, by, df) {
    return into(
      [],
      summariseBy(summariseFn, by),
      df
    )
  }
));

function _isReducable (summariseFn) {
  try {
    const summariseInstructions = summariseFn({});

    for (const newColumnName in summariseInstructions) {
      if (summariseInstructions[newColumnName] !== REDUCABLE) {
        return false
      }
    }
  } catch (e) {
    return false
  }

  return true
}

const _xfilterByReducable = (summariseFn, predicate, by, xf) => {
  return new XFilterByReducable(summariseFn, predicate, by, xf)
};

function XFilterByReducable (summariseFn, predicate, by, xf) {
  this.instructions = _getReducableInstructions(summariseFn);
  this.predicate = predicate;
  this.by = by;
  this.xf = xf;

  this.summarizedDataById = {};
  this.rows = [];
  this.ids = [];
}

XFilterByReducable.prototype['@@transducer/init'] = _xfBase.init;
XFilterByReducable.prototype['@@transducer/result'] = _result$3;
XFilterByReducable.prototype['@@transducer/step'] = _step$4;

function _result$3 () {
  for (const id in this.summarizedDataById) {
    for (const newColumnName in this.instructions) {
      const resultFn = this
        .instructions[newColumnName]
        .xf['@@transducer/result'];

      this.summarizedDataById[id][newColumnName] = resultFn(
        this.summarizedDataById[id][newColumnName]
      );
    }
  }

  let acc = this.xf['@@transducer/init']();
  let idx = 0;
  const len = this.rows.length;

  while (idx < len) {
    const row = this.rows[idx];
    const id = this.ids[idx];

    if (this.predicate(row, this.summarizedDataById[id])) {
      acc = this.xf['@@transducer/step'](acc, row);
    }

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break
    }

    idx++;
  }

  return this.xf['@@transducer/result'](acc)
}

function _step$4 (acc, row) {
  const id = _idFromCols(row, this.by);
  const newId = !(id in this.summarizedDataById);

  this.rows.push(row);
  this.ids.push(id);

  if (newId) {
    this.summarizedDataById[id] = _initSummaryGroup(
      this.instructions,
      row,
      this.by
    );
  }

  this.summarizedDataById[id] = _updateSummaryGroup(
    this.summarizedDataById[id],
    this.instructions,
    row
  );

  return acc
}

// import _reduceObjVals from './_reduceObjVals.js'

const _xfilterByIrreducable = (summariseFn, predicate, by, xf) => {
  return new XFilterByIrreducable(summariseFn, predicate, by, xf)
};

function XFilterByIrreducable (summariseFn, predicate, by, xf) {
  this.summariseFn = summariseFn;
  this.predicate = predicate;
  this.by = by;
  this.xf = xf;

  this.nestColName = Symbol('nested');
  this.getAccumulator = accumulator;

  this.nestedColumns = [];
  this.nestedDataById = {};
  this.accumulatorById = {};
  this.rows = [];
  this.ids = [];

  this.init = true;
}

XFilterByIrreducable.prototype['@@transducer/init'] = _xfBase.init;
XFilterByIrreducable.prototype['@@transducer/result'] = _result$4;
XFilterByIrreducable.prototype['@@transducer/step'] = function (acc, row) {
  if (this.init) {
    this._initStep(acc, row);
    this.init = false;
  }

  return this._step(acc, row)
};
XFilterByIrreducable.prototype._initStep = _initStep$1;
XFilterByIrreducable.prototype._step = _step$5;

function _result$4 () {
  for (const id in this.nestedDataById) {
    const row = this.nestedDataById[id];

    const summarizedRow = this.summariseFn(row[this.nestColName]);

    for (let i = 0; i < this.by.length; i++) {
      const byCol = this.by[i];
      summarizedRow[byCol] = row[byCol];
    }

    this.nestedDataById[id] = summarizedRow;
  }

  this.summarizedDataById = this.nestedDataById;
  this.nestedDataById = null;

  let acc = this.xf['@@transducer/init']();
  let idx = 0;
  const len = this.rows.length;

  while (idx < len) {
    const row = this.rows[idx];
    const id = this.ids[idx];

    if (this.predicate(row, this.summarizedDataById[id])) {
      acc = this.xf['@@transducer/step'](acc, row);
    }

    if (acc && acc['@@transducer/reduced']) {
      acc = acc['@@transducer/value'];
      break
    }

    idx++;
  }

  return this.xf['@@transducer/result'](acc)
}

function _step$5 (acc, row) {
  const id = _idFromCols(row, this.by);
  const newId = !(id in this.accumulatorById);

  this.rows.push(row);
  this.ids.push(id);

  if (newId) {
    this.accumulatorById[id] = _stepCat(this.getAccumulator());

    const nestRow = _initNestRow(
      row,
      this.nestColName,
      this.by,
      this.accumulatorById[id]['@@transducer/init']()
    );

    this.nestedDataById[id] = nestRow;
  }

  const xf = this.accumulatorById[id];

  this.nestedDataById[id][this.nestColName] = xf['@@transducer/step'](
    this.nestedDataById[id][this.nestColName],
    this.select(row)
  );

  return acc
}

const _xfilterBy = curryN(4, function _xfilterBy (summariseFn, predicate, by, xf) {
  return _isReducable(summariseFn)
    ? _xfilterByReducable(summariseFn, predicate, by, xf)
    : _xfilterByIrreducable(summariseFn, predicate, by, xf)
});

const filterBy = curryN(4, _dispatchable([], _xfilterBy,
  function (summariseFn, predicate, by, df) {
    return into(
      [],
      filterBy(summariseFn, predicate, by),
      df
    )
  }
));

function mutate (mutateInstructions, df) {
  const mutateFn = _getMutateFn(mutateInstructions);
  return df
    ? map(mutateFn, df)
    : map(mutateFn)
}

function _getMutateFn (mutateInstructions) {
  return row => {
    const newRow = Object.assign({}, row);

    for (const newColumnName in mutateInstructions) {
      newRow[newColumnName] = mutateInstructions[newColumnName](newRow);
    }

    return newRow
  }
}

const _xpivotLonger = curryN(2, function _xpivotLonger (pivotInstructions, xf) {
  return new XPivotLonger(pivotInstructions, xf)
});

const pivotLonger = curryN(2, _dispatchable([], _xpivotLonger,
  function (pivotInstructions, df) {
    return into(
      [],
      pivotLonger(pivotInstructions),
      df
    )
  }
));

function XPivotLonger ({ columns, namesTo, valuesTo }, xf) {
  this.pivotColumns = columns;
  this.pivotColumnsSet = new Set(columns);
  this.namesTo = namesTo;
  this.valuesTo = valuesTo;
  this.xf = xf;

  this.columns = null;
  this.idColumns = null;

  this.init = true;
}

XPivotLonger.prototype['@@transducer/init'] = _xfBase.init;
XPivotLonger.prototype['@@transducer/result'] = _xfBase.result;
XPivotLonger.prototype['@@transducer/step'] = function (acc, row) {
  if (this.init) {
    this._initStep(acc, row);
    this.init = false;
  }

  return this._step(acc, row)
};
XPivotLonger.prototype._initStep = _initStep$2;
XPivotLonger.prototype._step = _step$6;

function _initStep$2 (acc, row) {
  this.columns = Object.keys(row);

  this.idColumns = this.columns.filter(
    columnName => !this.pivotColumnsSet.has(columnName)
  );
}

function _step$6 (acc, row) {
  const newRows = [];

  for (let j = 0; j < this.pivotColumns.length; j++) {
    const newRow = {};

    const pivotColumnName = this.pivotColumns[j];
    const pivotColumnValue = row[pivotColumnName];

    newRow[this.namesTo] = pivotColumnName;
    newRow[this.valuesTo] = pivotColumnValue;

    for (let k = 0; k < this.idColumns.length; k++) {
      const idColumnName = this.idColumns[k];
      newRow[idColumnName] = row[idColumnName];
    }

    newRows.push(newRow);
  }

  return reduce(
    this.xf['@@transducer/step'].bind(this.xf),
    acc,
    newRows
  )
}

const _xpivotWider = curryN(2, function _xpivotWider (pivotInstructions, xf) {
  return new XPivotWider(pivotInstructions, xf)
});

const pivotWider = curryN(2, _dispatchable([], _xpivotWider,
  function (pivotInstructions, df) {
    return into(
      [],
      pivotWider(pivotInstructions),
      df
    )
  }
));

function XPivotWider ({ namesFrom, valuesFrom, valuesFill = null }, xf) {
  this.namesFrom = namesFrom;
  this.valuesFrom = valuesFrom;
  this.valuesFill = valuesFill;
  this.xf = xf;

  this.idColumns = null;
  this.widerRowsById = {};
  this.newColumnsSet = new Set();
  this.newColumns = null;

  this.init = true;
}

XPivotWider.prototype['@@transducer/init'] = _xfBase.init;
XPivotWider.prototype['@@transducer/result'] = _result$5;
XPivotWider.prototype['@@transducer/step'] = function (acc, row) {
  if (this.init) {
    this._initStep(acc, row);
    this.init = false;
  }

  return this._step(acc, row)
};
XPivotWider.prototype._initStep = _initStep$3;
XPivotWider.prototype._step = _step$7;
XPivotWider.prototype._finalStep = _finalStep$2;

function _result$5 () {
  this.newColumns = Array.from(this.newColumnsSet);

  return this.xf['@@transducer/result'](_reduceObjVals(
    this._finalStep.bind(this),
    this.xf['@@transducer/init'](),
    this.widerRowsById
  ))
}

function _initStep$3 (acc, row) {
  const columns = Object.keys(row);
  const nonIdColumns = [this.namesFrom, this.valuesFrom];
  this.idColumns = columns.filter(c => !nonIdColumns.includes(c));
}

function _step$7 (acc, row) {
  const id = _idFromCols(row, this.idColumns);
  const newId = !(id in this.widerRowsById);

  if (newId) {
    const widerRow = {};

    for (let i = 0; i < this.idColumns.length; i++) {
      const idColumn = this.idColumns[i];
      widerRow[idColumn] = row[idColumn];
    }

    this.widerRowsById[id] = widerRow;
  }

  const column = row[this.namesFrom];
  const value = row[this.valuesFrom];

  this.widerRowsById[id][column] = value;
  this.newColumnsSet.add(column);
}

function _finalStep$2 (acc, row) {
  for (let i = 0; i < this.newColumns.length; i++) {
    const newColumn = this.newColumns[i];

    if (!(newColumn in row)) {
      row[newColumn] = this.valuesFill;
    }
  }

  return this.xf['@@transducer/step'](acc, row)
}

function rename (renameInstructions, df) {
  const renameFn = _getRenameFn(renameInstructions);
  return df
    ? map(renameFn, df)
    : map(renameFn)
}

function _getRenameFn (renameInstructions) {
  return row => {
    const newRow = Object.assign({}, row);

    for (const newCol in renameInstructions) {
      const oldCol = renameInstructions[newCol];
      newRow[newCol] = newRow[oldCol];
      delete newRow[oldCol];
    }

    return newRow
  }
}

function _reduced (x) {
  return x && x['@@transducer/reduced']
    ? x
    : {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    }
}

const _xslice = curryN(2, function _xslice (indices, xf) {
  return new XSlice(indices, xf)
});

const slice = curryN(2, _dispatchable([], _xslice,
  function (indices, df) {
    return into(
      [],
      slice(indices),
      df
    )
  }
));

function XSlice (indices, xf) {
  this.indices = new Set(indices);
  this.xf = xf;

  this.counter = -1;
}

XSlice.prototype['@@transducer/init'] = _xfBase.init;
XSlice.prototype['@@transducer/result'] = _xfBase.result;
XSlice.prototype['@@transducer/step'] = function (acc, row) {
  this.counter++;

  if (this.indices.has(this.counter)) {
    this.indices.delete(this.counter);
    const output = this.xf['@@transducer/step'](acc, row);

    return this.indices.size === 0
      ? _reduced(output)
      : output
  }

  return acc
};

const _xunnest = curryN(3, function _xunnest (nestColName, nestWrapper, xf) {
  return new XUnnest(nestColName, nestWrapper, xf)
});

const unnest = curryN(3, _dispatchable([], _xunnest,
  function (nestColName, nestWrapper, df) {
    return into(
      [],
      unnest(nestColName, nestWrapper),
      df
    )
  }
));

function XUnnest (nestColName, nestWrapper, xf) {
  this.nestColName = nestColName;
  this.nestWrapper = nestWrapper;
  this.xf = xf;
  this.outerColumns = [];

  this.init = true;
}

XUnnest.prototype['@@transducer/init'] = _xfBase.init;
XUnnest.prototype['@@transducer/result'] = _xfBase.result;
XUnnest.prototype['@@transducer/step'] = function (acc, row) {
  if (this.init) {
    this._initStep(acc, row);
    this.init = false;
  }

  return this._step(acc, row)
};

XUnnest.prototype._initStep = function (acc, row) {
  for (const columnName in row) {
    if (columnName !== this.nestColName) {
      this.outerColumns.push(columnName);
    }
  }
};

XUnnest.prototype._step = function (acc, row) {
  const nestedData = row[this.nestColName];

  const rowWithoutNested = Object.assign({}, row);
  delete rowWithoutNested[this.nestColName];

  return reduce(
    (innerAcc, innerRow) => this.xf[['@@transducer/step']](
      innerAcc,
      _attach(innerRow, rowWithoutNested)
    ),
    acc,
    this.nestWrapper(nestedData)
  )
};

function _attach (innerRow, outerRow) {
  const newRow = Object.assign({}, innerRow);

  for (const columnName in outerRow) {
    newRow[columnName] = outerRow[columnName];
  }

  return newRow
}

export { arrange, ascending, ascendingStr, columnOriented, count, descending, ascendingStr$1 as descendingStr, filterBy, geojson, max, mean, median, min, mode, mutate, nestBy, pivotLonger, pivotWider, rename, select, slice, sum, summariseBy, unnest };
